<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TiDB Development Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">TiDB Development Guide</a></li><li class="chapter-item expanded "><a href="get-started/introduction.html"><strong aria-hidden="true">1.</strong> Get Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="get-started/install-golang.html"><strong aria-hidden="true">1.1.</strong> Install Golang</a></li><li class="chapter-item expanded "><a href="get-started/build-tidb-from-source.html"><strong aria-hidden="true">1.2.</strong> Get the code, build and run</a></li><li class="chapter-item expanded "><a href="get-started/setup-an-ide.html"><strong aria-hidden="true">1.3.</strong> Setup an IDE</a></li><li class="chapter-item expanded "><a href="get-started/write-and-run-unit-tests.html"><strong aria-hidden="true">1.4.</strong> Write and run unit tests</a></li><li class="chapter-item expanded "><a href="get-started/debug-and-profile.html"><strong aria-hidden="true">1.5.</strong> Debug and profile</a></li><li class="chapter-item expanded "><a href="get-started/commit-code-and-submit-a-pull-request.html"><strong aria-hidden="true">1.6.</strong> Commit code and submit a pull request</a></li></ol></li><li class="chapter-item expanded "><a href="contribute-to-tidb/introduction.html"><strong aria-hidden="true">2.</strong> Contribute to TiDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribute-to-tidb/community-guideline.html"><strong aria-hidden="true">2.1.</strong> Community Guideline</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/committer-guide.html"><strong aria-hidden="true">2.2.</strong> Committer Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/report-an-issue.html"><strong aria-hidden="true">2.3.</strong> Report an Issue</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/contribute-code.html"><strong aria-hidden="true">2.4.</strong> Contribute Code</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/review-a-pr.html"><strong aria-hidden="true">2.5.</strong> Review a Pull Request</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/make-a-proposal.html"><strong aria-hidden="true">2.6.</strong> Make a Proposal</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/code-style-and-quality-guide.html"><strong aria-hidden="true">2.7.</strong> Code Style and Quality Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/write-document.html"><strong aria-hidden="true">2.8.</strong> Write Document</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/miscellaneous-topics.html"><strong aria-hidden="true">2.9.</strong> Miscellaneous Topics</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/introduction.html"><strong aria-hidden="true">3.</strong> Understand TiDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/the-lifecycle-of-a-statement.html"><strong aria-hidden="true">3.1.</strong> The Lifecycle of a Statement</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/ddl.html"><strong aria-hidden="true">3.1.1.</strong> DDL</a></li><li class="chapter-item expanded "><a href="understand-tidb/dml.html"><strong aria-hidden="true">3.1.2.</strong> DML</a></li><li class="chapter-item expanded "><a href="understand-tidb/dql.html"><strong aria-hidden="true">3.1.3.</strong> DQL</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/parser.html"><strong aria-hidden="true">3.2.</strong> Parser</a></li><li class="chapter-item expanded "><a href="understand-tidb/planner.html"><strong aria-hidden="true">3.3.</strong> Planner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/table-statistics.html"><strong aria-hidden="true">3.3.1.</strong> Table Statistics</a></li><li class="chapter-item expanded "><a href="understand-tidb/rbo.html"><strong aria-hidden="true">3.3.2.</strong> Rule-based Optimization</a></li><li class="chapter-item expanded "><a href="understand-tidb/cbo.html"><strong aria-hidden="true">3.3.3.</strong> Cost-based Optimization</a></li><li class="chapter-item expanded "><a href="understand-tidb/plan-cache.html"><strong aria-hidden="true">3.3.4.</strong> Plan Cache</a></li><li class="chapter-item expanded "><a href="understand-tidb/sql-plan-management.html"><strong aria-hidden="true">3.3.5.</strong> SQL Plan Management</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/execution.html"><strong aria-hidden="true">3.4.</strong> Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/parallel-execution-framework.html"><strong aria-hidden="true">3.4.1.</strong> Parallel Execution Framework</a></li><li class="chapter-item expanded "><a href="understand-tidb/implementation-of-vectorized-execution.html"><strong aria-hidden="true">3.4.2.</strong> Implementation of Vectorized Execution</a></li><li class="chapter-item expanded "><a href="understand-tidb/memory-management-mechanism.html"><strong aria-hidden="true">3.4.3.</strong> Memory Management Mechanism</a></li><li class="chapter-item expanded "><a href="understand-tidb/implementation-of-typical-operators.html"><strong aria-hidden="true">3.4.4.</strong> Implementation of Typical Operators</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/transaction.html"><strong aria-hidden="true">3.5.</strong> Transaction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/transaction-on-tikv.html"><strong aria-hidden="true">3.5.1.</strong> Transaction on TiKV</a></li><li class="chapter-item expanded "><a href="understand-tidb/optimistic-transaction.html"><strong aria-hidden="true">3.5.2.</strong> Optimistic Transaction</a></li><li class="chapter-item expanded "><a href="understand-tidb/lock-resolver.html"><strong aria-hidden="true">3.5.3.</strong> Lock Resolver</a></li><li class="chapter-item expanded "><a href="understand-tidb/pessimistic-transaction.html"><strong aria-hidden="true">3.5.4.</strong> Pessimistic Transaction</a></li><li class="chapter-item expanded "><a href="understand-tidb/async-commit.html"><strong aria-hidden="true">3.5.5.</strong> Async Commit</a></li><li class="chapter-item expanded "><a href="understand-tidb/1pc.html"><strong aria-hidden="true">3.5.6.</strong> 1PC</a></li><li class="chapter-item expanded "><a href="understand-tidb/mvcc-garbage-collection.html"><strong aria-hidden="true">3.5.7.</strong> MVCC garbage collection</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/session.html"><strong aria-hidden="true">3.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="understand-tidb/privilege.html"><strong aria-hidden="true">3.7.</strong> Privilege</a></li><li class="chapter-item expanded "><a href="understand-tidb/plugin.html"><strong aria-hidden="true">3.8.</strong> Plugin</a></li></ol></li><li class="chapter-item expanded "><a href="project-management/introduction.html"><strong aria-hidden="true">4.</strong> Project Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project-management/release-train-model.html"><strong aria-hidden="true">4.1.</strong> Releases Train Model</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">TiDB Development Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/pingcap/tidb-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tidb-development-guide"><a class="header" href="#tidb-development-guide">TiDB Development Guide</a></h1>
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
<p><a href="index.html#contributors-"><img src="https://img.shields.io/badge/all_contributors-29-orange.svg?style=flat-square" alt="All Contributors" /></a></p>
<!-- ALL-CONTRIBUTORS-BADGE:END -->
<h2 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h2>
<ul>
<li><strong>The target audience</strong> of this guide is TiDB contributors, both new and experienced.</li>
<li><strong>The objective</strong> of this guide is to help contributors become an expert of TiDB, who is familiar with its design and implementation and thus is able to use it fluently in the real world as well as develop TiDB itself deeply.</li>
</ul>
<h2 id="the-structure-of-this-guide"><a class="header" href="#the-structure-of-this-guide">The structure of this guide</a></h2>
<p>At present, the guide is composed of the following parts:</p>
<ol>
<li><strong>Get started:</strong> Setting up the development environment, build and connect to the tidb-server, the subsections are based on an imagined newbie user journey.</li>
<li><strong>Contribute to TiDB</strong> helps you quickly get involved in the TiDB community, which illustrates what contributions you can make and how to quickly make one.</li>
<li><strong>Understand TiDB</strong>: helps you to be familiar with basic distributed database concepts, build a knowledge base in your mind, including but not limited to SQL language, key components, algorithms in a distributed database. The audiences who are already familiar with these concepts can skip this section.</li>
<li><strong>Project Management</strong>: helps you to participate in team working, lead feature development, manage projects in the TiDB community.</li>
</ol>
<h2 id="contributors-"><a class="header" href="#contributors-">Contributors âœ¨</a></h2>
<p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p>
<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/LittleFall"><img src="https://avatars.githubusercontent.com/u/30543181?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Zhi Qi</b></sub></a><br /><a href="index.html#content-LittleFall" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://tisonkun.github.io/Miracle/"><img src="https://avatars.githubusercontent.com/u/18818196?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tison</b></sub></a><br /><a href="index.html#content-tisonkun" title="Content">ðŸ–‹</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Atisonkun" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="http://zz-jason.github.io/"><img src="https://avatars.githubusercontent.com/u/5268763?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Jian Zhang</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Azz-jason" title="Reviewed Pull Requests">ðŸ‘€</a> <a href="index.html#content-zz-jason" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/qiancai"><img src="https://avatars.githubusercontent.com/u/79440533?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Grace Cai</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aqiancai" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://ichn.xyz"><img src="https://avatars.githubusercontent.com/u/29735669?v=4?s=100" width="100px;" alt=""/><br /><sub><b>è™Ž</b></sub></a><br /><a href="index.html#content-ichn-hu" title="Content">ðŸ–‹</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aichn-hu" title="Reviewed Pull Requests">ðŸ‘€</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/bb7133"><img src="https://avatars.githubusercontent.com/u/1174042?v=4?s=100" width="100px;" alt=""/><br /><sub><b>bb7133</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Abb7133" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://www.linkedin.com/in/gregabramowitzweber"><img src="https://avatars.githubusercontent.com/u/1183?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Greg Weber</b></sub></a><br /><a href="index.html#content-gregwebs" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/djshow832"><img src="https://avatars.githubusercontent.com/u/29590578?v=4?s=100" width="100px;" alt=""/><br /><sub><b>djshow832</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adjshow832" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="http://www.zenlife.tk"><img src="https://avatars.githubusercontent.com/u/1420062?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tiancaiamao</b></sub></a><br /><a href="index.html#content-tiancaiamao" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/tomdewan"><img src="https://avatars.githubusercontent.com/u/50153616?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tomdewan</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Atomdewan" title="Reviewed Pull Requests">ðŸ‘€</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/disksing"><img src="https://avatars.githubusercontent.com/u/12077877?v=4?s=100" width="100px;" alt=""/><br /><sub><b>disksing</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adisksing" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://www.hawkingrei.com/blog/"><img src="https://avatars.githubusercontent.com/u/3427324?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Weizhen Wang</b></sub></a><br /><a href="index.html#content-hawkingrei" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/TomShawn"><img src="https://avatars.githubusercontent.com/u/41534398?v=4?s=100" width="100px;" alt=""/><br /><sub><b>TomShawn</b></sub></a><br /><a href="index.html#content-TomShawn" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/mjonss"><img src="https://avatars.githubusercontent.com/u/5520054?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Mattias Jonsson</b></sub></a><br /><a href="index.html#content-mjonss" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="http://www.tocker.ca/"><img src="https://avatars.githubusercontent.com/u/57982?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Morgan Tocker</b></sub></a><br /><a href="index.html#content-morgo" title="Content">ðŸ–‹</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Amorgo" title="Reviewed Pull Requests">ðŸ‘€</a></td>
  </tr>
  <tr>
    <td align="center"><a href="http://databaseblog.myname.nl"><img src="https://avatars.githubusercontent.com/u/1272980?v=4?s=100" width="100px;" alt=""/><br /><sub><b>DaniÃ«l van Eeden</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adveeden" title="Reviewed Pull Requests">ðŸ‘€</a> <a href="index.html#content-dveeden" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://xxchan.github.io"><img src="https://avatars.githubusercontent.com/u/37948597?v=4?s=100" width="100px;" alt=""/><br /><sub><b>xxchan</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Axxchan" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://www.iamhlbx.xyz"><img src="https://avatars.githubusercontent.com/u/50866227?v=4?s=100" width="100px;" alt=""/><br /><sub><b>iamhlbx</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3AHuGanghui" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://github.com/sunxiaoguang"><img src="https://avatars.githubusercontent.com/u/3982329?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Xiaoguang Sun</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Asunxiaoguang" title="Reviewed Pull Requests">ðŸ‘€</a> <a href="index.html#content-sunxiaoguang" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/eurekaka"><img src="https://avatars.githubusercontent.com/u/6261973?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Kenan Yao</b></sub></a><br /><a href="index.html#content-eurekaka" title="Content">ðŸ–‹</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://about.me/li.su"><img src="https://avatars.githubusercontent.com/u/528332?v=4?s=100" width="100px;" alt=""/><br /><sub><b>lysu</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Alysu" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://github.com/cfzjywxk"><img src="https://avatars.githubusercontent.com/u/3692139?v=4?s=100" width="100px;" alt=""/><br /><sub><b>cfzjywxk</b></sub></a><br /><a href="index.html#content-cfzjywxk" title="Content">ðŸ–‹</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Acfzjywxk" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://blog.tongmu.me"><img src="https://avatars.githubusercontent.com/u/9587680?v=4?s=100" width="100px;" alt=""/><br /><sub><b>you06</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Ayou06" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://github.com/ekexium"><img src="https://avatars.githubusercontent.com/u/31720476?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ziqian Qin</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aekexium" title="Reviewed Pull Requests">ðŸ‘€</a></td>
    <td align="center"><a href="https://github.com/zhangyangyu"><img src="https://avatars.githubusercontent.com/u/3690895?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Xiang Zhang</b></sub></a><br /><a href="index.html#content-zhangyangyu" title="Content">ðŸ–‹</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/XuHuaiyu"><img src="https://avatars.githubusercontent.com/u/9039012?v=4?s=100" width="100px;" alt=""/><br /><sub><b>HuaiyuXu</b></sub></a><br /><a href="index.html#content-XuHuaiyu" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://sticnarf.me"><img src="https://avatars.githubusercontent.com/u/17217495?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yilin Chen</b></sub></a><br /><a href="index.html#content-sticnarf" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/tangenta"><img src="https://avatars.githubusercontent.com/u/24713065?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tangenta</b></sub></a><br /><a href="index.html#content-tangenta" title="Content">ðŸ–‹</a></td>
    <td align="center"><a href="https://github.com/wshwsh12"><img src="https://avatars.githubusercontent.com/u/14054293?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Shenghui Wu</b></sub></a><br /><a href="index.html#content-wshwsh12" title="Content">ðŸ–‹</a></td>
  </tr>
</table>
<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->
<p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="get-started"><a class="header" href="#get-started">Get Started</a></h1>
<p>Let's start your TiDB journey! There's a lot to learn, but every journey starts somewhere. In this chapter, we'll discuss:</p>
<ul>
<li><a href="get-started/install-golang.html">Install Golang</a></li>
<li><a href="get-started/build-tidb-from-source.html">Get the code, build and run</a></li>
<li><a href="get-started/setup-an-ide.html">Setup an IDE</a></li>
<li><a href="get-started/write-and-run-unit-tests.html">Write and run unit tests</a></li>
<li><a href="get-started/debug-and-profile.html">Debug and profile</a></li>
<li><a href="get-started/commit-code-and-submit-a-pull-request.html">Commit code and submit a pull request</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="install-golang"><a class="header" href="#install-golang">Install Golang</a></h1>
<p>To build TiDB from source code, you need to install Go in your development environment first. If Go is not installed yet, you can follow the instructions in this document for installation.</p>
<h2 id="install-go-116"><a class="header" href="#install-go-116">Install Go 1.16</a></h2>
<p>Currently, TiDB uses Go 1.16 to compile the code. To install Go 1.16, go to <a href="https://golang.org/dl/">Go's download page</a>, choose version 1.16, and then follow the <a href="https://golang.org/doc/install">installation instructions</a>.</p>
<h2 id="manage-the-go-toolchain-using-gvm"><a class="header" href="#manage-the-go-toolchain-using-gvm">Manage the Go toolchain using gvm</a></h2>
<p>If you are using Linux or MacOS, you can manage Go versions with <a href="https://github.com/moovweb/gvm">Go Version Manager (gvm)</a> easily.</p>
<p>To install gvm, run the following command:</p>
<pre><code class="language-bash">curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer | sh
</code></pre>
<p>Once you have gvm installed, you can use it to manage multiple different Go compilers with different versions. Let's install Go 1.16 and set it as default:</p>
<pre><code class="language-bash">gvm install go1.16
gvm use go1.16 --default
</code></pre>
<p>Now, you can type <code>go version</code> in the shell to verify the installation:</p>
<pre><code class="language-bash">go version
# OUTPUT:
# go version go1.16 linux/amd64
</code></pre>
<p>In the next chapter, you will learn how to obtain the TiDB source code and how to build it.</p>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="get-the-code-build-and-run"><a class="header" href="#get-the-code-build-and-run">Get the code, build, and run</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><code>git</code>: The TiDB source code is hosted on GitHub as a git repository. To work with the git repository, please <a href="https://git-scm.com/downloads">install <code>git</code></a>.</li>
<li><code>go</code>: TiDB is a Go project. Therefore, you need a working Go environment to build it. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li><code>mysql</code> client (optional): After building TiDB from source, you can use the official <a href="https://dev.mysql.com/downloads/mysql/">MySQL client</a> to connect to TiDB. It is not required if you want to build TiDB only.</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
<p>TiDB could compile and run on Windows 10. However, it is not expected to be deployed on Windows, where you might encounter many compatibility problems. To have a better experience, we recommend you <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">install WSL2</a> first.</p>
</blockquote>
<h2 id="clone"><a class="header" href="#clone">Clone</a></h2>
<p>Clone the source code to your development machine:</p>
<pre><code class="language-bash">git clone https://github.com/pingcap/tidb.git
</code></pre>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<p>Build TiDB from the source code:</p>
<pre><code class="language-bash">cd tidb
make
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Now that you have the <code>tidb-server</code> binary under the <code>bin</code> directory, execute it for a TiDB server instance:</p>
<pre><code class="language-bash">./bin/tidb-server
</code></pre>
<p>This starts the TiDB server listening on port 4000 with embedded <code>unistore</code>.</p>
<h2 id="connect"><a class="header" href="#connect">Connect</a></h2>
<p>You can use the official MySQL client to connect to TiDB:</p>
<pre><code class="language-bash">mysql -h 127.0.0.1 -P 4000 -u root -D test --prompt=&quot;tidb&gt; &quot; --comments
</code></pre>
<p>where</p>
<ul>
<li><code>-h 127.0.0.1</code> sets the Host to local host loopback interface</li>
<li><code>-P 4000</code> uses port 4000</li>
<li><code>-u root</code> connects as root user (<code>-p</code> not given; the development build has no password for root.)</li>
<li><code>-D test</code> uses the Schema/Database test</li>
<li><code>--prompt &quot;tidb&gt; &quot;</code> sets the prompt to distinguish it from a connection to MySQL</li>
<li><code>--comments</code> preserves comments like <code>/*T![clustered_index NONCLUSTERED */</code> instead of stripping them when sending the query to the server.</li>
</ul>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="setup-an-ide"><a class="header" href="#setup-an-ide">Setup an IDE</a></h1>
<p>Using an IDE is recommended as it makes it a lot easier to work with the TiDB code, for example to see the fields of a <code>struct</code>. However it is not required to use a specific IDE or editor. You can use the IDE or editor of your choice.</p>
<h2 id="goland"><a class="header" href="#goland">GoLand</a></h2>
<p>You can use <a href="https://www.jetbrains.com/go/">GoLand</a> to easily run or debug TiDB in many situations.</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li><code>go</code>: TiDB is a Go project. Therefore, you need a working Go environment to build it. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li>TiDB source code: See the previous <a href="get-started/build-tidb-from-source.html">Get the code, build and run</a> section to get the source code.</li>
</ul>
<h3 id="download-goland"><a class="header" href="#download-goland">Download GoLand</a></h3>
<p>Download GoLand from <a href="https://www.jetbrains.com/go/download">here</a> and install it.</p>
<h3 id="open-the-tidb-source-code-in-goland"><a class="header" href="#open-the-tidb-source-code-in-goland">Open the TiDB source code in GoLand</a></h3>
<p>Follow the <a href="https://www.jetbrains.com/help/go/quick-start-guide-goland.html#open-project">instructions</a> and open the  TiDB source code in GoLand.</p>
<p><img src="get-started/../img/open-tidb-in-goland.png" alt="Open TiDB source code in GoLand" /></p>
<h3 id="populate-run-configurations"><a class="header" href="#populate-run-configurations">Populate run configurations</a></h3>
<p>Under the root directory of the TiDB source code, execute the following commands to add config files:</p>
<pre><code class="language-bash">mkdir -p .idea/runConfigurations/ &amp;&amp; cd .idea/runConfigurations/

cat &lt;&lt;EOF &gt; unistore_4000.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;unistore 4000&quot; type=&quot;GoApplicationRunConfiguration&quot; factoryName=&quot;Go Application&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;kind value=&quot;PACKAGE&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb/tidb-server&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF

cat &lt;&lt;EOF &gt; playground_attach_4001.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;playground attach 4001&quot; type=&quot;GoApplicationRunConfiguration&quot; factoryName=&quot;Go Application&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;parameters value=&quot;--path=127.0.0.1:2379 --store=tikv --status=10081 -P 4001 &quot; /&gt;
    &lt;kind value=&quot;PACKAGE&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$/tidb-server/main.go&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb/tidb-server&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF

cat &lt;&lt;EOF &gt; unit_test.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;unit test&quot; type=&quot;GoTestRunConfiguration&quot; factoryName=&quot;Go Test&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;go_parameters value=&quot;-i&quot; /&gt;
    &lt;framework value=&quot;gocheck&quot; /&gt;
    &lt;kind value=&quot;DIRECTORY&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$/planner/core&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;pattern value=&quot;TestEnforceMPP&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF
</code></pre>
<p>Now, confirm there are three config files:</p>
<pre><code class="language-bash">ls
# OUTPUT:
# playground_attach_4001.xml
# unistore_4000.xml
# unit_test.xml
</code></pre>
<h3 id="run-or-debug"><a class="header" href="#run-or-debug">Run or debug</a></h3>
<p>Now you can see the run/debug configs right upper the window.</p>
<p><img src="get-started/../img/run-configs.png" alt="Run Configs" /></p>
<p>The first config is <code>unistore 4000</code>, which enables you to run/debug TiDB independently without TiKV, PD, and TiFlash.</p>
<p><img src="get-started/../img/unistore-config.png" alt="unistore config" /></p>
<p><img src="get-started/../img/unistore-output.png" alt="unistore output" /></p>
<p>The second config is <code>playground attach 4001</code>, which enables you to run/debug TiDB by attaching to an existing cluster; for example, a cluster deployed with <a href="https://docs.pingcap.com/tidb/stable/tiup-playground"><code>tiup playground</code></a>.</p>
<p>After the server process starts, you can connect to the origin TiDB by port 4000, or connect to your TiDB by port 4001 at the same time.</p>
<p><img src="get-started/../img/playground-attach-config.png" alt="playground attach config" />
<img src="get-started/../img/playground-attach-debug.png" alt="playground attach debug" /></p>
<p>The third config is <code>unit test</code>, which enables you to run/debug unit tests. You may modify the <code>Directory</code> and <code>Pattern</code> to run other tests.</p>
<p><img src="get-started/../img/unit-test-config.png" alt="unit test config" />
<img src="get-started/../img/unit-test-output.png" alt="unit test output" /></p>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>VS Code is a generic IDE that has good extensions for working with Go and TiDB.</p>
<p><img src="get-started/../img/vscode_tide.png" alt="VS Code with TiDE" /></p>
<h3 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h3>
<ul>
<li><code>go</code>: TiDB is a Go project thus its building requires a working <code>go</code> environment. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li>TiDB source code: See the previous <a href="get-started/build-tidb-from-source.html">Get the code, build and run</a> section to get the source code.</li>
</ul>
<h3 id="download-vs-code"><a class="header" href="#download-vs-code">Download VS Code</a></h3>
<p>Download VS Code from <a href="https://code.visualstudio.com/Download">here</a> and install it.</p>
<p>Now install these extensions:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=golang.Go">Go</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=dragonly.ticode">TiDE</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=github.vscode-pull-request-github">GitHub Pull Requests and Issues</a></li>
</ul>
<h3 id="work-with-tidb-code-in-vs-code"><a class="header" href="#work-with-tidb-code-in-vs-code">Work with TiDB code in VS Code</a></h3>
<p>Open the folder containing TiDB code via <code>Fileâ†’Open Folder</code>. See the <a href="https://code.visualstudio.com/docs">VS Code docs</a> for how to edit and commit code.</p>
<p>There is <a href="https://github.com/tidb-incubator/tide/blob/HEAD/doc/guide.md">detailed guide</a> explaining how to use the TiDE extension.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-and-run-unit-tests"><a class="header" href="#write-and-run-unit-tests">Write and run unit tests</a></h1>
<p>The TiDB project runs unit tests using <a href="https://github.com/stretchr/testify">testify</a>.</p>
<p>You may find tests using <a href="http://github.com/pingcap/check">pingcap/check</a> which is a fork of <a href="https://github.com/go-check/check">go-check/check</a>, but since that framework is poorly maintained, we are migrating to testify.</p>
<p>You can check the background and progress on the migration <a href="https://github.com/pingcap/tidb/issues/26022">tracking issue</a>.</p>
<h2 id="how-to-write-unit-tests"><a class="header" href="#how-to-write-unit-tests">How to write unit tests</a></h2>
<p>We use testify to write unit tests. Basically, it is out-of-the-box <a href="https://pkg.go.dev/testing">testing</a> with testify assertions.</p>
<h3 id="testmain"><a class="header" href="#testmain">TestMain</a></h3>
<p>When you run tests, Golang compiles each package along with any files with names with suffix <code>_test.go</code>. Thus, a test binary contains tests in a package.</p>
<p>Golang testing provides a mechanism to support doing extra setup or teardown before or after testing by writing a package level unique function:</p>
<pre><code class="language-go">func TestMain(m *testing.M)
</code></pre>
<p>After all tests finish, we leverage the function to detect Goroutine leaks by <a href="https://github.com/uber-go/goleak">goleak</a>.</p>
<p>Before you write any unit tests in a package, create a file named <code>main_test.go</code> and setup the scaffolding:</p>
<pre><code class="language-go">func TestMain(m *testing.M) {
    goleak.VerifyTestMain(m)
}
</code></pre>
<p>You can also put global variables or helper functions of the test binary in this file.</p>
<h3 id="assertion"><a class="header" href="#assertion">Assertion</a></h3>
<p>Let's write a basic test for the utility function <code>StrLenOfUint64Fast</code>:</p>
<pre><code class="language-go">func TestStrLenOfUint64Fast(t *testing.T) {
    for i := 0; i &lt; 1000000; i++ {
        num := rand.Uint64()
        expected := len(strconv.FormatUint(num, 10))
        actual := StrLenOfUint64Fast(num)
        require.Equal(t, expected, actual)
    }
}
</code></pre>
<p>Golang testing detects test functions from <code>*_test.go</code> files of the form:</p>
<pre><code class="language-go">func TestXxx(*testing.T)
</code></pre>
<p>where <code>Xxx</code> does not start with a lowercase letter. The function name identifies the test routine.</p>
<p>We follow this pattern but use testify assertions instead of out-of-the-box methods, like <code>Error</code> or <code>Fail</code>, since they are too low level to use.</p>
<p>We mostly use <code>require.Xxx</code> for assertions, which is imported from <code>github.com/stretchr/testify/require</code>. If the assertions fail, the test fails immediately, and we tend to fail tests fast.</p>
<p>Below are the most frequently used assertions:</p>
<pre><code class="language-go">func Equal(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{})
func EqualValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{})
func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{})
func Nil(t TestingT, object interface{}, msgAndArgs ...interface{})
func NoError(t TestingT, err error, msgAndArgs ...interface{})
func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{})
func True(t TestingT, value bool, msgAndArgs ...interface{})
</code></pre>
<p>You can find other assertions follow the <a href="https://pkg.go.dev/github.com/stretchr/testify/require">documentation</a>.</p>
<h3 id="parallel"><a class="header" href="#parallel">Parallel</a></h3>
<p>Golang testing provides a method of <code>testing.T</code> to run tests in parallel:</p>
<pre><code class="language-go">t.Parallel()
</code></pre>
<p>We leverage this function to run tests as parallel as possible, so that we make full use of the available resource.</p>
<p>When some tests should be run in serial, use Golang testing <a href="https://pkg.go.dev/testing#hdr-Subtests_and_Sub_benchmarks">subtests</a> and parallel the parent test only. In this way, tests in the same subtests set run in serial.</p>
<pre><code class="language-go">func TestParent(t *testing.T) {
    t.Parallel()
    // &lt;setup code&gt;
    t.Run(&quot;Serial 0&quot;, func(t *testing.T) { ... })
    t.Run(&quot;Serial 1&quot;, func(t *testing.T) { ... })
    t.Run(&quot;Serial 2&quot;, func(t *testing.T) { ... })
    // &lt;tear-down code&gt;
}
</code></pre>
<p>Generally, if a test modifies global configs or fail points, it should be run in serial.</p>
<p>When writing parallel tests, there are several common considerations.</p>
<p>In Golang, the loop iterator variable is a single variable that takes different value in each loop iteration. Thus, when you run this code it is highly possible to see the last element used for every iteration. You may use below paradigm to work around.</p>
<pre><code class="language-go">func TestParallelWithRange(t *testing.T) {
    for _, test := range tests {
        // copy iterator variable into a new variable, see issue #27779 in tidb repo
        test := test
        t.Run(test.Name, func(t *testing.T) {
            t.Parallel()
            ...
        })
    }
}
</code></pre>
<h3 id="test-kits"><a class="header" href="#test-kits">Test kits</a></h3>
<p>Most of our tests are much more complex than what we describe above. For example, to set up a test, we may create a mock storage, a mock session, or even a local database instance.</p>
<p>These functions are known as test kits. Some are used in one package so we implement them in place; others are quite common so we move it to the <code>testkit</code> directory.</p>
<p>When you write complex unit tests, you may take a look at what test kits we have now and try to leverage them. If we donâ€™t have a test kit for your issue and your issue is considered common, add one.</p>
<h2 id="how-to-run-unit-tests"><a class="header" href="#how-to-run-unit-tests">How to run unit tests</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running all tests</a></h3>
<p>You can always run all tests by executing the <code>gotest</code> target in Makefile:</p>
<pre><code>make gotest
</code></pre>
<p>This is almost equivalent to <code>go test ./...</code> but it enables and disables fail points before and after running tests.</p>
<p><a href="https://github.com/pingcap/failpoint">pingcap/failpoint</a> is an implementation of <a href="https://www.freebsd.org/cgi/man.cgi?query=fail">failpoints</a> for Golang. A fail point is used to add code points where you can inject errors. Fail point is a code snippet that is only executed when the corresponding fail point is active.</p>
<h3 id="running-a-single-test"><a class="header" href="#running-a-single-test">Running a single test</a></h3>
<p>To run a single test, you can manually repeat what <code>make gotest</code> does and narrow the scope in one test or one package:</p>
<pre><code>make failpoint-enable
cd domain
go test -v -run TestSchemaValidator # or with any other test flags
cd ..
make failpoint-disable
</code></pre>
<p>To display information on all the test flags, enter <code>go help testflag</code>.</p>
<p>If you develop with GoLand, you can also run a test from the IDE with manually enabled and disabled fail points. See the <a href="https://www.jetbrains.com/help/go/performing-tests.html">documentation</a> for details.</p>
<p><img src="get-started/../img/goland-run-tests.png" alt="GoLand Run Tests" /></p>
<p>As shown above, you can run tests of the whole package, of a test, or of a subtest, by click the corresponding gutter icon.</p>
<p>If you develop with VS Code, you can also run a test from the editor with manually enabled and disabled fail points. See the <a href="https://code.visualstudio.com/docs/languages/go#_test">documentation</a> for details.</p>
<p><img src="get-started/../img/vscode-run-tests.png" alt="VS Code Run Tests" /></p>
<p>As shown above, you can run tests of the whole package, of a test, or of a file.</p>
<h3 id="running-tests-for-a-pull-request"><a class="header" href="#running-tests-for-a-pull-request">Running tests for a pull request</a></h3>
<p>Before you merge a pull request, it must pass all tests.</p>
<p>Generally, continuous integration (CI) runs the tests for you; however, if you want to run tests with conditions or rerun tests on failure, you should know how to do that.</p>
<h4 id="rebuild"><a class="header" href="#rebuild"><code>/rebuild</code></a></h4>
<p>Build the binary based on the PR for testing. It also reruns all the CI test cases.</p>
<h4 id="run-all-tests"><a class="header" href="#run-all-tests"><code>/run-all-tests</code></a></h4>
<p>Rerun all the CI test cases. This command accepts the following parameters:</p>
<ul>
<li><code>tidb=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tidb to use.</li>
<li><code>tikv=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tikv to use.</li>
<li><code>pd=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which pd to use.</li>
<li><code>tidb-test=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tidb-test to use.</li>
<li><code>tidb-private-test=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tidb-private-test to use.</li>
</ul>
<p>For example:</p>
<pre><code>/run-all-tests tidb-test=pr/666
/run-all-tests tidb-test=release-2.1
/run-all-tests tikv=pr/999
</code></pre>
<h4 id="run-test"><a class="header" href="#run-test"><code>/run-{{test}}</code></a></h4>
<p>Run a single CI test. This command accepts the same parameters as <code>/run-all-tests</code>.</p>
<h2 id="how-to-find-failed-tests"><a class="header" href="#how-to-find-failed-tests">How to find failed tests</a></h2>
<p>There are several common causes of failed tests.</p>
<h3 id="assertion-failed"><a class="header" href="#assertion-failed">Assertion failed</a></h3>
<p>The most common cause of failed tests is that assertion failed. Its failure report looks like:</p>
<pre><code>=== RUN   TestTopology
    info_test.go:72: 
            Error Trace:    info_test.go:72
            Error:          Not equal: 
                            expected: 1282967700000
                            actual  : 1628585893
            Test:           TestTopology
--- FAIL: TestTopology (0.76s)
</code></pre>
<p>To find this type of failure, enter <code>grep -i &quot;FAIL&quot;</code> to search the report output.</p>
<h3 id="data-race"><a class="header" href="#data-race">Data race</a></h3>
<p>Golang testing supports detecting data race by running tests with the <code>-race</code> flag. Its failure report looks like:</p>
<pre><code>[2021-06-21T15:36:38.766Z] ==================
[2021-06-21T15:36:38.766Z] WARNING: DATA RACE
[2021-06-21T15:36:38.766Z] Read at 0x00c0055ce380 by goroutine 108:
...
[2021-06-21T15:36:38.766Z] Previous write at 0x00c0055ce380 by goroutine 169:
[2021-06-21T15:36:38.766Z]   [failed to restore the stack]
</code></pre>
<h3 id="goroutine-leak"><a class="header" href="#goroutine-leak">Goroutine leak</a></h3>
<p>We use goleak to detect goroutine leak for tests. Its failure report looks like:</p>
<pre><code>goleak: Errors on successful test run: found unexpected goroutines:
[Goroutine 104 in state chan receive, with go.etcd.io/etcd/pkg/logutil.(*MergeLogger).outputLoop on top of the stack:
goroutine 104 [chan receive]:
go.etcd.io/etcd/pkg/logutil.(*MergeLogger).outputLoop(0xc000197398)
    /go/pkg/mod/go.etcd.io/etcd@v0.5.0-alpha.5.0.20200824191128-ae9734ed278b/pkg/logutil/merge_logger.go:173 +0x3ac
created by go.etcd.io/etcd/pkg/logutil.NewMergeLogger
    /go/pkg/mod/go.etcd.io/etcd@v0.5.0-alpha.5.0.20200824191128-ae9734ed278b/pkg/logutil/merge_logger.go:91 +0x85

</code></pre>
<p>To  determine the source of package leaks, see the <a href="https://github.com/uber-go/goleak/#determine-source-of-package-leaks">documentation</a></p>
<h3 id="timeout"><a class="header" href="#timeout">Timeout</a></h3>
<p>After @tiancaiamao introduced the timeout checker for continuous integration, every test case should run in at most five seconds.</p>
<p>If a test case takes longer, its failure report looks like:</p>
<pre><code>[2021-08-09T03:33:57.661Z] The following test cases take too long to finish:
[2021-08-09T03:33:57.661Z] PASS: tidb_test.go:874: tidbTestSerialSuite.TestTLS  7.388s
[2021-08-09T03:33:57.661Z] --- PASS: TestCluster (5.20s)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debug-and-profile"><a class="header" href="#debug-and-profile">Debug and profile</a></h1>
<p>In this section, you will learn:</p>
<ul>
<li>How to debug TiDB</li>
<li>How to pause the execution at any line of code to inspect values and stacks</li>
<li>How to profile TiDB to catch a performance bottleneck</li>
</ul>
<h2 id="use-delve-for-debugging"><a class="header" href="#use-delve-for-debugging">Use delve for debugging</a></h2>
<p><a href="https://github.com/go-delve/delve">Delve</a> is a debugger for the Go programming language. It provides a command-line debugging experience similar to the GNU Project debugger (GDB), but it is much more Go native than GDB itself.</p>
<h3 id="install-delve"><a class="header" href="#install-delve">Install delve</a></h3>
<p>To install delve, see the <a href="https://github.com/go-delve/delve/tree/master/Documentation/installation">installation guide</a>. After the installation, depending on how you set your environment variables, you will have an executable file named <code>dlv</code> in either <code>$GOPATH/bin</code> or <code>$HOME/go/bin</code>. You can then run the following command to verify the installation:</p>
<pre><code>$ dlv version
Delve Debugger
Version: 1.5.0
Build: $Id: ca5318932770ca063fc9885b4764c30bfaf8a199 $
</code></pre>
<h3 id="attach-delve-to-a-running-tidb-process"><a class="header" href="#attach-delve-to-a-running-tidb-process">Attach delve to a running TiDB process</a></h3>
<p>Once you get the TiDB server running, you can attach the delve debugger.</p>
<p>For example, you can build and run a standalone TiDB server by running the following commands in the root directory of the source code:</p>
<pre><code class="language-bash">make server
./bin/tidb-server
</code></pre>
<p>You can then start a new shell and use <code>ps</code> or <code>pgrep</code> to find the PID of the tidb server process you just started:</p>
<pre><code class="language-bash">pgrep tidb-server
# OUTPUT:
# 1394942
</code></pre>
<p>If the output lists multiple PIDs, it indicates that you might have multiple TiDB servers running at the same time. To determine the PID of the tidb server you are planning to debug, you can use commands such as <code>ps $PID</code>, where <code>$PID</code> is the PID you are trying to know more about:</p>
<pre><code class="language-bash">ps 1394942
# OUTPUT:
#     PID TTY      STAT   TIME COMMAND
# 1394942 pts/11   SNl    0:02 ./bin/tidb-server
</code></pre>
<p>Once you get the PID, you can attach delve to it by running the following command:</p>
<pre><code class="language-bash">dlv attach 1394942
</code></pre>
<p>You might get error messages of the kernel security setting as follows:</p>
<pre><code>Could not attach to pid 1394942: this could be caused by a kernel security setting, try writing &quot;0&quot; to /proc/sys/kernel/yama/ptrace_scope
</code></pre>
<p>To resolve the error, follow the instructions provided in the error message and execute the following command as the root user to override the kernel security setting:</p>
<pre><code class="language-bash">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope
</code></pre>
<p>Then retry attaching delve onto the PID, and it should work.</p>
<p>If you've worked with GDB, the delve debugging interface will look familiar to you. It is an interactive dialogue that allows you to interact with the execution of the tidb server attached on. To learn more about delve, you can type help into the dialogue and read the <code>help</code> messages.</p>
<h3 id="use-delve-for-debugging-1"><a class="header" href="#use-delve-for-debugging-1">Use delve for debugging</a></h3>
<p>After attaching delve to the running TiDB server process, you can now set breakpoints. TiDB server will pause execution at the breakpoints you specify.</p>
<p>To create a breakpoint, you can write:</p>
<pre><code>break [name] &lt;linespec&gt;
</code></pre>
<p>where <code>[name]</code> is the name for the breakpoint, and <code>&lt;linespec&gt;</code> is the position of a line of code in the source code. Note the name is optional.</p>
<p>For example, the following command creates a breakpoint at the <code>Next</code> function of <code>HashJoinExec</code>. (The line number can be subject to change due to the modification of the source code).</p>
<pre><code class="language-bash">dlv debug tidb-server/main.go
# OUTPUT:
# Type 'help' for list of commands.
# (dlv) break executor/join.go:653
# Breakpoint 1 (enabled) set at 0x36752d8 for github.com/pingcap/tidb/executor.(*HashJoinExec).Next() ./executor/join.go:653
# (dlv)
</code></pre>
<p>Once the execution is paused, the context of the execution is fully preserved. You are free to inspect the values of different variables, print the calling stack, and even jump between different goroutines. Once you finish the inspection, you can resume the execution by stepping into the next line of code or continue the execution until the next breakpoint is encountered.</p>
<p>Typically, when you use a debugger, you need to take the following steps:</p>
<ol>
<li>Locate the code and set a breakpoint.</li>
<li>Prepare data so that the execution will get through the breakpoint, and pause at the specified breakpoint as expected.</li>
<li>Inspect values and follow the execution step by step.</li>
</ol>
<h3 id="using-delve-to-debug-a-test-case"><a class="header" href="#using-delve-to-debug-a-test-case">Using delve to debug a test case</a></h3>
<p>If a test case fails, you can also use delve to debug it. Get the name of the test case, go to the corresponding package directory, and then run the following command to start a debugging session that will stop at the entry of the test:</p>
<pre><code>dlv test -- -run TestName
</code></pre>
<h3 id="understand-how-tidb-works-through-debugging"><a class="header" href="#understand-how-tidb-works-through-debugging">Understand how TiDB works through debugging</a></h3>
<p>Besides debugging problems, you can also use the debugger to understand how TiDB works through tracking the execution step by step.</p>
<p>To understand TiDB internals, it's critical that you understand certain functions. To better understand how TiDB works, you can pause the execution of these TiDB functions, and then run TiDB step by step.</p>
<p>For example:</p>
<ol>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/executor/compiler.go#L48"><code>executor/compiler.go:Compile</code></a> is where each SQL statement is compiled and optimized.</li>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/planner/optimize.go#L80"><code>planner/planner.go:Optimize</code></a> is where the SQL optimization starts.</li>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/executor/adapter.go#L312"><code>executor/adapter.go:ExecStmt.Exec</code></a> is where the SQL plan turns into executor and where the SQL execution starts.</li>
<li>Each executor's <code>Open</code>, <code>Next</code>, and <code>Close</code> function marks the volcano-style execution logic.</li>
</ol>
<p>When you are reading the TiDB source code, you are strongly encouraged to set a breakpoint and use the debugger to trace the execution whenever you are confused or uncertain about the code.</p>
<h2 id="using-pprof-for-profiling"><a class="header" href="#using-pprof-for-profiling">Using <code>pprof</code> for profiling</a></h2>
<p>For any database system, performance is always important. If you want to know where the performance bottleneck is, you can use a powerful Go profiling tool called <code>pprof</code>.</p>
<h3 id="gather-runtime-profiling-information-through-http-end-points"><a class="header" href="#gather-runtime-profiling-information-through-http-end-points">Gather runtime profiling information through HTTP end points</a></h3>
<p>Usually, when TiDB server is running, it exposes a profiling end point through HTTP at <code>http://127.0.0.1:10080/debug/pprof/profile</code>. You can get the profile result by running the following commands:</p>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/profile?seconds=45&quot; &gt; profile.profile
go tool pprof -http 127.0.0.1:4001 profile.profile
</code></pre>
<p>The commands capture the profiling information for 45 seconds, and then provide a web view of the profiling result at <code>127.0.0.1:4001</code>. This view contains a <a href="http://www.brendangregg.com/flamegraphs.html">flame graph</a> of the execution and more views that can help you diagnose the performance bottleneck.</p>
<p>You can also gather other runtime information through this end point. For example:</p>
<ul>
<li>Goroutine:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/goroutine&quot; &gt; goroutine.profile
</code></pre>
<ul>
<li>Trace:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/trace?seconds=3&quot; &gt; trace.profile
go tool trace -http 127.0.0.1:4001 trace.profile
</code></pre>
<ul>
<li>Heap:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/heap&quot; &gt; heap.profile
go tool pprof -http 127.0.0.1:4001 heap.profile
</code></pre>
<p>To learn how the runtime information is analyzed, see Go's <a href="https://golang.org/doc/diagnostics">diagnostics document</a>.</p>
<h3 id="profiling-during-benchmarking"><a class="header" href="#profiling-during-benchmarking">Profiling during benchmarking</a></h3>
<p>When you are proposing a performance-related feature for TiDB, we recommend that you also include a benchmark result as proof of the performance gain or to show that your code won't introduce any performance regression. In this case, you need to write your own benchmark test like in <code>executor/benchmark.go</code>.</p>
<p>For example, if you want to benchmark the window functions, because <code>BenchmarkWindow</code> are already in the benchmark tests, you can run the following commands to get the benchmark result:</p>
<pre><code class="language-bash">cd executor
go test -bench BenchmarkWindow -run BenchmarkWindow -benchmem
</code></pre>
<p>If you find any performance regression, and you want to know the cause of it, you could use a command like the following:</p>
<pre><code class="language-bash">go test -bench BenchmarkWindow -run BenchmarkWindow -benchmem -memprofile memprofile.out -cpuprofile profile.out
</code></pre>
<p>Then, you can use the steps described above to generate and analyze the profiling information.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="commit-the-code-and-submit-a-pull-request"><a class="header" href="#commit-the-code-and-submit-a-pull-request">Commit the code and submit a pull request</a></h1>
<p>The TiDB project uses <a href="https://git-scm.com/">Git</a> to manage its source code. To contribute to the project, you need to get familiar with Git features so that your changes can be incorporated into the codebase.</p>
<p>This section addresses some of the most common questions and problems that new contributors might face. This section also covers some Git basics; however if you find that the content is a little difficult to understand, we recommend that you first read the following introductions to Git:</p>
<ul>
<li>The &quot;Beginner&quot; and &quot;Getting Started&quot; sections of <a href="https://www.atlassian.com/git/tutorials">this tutorial</a> from Atlassian</li>
<li><a href="https://docs.github.com/en/github/getting-started-with-github/set-up-git">Documentation</a> and <a href="https://guides.github.com/introduction/git-handbook/">guides</a> for beginners from Github</li>
<li>A more in-depth <a href="https://git-scm.com/book/en/v2/">book</a> from Git</li>
</ul>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Before you create a pull request, make sure that you've installed Git, forked <a href="https://github.com/pingcap/tidb">pingcap/tidb</a>, and cloned the upstream repo to your PC. The following instructions use the command line interface to interact with Git; there are also several GUIs and IDE integrations that can interact with Git too.</p>
<p>If you've cloned the upstream repo, you can reference it using <code>origin</code> in your local repo. Next, you need to set up a remote for the repo your forked using the following command:</p>
<pre><code class="language-bash">git remote add dev https://github.com/your_github_id/tidb.git
</code></pre>
<p>You can check the remote setting using the following command:</p>
<pre><code class="language-bash">git remote -v
# dev    https://github.com/username/tidb.git (fetch)
# dev    https://github.com/username/tidb.git (push)
# origin    https://github.com/pingcap/tidb.git (fetch)
# origin    https://github.com/pingcap/tidb.git (push)
</code></pre>
<h2 id="standard-process"><a class="header" href="#standard-process">Standard Process</a></h2>
<p>The following is a normal procedure that you're likely to use for the most common minor changes and PRs:</p>
<ol>
<li>
<p>Ensure that you're making your changes on top of master and get the latest changes:</p>
<pre><code class="language-bash">git checkout master
git pull master
</code></pre>
</li>
<li>
<p>Create a new branch for your changes:</p>
<pre><code class="language-bash">git checkout -b my-changes
</code></pre>
</li>
<li>
<p>Make some changes to the repo and test them.</p>
</li>
<li>
<p>Commit your changes and push them to your <code>dev</code> remote repository:</p>
<pre><code class="language-bash"># stage files you created/changed/deleted
git add path/to/changed/file.go path/to/another/changed/file.go

# commit changes staged, make sure the commit message is meaningful and readable
git commit -s -m &quot;pkg, pkg2, pkg3: what's changed&quot;

# optionally use `git status` to check if the change set is correct
# git status

# push the change to your `dev` remote repository
git push --set-upstream dev my-changes
</code></pre>
</li>
<li>
<p>Make a PR from your fork to the master branch of pingcap/tidb. For more information on how to make a PR, see <a href="https://guides.github.com/activities/forking/#making-a-pull-request">Making a Pull Request</a> in GitHub Guides.</p>
</li>
</ol>
<p>When making a PR, look at the <a href="https://raw.githubusercontent.com/pingcap/tidb/master/.github/pull_request_template.md">PR template</a> and follow the commit message format, PR title format, and checklists.</p>
<p>After you create a PR, if your reviewer requests code changes, the procedure for making those changes is similar to that of making a PR, with some steps skipped:</p>
<ol>
<li>
<p>Switch to the branch that is the head and get the latest changes:</p>
<pre><code class="language-bash">git checkout my-changes
git pull
</code></pre>
</li>
<li>
<p>Make, stage, and commit your additional changes just like before.</p>
</li>
<li>
<p>Push those changes to your fork:</p>
<pre><code class="language-bash">git push
</code></pre>
</li>
</ol>
<p>If your reviewer requests for changes with GitHub suggestion, you can commit the suggestion from the webpage. GitHub provides <a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request#applying-suggested-changes">documentation</a> for this case.</p>
<h2 id="conflicts"><a class="header" href="#conflicts">Conflicts</a></h2>
<p>When you edit your code locally, you are making changes to the version of pingcap/tidb that existed when you created your feature branch. As such, when you submit your PR it is possible that some of the changes that have been made to pingcap/tidb since then conflict with the changes you've made.</p>
<p>When this happens, you need to resolve the conflicts before your changes can be merged. First, get a local copy of the conflicting changes: checkout your local master branch with <code>git checkout master</code>, then <code>git pull master</code> to update it with the most recent changes.</p>
<h3 id="rebasing"><a class="header" href="#rebasing">Rebasing</a></h3>
<p>You're now ready to start the rebasing process. Checkout the branch with your changes and execute <code>git rebase master</code>.</p>
<p>When you rebase a branch on master, all the changes on your branch are reapplied to the most recent version of master. In other words, Git tries to pretend that the changes you made to the old version of master were instead made to the new version of master. During this process, you should expect to encounter at least one &quot;rebase conflict.&quot; This happens when Git's attempt to reapply the changes fails because your changes conflict with other changes that have been made. You can tell that this happened because you'll see lines in the output that look like:</p>
<pre><code class="language-text">CONFLICT (content): Merge conflict in file.go
</code></pre>
<p>When you open these files, you'll see sections of the form</p>
<pre><code class="language-text">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Original code
=======
Your code
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8fbf656... Commit fixes 12345
</code></pre>
<p>This represents the lines in the file that Git could not figure out how to rebase. The section between <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> and <code>=======</code> has the code from master, while the other side has your version of the code. You'll need to decide how to deal with the conflict. You may want to keep your changes, keep the changes on master, or combine the two.</p>
<p>Generally, resolving the conflict consists of two steps: First, fix the particular conflict. Edit the file to make the changes you want and remove the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> lines in the process. Second, check the surrounding code. If there was a conflict, it's likely there are some logical errors lying around too!</p>
<p>Once you're all done fixing the conflicts, you need to stage the files that had conflicts in them via git add. Afterwards, run <code>git rebase --continue</code> to let Git know that you've resolved the conflicts and it should finish the rebase.</p>
<p>Once the rebase has succeeded, you'll want to update the associated branch on your fork with <code>git push --force-with-lease</code>.</p>
<h2 id="advanced-rebasing"><a class="header" href="#advanced-rebasing">Advanced rebasing</a></h2>
<p>If your branch contains multiple consecutive rewrites of the same code, or if the rebase conflicts are extremely severe, you can use <code>git rebase --interactive master</code> to gain more control over the process. This allows you to choose to skip commits, edit the commits that you do not skip, change the order in which they are applied, or &quot;squash&quot; them into each other.</p>
<p>Alternatively, you can sacrifice the commit history like this:</p>
<pre><code class="language-bash"># squash all the changes into one commit so you only have to worry about conflicts once
git rebase -i $(git merge-base master HEAD)  # and squash all changes along the way
git rebase master
# fix all merge conflicts
git rebase --continue
</code></pre>
<p>Squashing commits into each other causes them to be merged into a single commit. Both the upside and downside of this is that it simplifies the history. On the one hand, you lose track of the steps in which changes were made, but the history becomes easier to work with.</p>
<p>You also may want to squash together just the last few commits, possibly because they only represent &quot;fixups&quot; and not real changes. For example, <code>git rebase --interactive HEAD~2</code> allows you to edit the two commits only.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-tidb"><a class="header" href="#contribute-to-tidb">Contribute to TiDB</a></h1>
<p>TiDB is developed by an open and friendly community. Everybody is cordially welcome to join the community and contribute to TiDB. We value all forms of contributions, including, but not limited to:</p>
<ul>
<li>Code reviewing of the existing patches</li>
<li>Documentation and usage examples</li>
<li>Community participation in forums and issues</li>
<li>Code readability and developer guide
<ul>
<li>We welcome contributions that add code comments and code refactor to improve readability</li>
<li>We also welcome contributions to docs to explain the design choices of the internal</li>
</ul>
</li>
<li>Test cases to make the codebase more robust</li>
<li>Tutorials, blog posts, talks that promote the project</li>
</ul>
<p>Here are guidelines for contributing to various aspect of the project:</p>
<ul>
<li><a href="contribute-to-tidb/community-guideline.html">Community Guideline</a></li>
<li><a href="contribute-to-tidb/committer-guide.html">Committer Guide</a></li>
<li><a href="contribute-to-tidb/report-an-issue.html">Report an Issue</a></li>
<li><a href="contribute-to-tidb/contribute-code.html">Contribute Code</a></li>
<li><a href="contribute-to-tidb/review-a-pr.html">Review a Pull Request</a></li>
<li><a href="contribute-to-tidb/make-a-proposal.html">Make a Proposal</a></li>
<li><a href="contribute-to-tidb/code-style-and-quality-guide.html">Code Style and Quality Guide</a></li>
<li><a href="contribute-to-tidb/write-document.html">Write Document</a></li>
<li><a href="contribute-to-tidb/miscellaneous-topics.html">Miscellaneous Topics</a></li>
</ul>
<p>Any other question? Reach out to the <a href="https://internals.tidb.io/">TiDB Internals forum</a> to get help!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="community-guideline"><a class="header" href="#community-guideline">Community Guideline</a></h1>
<p>TiDB community aims to provide harassment-free, welcome and friendly experience for everyone. The first and most important thing for any participant in the community is be friendly and respectful to others. Improper behaviors will be warned and punished.</p>
<p>We appreciate any contribution in any form to TiDB community. Thanks so much for your interest and enthusiasm on TiDB!</p>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>TiDB community refuses any kind of harmful behavior to the community or community members. Everyone should read our <a href="https://github.com/pingcap/community/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a> and keep proper behavior while participating in the community.</p>
<h2 id="governance"><a class="header" href="#governance">Governance</a></h2>
<p>TiDB development governs by two kind of groups:</p>
<ul>
<li><a href="https://github.com/pingcap/community/tree/master/toc">TOC</a>: TOC serves as the main bridge and channel for coordinating and information sharing across companies and organizations. It is the coordination center for solving problems in terms of resource mobilization, technical research and development direction in the current community and cooperative projects.</li>
<li><a href="https://github.com/pingcap/community/tree/master/teams">teams</a>: Teams are persistent open groups that focus on a part of the TiDB projects. A team has its reviewer, committer and maintainer, and owns one or more repositories. Team level decision making comes from its maintainers.</li>
</ul>
<p>A typical promoted path for a TiDB developer is from user to reviewer, then committer and maintainer, finally maybe a TOC member. But gaining more roles doesn't mean you have any privilege over other community members or even any right to control them. Everyone in TiDB community are equal and share the responsibility to collaborate constructively with other contributors, building a friendly community. The roles are a natural reward for your substantial contribution in TiDB development and provide you more rights in the development workflow to enhance your efficiency. Meanwhile, they request some additional responsibilities from you:</p>
<ul>
<li>Now that you are a member of team reviewers/committers/maintainers, you are representing the project and your fellow team members whenever you discuss TiDB with anyone. So please be a good person to defend the reputation of the team.</li>
<li>Committers/maintainers have the right to merge pull requests, so bear the additional responsibility of handling the consequences of accepting a change into the codebase or documentation. That includes reverting or fixing it if it causes problems as well as helping out the release manager in resolving any problems found during the pre-release testing cycle. While all contributors are free to help out with this part of the process, and it is most welcome when they do, the actual responsibility rests with the committers/maintainers that merged the change.</li>
<li>Reviewers/committers/maintainers also bear the primary responsibility for guiding contributors the right working procedure, like deciding when changes proposed on the issue tracker should be escalated to <a href="https://internals.tidb.io">internal.tidb.io</a> for wider discussion, as well as suggesting the use of the <a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB Design Documents</a> process to manage the design and justification of complex changes, or changes with a potentially significant impact on end users.</li>
</ul>
<p>There should be no blockers to contribute with no roles. It's totally fine for you to reject the promotion offer if you don't want to take the additional responsibilities or for any other reason. Besides, except for code or documentation contribution, any kind of contribution for the community is highly appreciated. Let's grow TiDB ecosystem through our contributions of this community.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="committer-guide"><a class="header" href="#committer-guide">Committer Guide</a></h1>
<p>This is an evolving document to provide some helpful tips for committers. Most of them are lessons learned during development. We welcome every committer to contribute to this document. See the <a href="contribute-to-tidb/community-guideline.html">TiDB Community Guideline</a> for an overview of the committership and the general development process.</p>
<h2 id="community-first"><a class="header" href="#community-first">Community First</a></h2>
<p>The collective effort of the community moves the project forward and makes the project awesome for everyone. When we make a decision, it is always helpful to keep the community in mind. Here are some example questions that we can ask:</p>
<ul>
<li>How can I encourage new contributors to get more involved in the project?</li>
<li>Can I help to save my fellow committers' time?</li>
<li>Have I enabled the rest of the community to participate the design proposals?</li>
</ul>
<h2 id="public-archive-principle"><a class="header" href="#public-archive-principle">Public Archive Principle</a></h2>
<p>While private channels such as face to face discussion are useful for development, they also create barriers for the broader community's participation. An open way of development suggests all decisions to be made in public channels, which are archived and accessible to everyone. As a result, any contributor can keep up with the development by watching the archives and join the development anytime.</p>
<p>While this principle applies to every contributor, it is especially important for committers. Here are some example applications of this principle:</p>
<ul>
<li>When getting a project-related question from a personal channel, encourage the person to open a public thread in the <a href="https://internals.tidb.io/">TiDB Internals forum</a>, so others in the community can benefit from the answer.</li>
<li>After an in-person discussion, send a summary to public channels (as an RFC or a discuss topic).</li>
</ul>
<h2 id="shepherd-a-pull-request"><a class="header" href="#shepherd-a-pull-request">Shepherd a Pull Request</a></h2>
<p>Here are some tips to shepherd a pull request. You can also take a look at <a href="contribute-to-tidb/review-a-pr.html">Review a Pull Request</a>.</p>
<ul>
<li>Assign the PR to yourself, so that other committers know that the PR has already been tended to.</li>
<li>Make use of the status label to indicate the current status.</li>
<li>Check if a design document needs to be present.</li>
<li>If the contributor has not requested a reviewer, kindly ask the contributor to do so. If the PR comes from a new contributor, help the contributor to request reviewers and ask the contributor to do so next time.</li>
<li>Moderate the reviews, ask reviewers to approve explicitly.</li>
<li>Mark the PR as accepted and acknowledge the contributor/reviewers.</li>
<li>Merge the PR :)</li>
</ul>
<h2 id="time-management"><a class="header" href="#time-management">Time Management</a></h2>
<p>There are many things that a committer can do, such as moderating discussions, pull request reviews and code contributions.</p>
<p>Working on an open source project can be rewarding, but also be a bit overwhelming sometimes. A little bit of time management might be helpful to alleviate the problem. For example, some committers have a &quot;community day&quot; in a week when they actively manage outstanding PRs, but watch the community less frequently in the rest of the time.</p>
<p>Remember that your merit will never go away, so please take your time and pace when contributing to the project:)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="report-an-issue"><a class="header" href="#report-an-issue">Report an Issue</a></h1>
<p>If you think you have found an issue in TiDB, you can report it to the <a href="https://github.com/pingcap/tidb/issues">issue tracker</a>. If you would to like to report issues to TiDB documents or this development guide, they are in separate GitHub repositories, so you need to file issues to corresponding issue tracker, <a href="https://github.com/pingcap/docs/issues">TiDB document issue tracker</a> and <a href="https://github.com/pingcap/tidb-dev-guide/issues">TiDB Development Guide issue tracker</a>. Read <a href="contribute-to-tidb/write-document.html">Write Document</a> for more details.</p>
<h2 id="checking-if-an-issue-already-exists"><a class="header" href="#checking-if-an-issue-already-exists">Checking if an issue already exists</a></h2>
<p>The first step before filing an issue report is to see whether the problem has already been reported. You can <a href="https://docs.github.com/en/github/administering-a-repository/finding-information-in-a-repository/using-search-to-filter-issues-and-pull-requests">use the search bar to search existing issues</a>. This doesn't always work, and sometimes it's hard to know what to search for, so consider this extra credit. We won't mind if you accidentally file a duplicate report. Don't blame yourself if your issue is closed as duplicated. We highly recommend if you are not sure about anything of your issue report, you can turn to <a href="https://internals.tidb.io">internal.tidb.io</a> for a wider audience and ask for discussion or help.</p>
<h2 id="filing-an-issue"><a class="header" href="#filing-an-issue">Filing an issue</a></h2>
<p>If the problem you're reporting is not already in the issue tracker, you can <a href="https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue">open a GitHub issue</a> with your GitHub account. TiDB uses issue template for different kinds of issues. Issue templates are a bundle of questions to collect necessary information about the problem to make it easy for other contributors to participate. For example, a bug report issue template consists of four questions:</p>
<ul>
<li>Minimal reproduce step.</li>
<li>What did you expect to see?</li>
<li>What did you see instead?</li>
<li>What is your TiDB version?</li>
</ul>
<p>Answering these questions give the details about your problem so other contributors or TiDB users could pick up your issue more easily. </p>
<p>As previous section shows, duplicated issues should be reduced. To help others who encountered the problem find your issue, except for problem details answered in the issue template, a descriptive title which contains information that might be unique to it also helps. This can be the components your issue belongs to or database features used in your issue, the conditions that trigger the bug, or part of the error message if there is any. </p>
<h2 id="making-good-issues"><a class="header" href="#making-good-issues">Making good issues</a></h2>
<p>Except for a good title and detailed issue message, you can also add suitable labels to your issue via <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#type">/label</a>, especially which component the issue belongs to. Many committers and contributors only focus on certain subsystems of TiDB. Setting the appropriate component is important for getting their attention.</p>
<p>If you are able to, you should take more considerations on your issue:</p>
<ul>
<li>Does the feature fit well into TiDB's architecture? Will it scale and keep TiDB flexible for the future, or will the feature restrict TiDB in the future?</li>
<li>Is the feature a significant new addition (rather than an improvement to an existing part)? If yes, will the community commit to maintaining this feature?</li>
<li>Does this feature align well with currently ongoing efforts?</li>
<li>Does the feature produce additional value for TiDB users or developers? Or does it introduce the risk of regression without adding relevant user or developer benefit?</li>
</ul>
<p>Deep thoughts could help the issue proceed faster and help build your own reputation in the community.</p>
<h2 id="understanding-the-issues-progress-and-status"><a class="header" href="#understanding-the-issues-progress-and-status">Understanding the issue's progress and status</a></h2>
<p>Once your issue is created, other contributors might take part in. You need to discuss with them, provide more information they might want to know, address their comments to reach consensus and make the progress proceeds. But please realize there are always more pending issues than contributors are able to handle, and especially TiDB community is a global one, contributors reside all over the world and they might already be very busy with their own work and life. Please be patient! If your issue gets stale for some time, it's okay to ping other participants, or take it to <a href="https://internals.tidb.io">internal.tidb.io</a> for more attention.</p>
<h2 id="disagreement-with-a-resolution-on-the-issue-tracker"><a class="header" href="#disagreement-with-a-resolution-on-the-issue-tracker">Disagreement with a resolution on the issue tracker</a></h2>
<p>As humans, we will have differences of opinions from time to time. First and foremost, please be respectful that care, thought, and volunteer time went into the resolution.</p>
<p>With this in mind, take some time to consider any comments made in association with the resolution of the issue. On reflection, the resolution steps may seem more reasonable than you initially thought.</p>
<p>If you still feel the resolution is incorrect, then raise a thoughtful question on <a href="https://internals.tidb.io">internal.tidb.io</a>. Further argument and disrespectful discourse on <a href="https://internals.tidb.io">internal.tidb.io</a> after a consensus has been reached amongst the committers is unlikely to win any converts.</p>
<h2 id="reporting-security-vulnerabilities"><a class="header" href="#reporting-security-vulnerabilities">Reporting security vulnerabilities</a></h2>
<p>Security issues are not suitable to report in public early, so different tracker strategy is used. Please refer to the <a href="https://github.com/pingcap/tidb/security/policy">dedicated process</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-code"><a class="header" href="#contribute-code">Contribute Code</a></h1>
<p>TiDB is maintained, improved, and extended by code contributions. We welcome code contributions to TiDB. TiDB uses a workflow based on <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests">pull requests</a>.</p>
<h2 id="before-contributing"><a class="header" href="#before-contributing">Before contributing</a></h2>
<p>Contributing to TiDB does <em>not</em> start with opening a pull request. We expect contributors to reach out to us first to discuss the overall approach together. Without consensus with the TiDB committers, contributions might require substantial rework or will not be reviewed. So please <a href="contribute-to-tidb/report-an-issue.html">create a GitHub issue</a>, discuss under an existing issue, or create a topic on the <a href="https://internals.tidb.io">internal.tidb.io</a> and reach consensus.</p>
<p>For newcomers, you can check the <a href="https://github.com/pingcap/tidb/contribute">starter issues</a>, which are annotated with a &quot;good first issue&quot; label. These are issues suitable for new contributors to work with and won't take long to fix. But because the label is typically added at triage time it can turn out to be inaccurate, so do feel free to leave a comment if you think the classification no longer applies.</p>
<p>To get your change merged you need to sign the <a href="https://cla-assistant.io/pingcap/tidb">CLA</a> to grant PingCAP ownership of your code.</p>
<h2 id="contributing-process"><a class="header" href="#contributing-process">Contributing process</a></h2>
<p>After a consensus is reached in issues, it's time to start the code contributing process:</p>
<ol>
<li>Assign the issue to yourself via <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#assign">/assign</a>. This lets other contributors know you are working on the issue so they won't make duplicate efforts.</li>
<li>Follow the <a href="https://guides.github.com/introduction/flow/">GitHub workflow</a>, commit code changes in your own git repository branch and open a pull request for code review.</li>
<li>Make sure the continuous integration checks on your pull request are green (i.e. successful).</li>
<li>Review and address <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request">comments on your pull request</a>. If your pull request becomes outdated with the target branch, you need to <a href="https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request#perform-a-rebase">rebase your pull request</a> to keep it up to date. Since TiDB uses <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/about-merge-methods-on-github#squashing-your-merge-commits">squash and merge</a>, simply merging master to catch up the change is also acceptable.</li>
<li>When your pull request gets enough approvals (the default number is 2) and all other requirements are met, it will be merged.</li>
<li>Handle regressions introduced by your change. Although committers bear the main responsibility to fix regressions, it's quite nice for you to handle it (reverting the change or sending fixes).</li>
</ol>
<p>Clear and kind communication is key to this process.</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>One important thing when you make code contributions to TiDB is tests. Tests should be always considered as a part of your change. Any code changes that cause semantic changes or new function additions to TiDB should have corresponding test cases. And of course you can not break any existing test cases if they are still valid. It's recommended to <a href="contribute-to-tidb/../get-started/write-and-run-unit-tests.html">run tests</a> on your local environment first to find obvious problems and fix them before opening the pull request.</p>
<p>It's also highly appreciated if your pull request only contains test cases to increase test coverage of TiDB. Supplement test cases for existing modules is a good and easy way to become acquainted with existing code.</p>
<h2 id="making-good-pull-requests"><a class="header" href="#making-good-pull-requests">Making good pull requests</a></h2>
<p>When creating a pull request for submission, there are several things that you should consider to help ensure that your pull request is accepted:</p>
<ul>
<li>Does the contribution alter the behavior of features or components in a way that it may break previous users' programs and setups? If yes, there needs to be a discussion and agreement that this change is desirable.</li>
<li>Does the contribution conceptually fit well into TiDB? Is it too much of a special case such that it makes things more complicated for the common case, or bloats the abstractions/APIs?</li>
<li>Does the contribution make a big impact on TiDB's build time?</li>
<li>Does your contribution affect any documentation? If yes, you should add/change proper documentation. </li>
<li>If there are any new dependencies, are they under active maintenances? What are their licenses?</li>
</ul>
<h2 id="making-good-commits"><a class="header" href="#making-good-commits">Making good commits</a></h2>
<p>Each feature or bugfix should be addressed by a single pull request, and for each pull request there may be several commits. In particular:</p>
<ul>
<li>Do <em>not</em> fix more than one issues in the same commit (except, of course, if one code change fixes all of them).</li>
<li>Do <em>not</em> do cosmetic changes to unrelated code in the same commit as some feature/bugfix.</li>
</ul>
<h2 id="waiting-for-review"><a class="header" href="#waiting-for-review">Waiting for review</a></h2>
<p>To begin with, please be patient! There are many more people submitting pull requests than there are people capable of reviewing your pull request. Getting your pull request reviewed requires a reviewer to have the spare time and motivation to look at your pull request. If your pull request has not received any notice from reviewers (i.e., no comment made) for some time, you can ping the reviewers and assignees, or take it to <a href="https://internals.tidb.io">internal.tidb.io</a> for more attention.</p>
<p>When someone does manage to find the time to look at your pull request, they will most likely make comments about how it can be improved (don't worry, even committers/maintainers have their pull requests sent back to them for changes). It is then expected that you update your pull request to address these comments, and the review process will thus iterate until a satisfactory solution has emerged.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="review-a-pull-request"><a class="header" href="#review-a-pull-request">Review a Pull Request</a></h1>
<p>TiDB values any <a href="https://en.wikipedia.org/wiki/Code_review">code review</a>. One of the bottlenecks in the TiDB development process is the lack of code reviews. If you browse the issue tracker, you will see that numerous issues have a fix, but cannot be merged into the main source code repository, because no one has reviewed the proposed solution. Reviewing a pull request can be just as informative as providing a pull request and it will allow you to give constructive comments on another developer's work. It is a common misconception that in order to be useful, a code review has to be perfect. This is not the case at all! It is helpful to just test the pull request and/or play around with the code and leave comments in the pull request.</p>
<h2 id="principles-of-the-code-review"><a class="header" href="#principles-of-the-code-review">Principles of the code review</a></h2>
<ul>
<li>Technical facts and data overrule opinions and personal preferences.</li>
<li>Software design is about trade-offs, and there is no silver bullet.</li>
</ul>
<p>Everyone comes from different technical backgrounds with different knowledge. They have their own personal preferences. It is important that the code review is not based on biased opinions.</p>
<p>Sometimes, making choices of accepting or rejecting a pull request can be tricky as in the following situations: </p>
<ul>
<li>Suppose that a pull request contains special optimization that can improve the overall performance by 30%. However, the pull request introduces a totally different code path, and every subsequent feature must consider it.</li>
<li>Suppose that a pull request is to fix a critical bug, but the change in the pull request is risky to introduce other bugs.</li>
</ul>
<p>If a pull request under your review is in these tricky situations, what is the right choice, accepting the pull request or rejecting it? The answer is always &quot;it depends.&quot; Software design is more like a kind of art than technology. It is about aesthetics and your taste of the code. There are always trade-offs, and often there's no perfect solution.</p>
<h2 id="triaging-pull-requests"><a class="header" href="#triaging-pull-requests">Triaging pull requests</a></h2>
<p>Some pull request authors may not be familiar with TiDB, TiDB development workflow or TiDB community. They don't know what labels should be added to the pull requests and which experts could be asked for review. If you are able to, it would be great for you to triage the pull requests, adding suitable labels to the pull requests, asking corresponding experts to review the pull requests. These actions could help more contributors notice the pull requests and make quick responses.</p>
<h2 id="checking-pull-requests"><a class="header" href="#checking-pull-requests">Checking pull requests</a></h2>
<p>There are some basic aspects to check when you review a pull request:</p>
<ul>
<li><strong>Concentration</strong>. One pull request should only do one thing. No matter how small it is, the change does exactly one thing and gets it right. Don't mix other changes into it.</li>
<li><strong>Tests</strong>. A pull request should be test covered, whether the tests are unit tests, integration tests, or end-to-end tests. Tests should be sufficient, correct and don't slow down the CI pipeline largely.</li>
<li><strong>Functionality</strong>. The pull request should implement what the author intends to do and fit well in the existing code base, resolve a real problem for TiDB users. To get the author's intention and the pull request design, you could follow the discussions in the corresponding GitHub issue or <a href="https://internals.tidb.io">internal.tidb.io</a> topic.</li>
<li><strong>Style</strong>. Code in the pull request should follow common programming style. For Go and Rust, there are built-in tools with the compiler toolchain. However, sometimes the existing code is inconsistent with the style guide, you should maintain consistency with the existing code or file a new issue to fix the existing code style first.</li>
<li><strong>Documentation</strong>. If a pull request changes how users build, test, interact with, or release code, you must check whether it also updates the related documentation such as READMEs and any generated reference docs. Similarly, if a pull request deletes or deprecates code, you must check whether or not the corresponding documentation should also be deleted.</li>
<li><strong>Performance</strong>. If you find the pull request may affect performance, you could ask the author to provide a benchmark result.</li>
</ul>
<h2 id="writing-code-review-comments"><a class="header" href="#writing-code-review-comments">Writing code review comments</a></h2>
<p>When you review a pull request, there are several rules and suggestions you should take to <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request">write better comments</a>:</p>
<ul>
<li><strong>Be respectful to pull request authors and other reviewers</strong>. Code review is a part of your community activities. You should follow the community requirements.</li>
<li><strong>Asking questions instead of making statements</strong>. The wording of the review comments is very important. To provide review comments that are constructive rather than critical, you can try asking questions rather than making statements.</li>
<li><strong>Offer sincere praise</strong>. Good reviewers focus not only on what is wrong with the code but also on good practices in the code. As a reviewer, you are recommended to offer your encouragement and appreciation to the authors for their good practices in the code. In terms of mentoring, telling the authors what they did is right is even more valuable than telling them what they did is wrong.</li>
<li><strong>Provide additional details and context of your review process</strong>. Instead of simply &quot;approving&quot; the pull request. If your test the pull request, report the result and your test environment details. If you request changes, try to suggest how.</li>
</ul>
<h2 id="accepting-pull-requests"><a class="header" href="#accepting-pull-requests">Accepting pull requests</a></h2>
<p>Once you think the pull request is ready, you can <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/approving-a-pull-request-with-required-reviews">approve</a> it. </p>
<p>In the TiDB community, most repositories require two approvals before a pull request can be accepted. A few repositories require a different number of approvals, but two approvals are the default setting. After the required approval number is met, a committer can <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#merge">/merge</a> the pull request.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="make-a-proposal"><a class="header" href="#make-a-proposal">Make a Proposal</a></h1>
<p>This page defines the best practices procedure for making a proposal in TiDB projects. This text is based on the content of <a href="https://github.com/pingcap/tidb/blob/7f4f5c02364b6578da561ec14f409a39ddf954a5/docs/design/README.md">TiDB Design Document</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a bit of a design process and produce a consensus among the TiDB community.</p>
<p>The process described in this page is intended to provide a consistent and controlled path for new features to enter the TiDB projects, so that all stakeholders can be confident about the direction the projects is evolving in.</p>
<h2 id="who-should-initiate-the-design-document"><a class="header" href="#who-should-initiate-the-design-document">Who should initiate the design document?</a></h2>
<p>Everyone is encouraged to initiate a design document, but before doing it, please make sure you have an intention of getting the work done to implement it.</p>
<h2 id="before-creating-a-design-document"><a class="header" href="#before-creating-a-design-document">Before creating a design document</a></h2>
<p>A hastily-proposed design document can hurt its chances of acceptance. Low-quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the design document can make the process smoother.</p>
<p>Although there is no single way to prepare for submitting a design document, it is generally a good idea to pursue feedback from other project developers beforehand, to ascertain that the design document may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting a draft of design document is on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<h2 id="what-is-the-process"><a class="header" href="#what-is-the-process">What is the process?</a></h2>
<ol>
<li>Create a pull request with a design document based on the <a href="https://github.com/pingcap/tidb/blob/7f4f5c02364b6578da561ec14f409a39ddf954a5/docs/design/TEMPLATE.md">template</a> as <code>YYYY-MM-DD-my-feature.md</code>.</li>
<li>Discussion takes place, and the text is revised in response.</li>
<li>The design document is accepted or rejected when at least two committers reach consensus and no objection from the committer.</li>
<li>If accepted, create a <a href="https://github.com/pingcap/tidb/issues/new?assignees=&amp;labels=type%2Fenhancement&amp;template=development-task.md">tracking issue</a> for the design document or convert one from a previous discuss issue. The tracking issue basically tracks subtasks and progress. And refer the tracking issue in the design document replacing placeholder in the template.</li>
<li>Merge the pull request of design.</li>
</ol>
<p>Please refer to the tracking issue from subtasks to track the progress.</p>
<p>An example that almost fits into this model is the proposal &quot;Support global index for partition table&quot;, without following the latest template.</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/18032">tracking issue</a></li>
<li><a href="https://github.com/pingcap/tidb/pull/18982">pull request of design document</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tidb-code-style-and-quality-guide"><a class="header" href="#tidb-code-style-and-quality-guide">TiDB Code Style and Quality Guide</a></h1>
<p>This is an attempt to capture the code and quality standard that we want to maintain.</p>
<h2 id="the-newtype-pattern-improves-code-quality"><a class="header" href="#the-newtype-pattern-improves-code-quality">The newtype pattern improves code quality</a></h2>
<p>We can create a new type using the <code>type</code> keyword.</p>
<p>The newtype pattern is perhaps most often used in Golang to get around type restrictions rather than to try to create new ones. It is used to create different interface implementations for a type or to extend a builtin type or a type from an existing package with new methods.</p>
<p>However, it is generally useful to improve code clarity by marking that data has gone through either a validation or a transformation. Using a different type can reduce error handling and prevent improper usage.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

type Email string

func newEmail(email string) (Email, error) {
    if !strings.Contains(email, &quot;@&quot;) {
        return Email(&quot;&quot;), fmt.Errorf(&quot;Expected @ in the email&quot;)
    }
    return Email(email), nil
}

func (email Email) Domain() string {
    return strings.Split(string(email), &quot;@&quot;)[1]
}

func main() {
    ping, err := newEmail(&quot;go@pingcap.com&quot;)
    if err != nil { panic(err) }
    fmt.Println(ping.Domain())
}
</code></pre>
<h2 id="when-to-use-value-or-pointer-receiver"><a class="header" href="#when-to-use-value-or-pointer-receiver">When to use value or pointer receiver</a></h2>
<p>Because pointer receivers need to be used some of the time, Go programmers often use them all of the time.
This is a typical outline of Go code:</p>
<pre><code class="language-go">type struct S {}
func NewStruct() *S
func (s *S) structMethod()
</code></pre>
<p>Using pointers for the entire method set means we have to read the source code of every function to determine if it mutates the struct. Mutations are a source of error. This is particularly true in concurrent programs. We can contrast this with values: these are always concurrent safe.</p>
<p>For code clarity and bug reduction a best practice is to default to using values and value receivers.
However, pointer receivers are often required to satisfy an interface or for performance reasons, and this need overrides any default practice.</p>
<p>However, performance can favor either approach. One might assume that pointers would always perform better because it avoids copying. However, the performance is roughly the same for small structs in micro benchmark. This is because the copying is cheap, inlining can often avoid copying anyways, and pointer indirection has its own small cost. In a larger program with a goal of predictable low latency the value approach can be more favorable because it avoids <a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/">heap allocation and any additional GC overhead</a>.</p>
<p>As a rule of thumb is that when a struct has 10 or more words we should use pointer receivers. However, to actually know which is best for performance depends on how the struct is used in the program and must ultimately be determined by profiling. For example these are some factors that affect things:</p>
<ul>
<li>method size: small inlineable methods favor value receivers.</li>
<li>Is the struct called repeatedly in a for loop? This favors pointer receivers.</li>
<li>What is the GC behavior of the rest of the program? GC pressure may favor value receivers.</li>
</ul>
<h2 id="parallel-for-loop"><a class="header" href="#parallel-for-loop">Parallel For-Loop</a></h2>
<p>There are two types of for loop on range: &quot;with index&quot; and &quot;without index&quot;. Let's see an example for range with index.</p>
<pre><code class="language-go">func TestRangeWithIndex(t *testing.T) {
	rows := []struct{ index int }{{index: 0}, {index: 1}, {index: 2}}
	for _, row := range rows {
		row.index += 10
	}
	for i, row := range rows {
		require.Equal(t, i+10, row.index)
	}
}
</code></pre>
<p>the output is:</p>
<pre><code>    Error Trace:	version_test.go:39
    Error:      	Not equal: 
                    expected: 10
                    actual  : 0
    Test:       	TestShowRangeWithIndex
</code></pre>
<p>Test fails because when range with index, the loop iterator variable is the same instance of the variable with a clone of iteration target value.</p>
<h3 id="the-same-instance-of-the-variable"><a class="header" href="#the-same-instance-of-the-variable">The same instance of the variable</a></h3>
<p>Since the the loop iterator variable is the same instance of the variable, it may result in tricky error with parallel for-loop.</p>
<pre><code class="language-go">done := make(chan bool)
values := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
for _, v := range values {
	go func() {
		fmt.Println(v)
		done &lt;- true
	}()
}
for _ = range values {
	&lt;-done
}
</code></pre>
<p>You might expect to see <code>a</code>, <code>b</code>, <code>c</code> as the output, but you'll probably see instead is <code>c</code>, <code>c</code>, <code>c</code>. </p>
<p>This is because each iteration of the loop uses the same instance of the variable <code>v</code>, so each closure shares that single variable.</p>
<p>This is the same reason which result wrong test when use <code>t.Parallel()</code> with range, which is covered in <a href="contribute-to-tidb/../get-started/write-and-run-unit-tests.html#parallel">Parallel section of Write and run unit tests</a></p>
<h3 id="a-clone-of-iteration-target-value"><a class="header" href="#a-clone-of-iteration-target-value">A clone of iteration target value</a></h3>
<p>Since the loop iterator variable is a clone of iteration target value, it may result in logic error. It can also lead to performance issue compared with none-index range loop or bare for loop.</p>
<pre><code class="language-go">type Item struct {
	id  int
	value [1024]byte
}

func BenchmarkRangeIndexStruct(b *testing.B) {
	var items [1024]Item
	for i := 0; i &lt; b.N; i++ {
		var tmp int
		for k := range items {
			tmp = items[k].id
		}
		_ = tmp
	}
}

func BenchmarkRangeStruct(b *testing.B) {
	var items [1024]Item
	for i := 0; i &lt; b.N; i++ {
		var tmp int
		for _, item := range items {
			tmp = item.id
		}
		_ = tmp
	}
}
</code></pre>
<pre><code>BenchmarkRangeIndexStruct-12             4875518               246.0 ns/op
BenchmarkRangeStruct-12                    16171             77523 ns/op
</code></pre>
<p>You can see range with index is much slower than range without index, since range with index use cloned value so have big performance decrease if cloned value use lots of memory.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-document"><a class="header" href="#write-document">Write Document</a></h1>
<p>Good documentation is crucial for any kind of software. This is especially true for sophisticated software systems such as distributed database like TiDB. The TiDB community aims to provide concise, precise, and complete documentation and welcomes any contribution to improve TiDB's documentation.</p>
<h2 id="where-you-can-contribute"><a class="header" href="#where-you-can-contribute">Where you can contribute</a></h2>
<p>The TiDB community provides bilingual documentation. The English documentation is maintained in the <a href="https://github.com/pingcap/docs">pingcap/docs</a> repository (docs repo) and the Chinese documentation is maintained in the <a href="https://github.com/pingcap/docs-cn">pingcap/docs-cn</a> repository (docs-cn repo). You are welcome to contribute to either of the repositories.</p>
<p>In a addition, you are also welcome to contribute to the <a href="https://github.com/pingcap/docs-tidb-operator">TiDB Operator documentation</a> and the <a href="https://github.com/pingcap/docs-dm">TiDB Data Migration documentation</a>.</p>
<p>This guide walks you through what and how you can contribute to the TiDB bilingual documentation in docs-cn and docs repos.</p>
<h2 id="what-you-can-contribute"><a class="header" href="#what-you-can-contribute">What you can contribute</a></h2>
<p>You can start from any one of the following items to help improve TiDB Docs at the PingCAP website (<a href="https://docs.pingcap.com/tidb/stable">en</a> and <a href="https://docs.pingcap.com/zh/tidb/stable">zh</a>):</p>
<ul>
<li>Fix typos or format (punctuation, space, indentation, code block, etc.)</li>
<li>Fix or update inappropriate or outdated descriptions</li>
<li>Add missing content (sentence, paragraph, or a new document)</li>
<li>Translate docs changes from English to Chinese, or from Chinese to English. See <a href="contribute-to-tidb/write-document.html#how-we-implement-bilingual-documentation">How we implement bilingual documentation</a></li>
<li>Submit, reply to, and resolve <a href="https://github.com/pingcap/docs/issues">docs issues</a> or <a href="https://github.com/pingcap/docs-cn/issues">docs-cn issues</a></li>
<li>(Advanced) Review Pull Requests created by others</li>
</ul>
<h2 id="before-you-contribute"><a class="header" href="#before-you-contribute">Before you contribute</a></h2>
<p>Before you contribute, let's take a quick look at some general information about TiDB documentation maintenance. This can help you to become a contributor soon.</p>
<h3 id="get-familiar-with-style"><a class="header" href="#get-familiar-with-style">Get familiar with style</a></h3>
<ul>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#how-to-write-a-good-commit-message">Commit Message Style</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#pull-request-title-style">Pull Request Title Style</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/docs/blob/master/resources/markdownlint-rules.md">Markdown Rules</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/code-comment-style.md">Code Comment Style</a></p>
</li>
<li>
<p>Diagram Style: <a href="https://github.com/pingcap/community/blob/master/contributors/figma-quick-start-guide.md">Figma Quick Start Guide</a></p>
<p>To keep a consistent style for diagrams, we recommend using <a href="https://www.figma.com/">Figma</a> to draw or design diagrams. If you need to draw a diagram, refer to the guide and use shapes or colors provided in the template.</p>
</li>
</ul>
<h3 id="learn-about-docs-versions"><a class="header" href="#learn-about-docs-versions">Learn about docs versions</a></h3>
<p>Currently, we maintain seven versions of TiDB documentation, each with a separate branch:</p>
<table><thead><tr><th align="left">Docs branch name</th><th align="left">Version description</th></tr></thead><tbody>
<tr><td align="left"><code>master</code> branch</td><td align="left">the latest development version</td></tr>
<tr><td align="left"><code>release-5.1</code> branch</td><td align="left">the 5.1 version</td></tr>
<tr><td align="left"><code>release-5.0</code> branch</td><td align="left">the 5.0 stable version</td></tr>
<tr><td align="left"><code>release-4.0</code> branch</td><td align="left">the 4.0 stable version</td></tr>
<tr><td align="left"><code>release-3.1</code> branch</td><td align="left">the 3.1 stable version</td></tr>
<tr><td align="left"><code>release-3.0</code> branch</td><td align="left">the 3.0 stable version</td></tr>
<tr><td align="left"><code>release-2.1</code> branch</td><td align="left">the 2.1 stable version</td></tr>
</tbody></table>
<p>Each docs version is updated very frequently and changes to one version often apply to another version or other versions as well. We introduce ti-chi-bot to automatically file PRs to other versions as long as you add corresponding cherry-pick labels to your PR.</p>
<h3 id="use-cherry-pick-labels"><a class="header" href="#use-cherry-pick-labels">Use cherry-pick labels</a></h3>
<ul>
<li>
<p>If your changes apply to only one doc version, just submit a PR to the corresponding version branch.</p>
</li>
<li>
<p>If your changes apply to multiple doc versions, you don't have to submit a PR to each branch. Instead, after you submit your PR, trigger the ti-chi-bot to submit a PR to other version branches by adding one or several of the following labels as needed. Once the current PR is merged, ti-chi-bot will start to work.</p>
<ul>
<li><code>needs-cherry-pick-release-5.1</code> label: ti-chi-bot will submit a PR to the <code>release-5.1</code> branch.</li>
<li><code>needs-cherry-pick-release-5.0</code> label: ti-chi-bot will submit a PR to the <code>release-5.0</code> branch.</li>
<li><code>needs-cherry-pick-release-4.0</code> label: ti-chi-bot will submit a PR to the <code>release-4.0</code> branch.</li>
<li><code>needs-cherry-pick-release-3.1</code> label: ti-chi-bot will submit a PR to the <code>release-3.1</code> branch.</li>
<li><code>needs-cherry-pick-release-3.0</code> label: ti-chi-bot will submit a PR to the <code>release-3.0</code> branch.</li>
<li><code>needs-cherry-pick-release-2.1</code> label: ti-chi-bot will submit a PR to the <code>release-2.1</code> branch.</li>
<li><code>needs-cherry-pick-master</code> label: ti-chi-bot will submit a PR to the <code>master</code> branch.</li>
</ul>
</li>
<li>
<p>If most of your changes apply to multiple doc versions but some differences exist among versions, you still can use cherry-pick labels to let ti-chi-bot create PRs to other versions. In this situation, you also need to add the <code>requires-version-specific-change</code> label as a reminder to the PR reviewer. After the PR to another version is successfully submitted by ti-chi-bot, you can make changes to that PR.</p>
</li>
</ul>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to contribute</a></h2>
<p>Your contribution journey is in two stages:</p>
<ol>
<li>
<p>In <a href="contribute-to-tidb/write-document.html#stage-1-create-and-submit-your-pr">stage 1</a>, create and submit your Pull Request to the <a href="https://github.com/pingcap/docs-cn">docs-cn</a> or <a href="https://github.com/pingcap/docs">docs</a> repository.</p>
</li>
<li>
<p>In <a href="contribute-to-tidb/write-document.html#stage-2-get-notified-and-address-review-comments">stage 2</a>, get notified of any review comments and address the comments until the PR gets approved and merged.</p>
</li>
</ol>
<h3 id="stage-1-create-and-submit-your-pr"><a class="header" href="#stage-1-create-and-submit-your-pr">Stage 1: Create and submit your PR</a></h3>
<p>Perform the following steps to create your Pull Request to the <a href="https://github.com/pingcap/docs">docs</a> repository. If don't like to use commands, you can also use <a href="https://desktop.github.com/">GitHub Desktop</a>, which is easier to get started.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>This section takes creating a PR to the <code>master</code> branch in the docs repository as an example. Steps of creating PRs to other branches or to the docs-cn repository are similar.</p>
</blockquote>
<h4 id="step-0-sign-the-cla"><a class="header" href="#step-0-sign-the-cla">Step 0: Sign the CLA</a></h4>
<p>Your PR can only be merged after you sign the <a href="https://cla-assistant.io/pingcap/docs">Contributor License Agreement (docs)</a>. Please make sure you sign the CLA before continuing.</p>
<h4 id="step-1-fork-the-repository"><a class="header" href="#step-1-fork-the-repository">Step 1: Fork the repository</a></h4>
<ol>
<li>Visit the project: <a href="https://github.com/pingcap/docs">https://github.com/pingcap/docs</a></li>
<li>Click the <strong>Fork</strong> button on the top right and wait it to finish.</li>
</ol>
<h4 id="step-2-clone-the-forked-repository-to-local-storage"><a class="header" href="#step-2-clone-the-forked-repository-to-local-storage">Step 2: Clone the forked repository to local storage</a></h4>
<pre><code>cd $working_dir # Comes to the directory that you want put the fork in, for example, &quot;cd ~/Documents/GitHub&quot;
git clone git@github.com:$user/docs.git # Replace &quot;$user&quot; with your GitHub ID

cd $working_dir/docs
git remote add upstream git@github.com:pingcap/docs.git # Adds the upstream repo
git remote -v # Confirms that your remote makes sense
</code></pre>
<h4 id="step-3-create-a-new-branch"><a class="header" href="#step-3-create-a-new-branch">Step 3: Create a new branch</a></h4>
<ol>
<li>
<p>Get your local master up-to-date with upstream/master.</p>
<pre><code>cd $working_dir/docs
git fetch upstream
git checkout master
git rebase upstream/master
</code></pre>
</li>
<li>
<p>Create a new branch based on the master branch.</p>
<pre><code>git checkout -b new-branch-name
</code></pre>
</li>
</ol>
<h4 id="step-4-do-something"><a class="header" href="#step-4-do-something">Step 4: Do something</a></h4>
<p>Edit some file(s) on the <code>new-branch-name</code> branch and save your changes. You can use editors like Visual Studio Code to open and edit <code>.md</code> files.</p>
<h4 id="step-5-commit-your-changes"><a class="header" href="#step-5-commit-your-changes">Step 5: Commit your changes</a></h4>
<pre><code>git status # Checks the local status
git add &lt;file&gt; ... # Adds the file(s) you want to commit. If you want to commit all changes, you can directly use `git add.`
git commit -m &quot;commit-message: update the xx&quot;
</code></pre>
<p>See <a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#how-to-write-a-good-commit-message">Commit Message Style</a>.</p>
<h4 id="step-6-keep-your-branch-in-sync-with-upstreammaster"><a class="header" href="#step-6-keep-your-branch-in-sync-with-upstreammaster">Step 6: Keep your branch in sync with upstream/master</a></h4>
<pre><code># While on your new branch
git fetch upstream
git rebase upstream/master
</code></pre>
<h4 id="step-7-push-your-changes-to-the-remote"><a class="header" href="#step-7-push-your-changes-to-the-remote">Step 7: Push your changes to the remote</a></h4>
<pre><code>git push -u origin new-branch-name # &quot;-u&quot; is used to track the remote branch from origin
</code></pre>
<h4 id="step-8-create-a-pull-request"><a class="header" href="#step-8-create-a-pull-request">Step 8: Create a pull request</a></h4>
<ol>
<li>Visit your fork at <a href="https://github.com/$user/docs">https://github.com/$user/docs</a> (replace <code>$user</code> with your GitHub ID)</li>
<li>Click the <code>Compare &amp; pull request</code> button next to your <code>new-branch-name</code> branch to create your PR. See <a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#pull-request-title-style">Pull Request Title Style</a>.</li>
</ol>
<p>Now, your PR is successfully submitted.</p>
<h3 id="stage-2-get-notified-and-address-review-comments"><a class="header" href="#stage-2-get-notified-and-address-review-comments">Stage 2: Get notified and address review comments</a></h3>
<p>After your PR is submitted, addressing review comments is just as important as creating the PR. Please perform the following steps to complete your contribution journey.</p>
<h4 id="step-1-get-notified-of-review-comments"><a class="header" href="#step-1-get-notified-of-review-comments">Step 1: Get notified of review comments</a></h4>
<p>After your PR is created, the repository administrator will add labels to your PR for PR management. Review comments will also be submitted to your PR, which requires you to modify the PR content.</p>
<p>Once the review comments are submitted, you will receive a notification in your registered email box. Check your email box and get notified.</p>
<p>Once you receive the email, click the PR link in the mail to open the PR page in your browser, and you will see the comments.</p>
<h4 id="step-2-address-review-comments"><a class="header" href="#step-2-address-review-comments">Step 2: Address review comments</a></h4>
<p>The review comments require you to change your submitted PR content. You can either accept a suggestion and make the change, or decline the suggestion and submit your reply right under the comment stating your reason.</p>
<h5 id="accept-comments-in-your-local-editor"><a class="header" href="#accept-comments-in-your-local-editor">Accept comments in your local editor</a></h5>
<p>To accept suggestions, perform the following steps to modify your submitted PR content:</p>
<ol>
<li>
<p>Pull the latest content from the remote origin of your PR to your local by executing the following commands in the terminal. This ensures that your local content is up-to-date with the remote origin.</p>
<pre><code>cd $working_dir/docs
git checkout new-branch-name
git fetch origin
</code></pre>
</li>
<li>
<p>Edit the file or files to be modified in your local editor (like Visual Studio Code) according to the review comments.</p>
</li>
<li>
<p>Commit your changes. This step is the same as <a href="contribute-to-tidb/write-document.html#step-5-commit-your-changes">Step 5: Commit your changes</a> in stage 1.</p>
<pre><code>git status # Checks the local status
git add &lt;file&gt; ... # Adds the file(s) you want to commit. If you want to commit all changes, you can directly use `git add.`
git commit -m &quot;commit-message: update the xx&quot;
</code></pre>
</li>
<li>
<p>Push your changes to the remote origin:</p>
<pre><code>git push -u origin new-branch-name # &quot;-u&quot; is used to track the remote branch from origin
</code></pre>
</li>
<li>
<p>After all comments are addressed, reply on the PR page: &quot;All comments are addressed. PTAL.&quot;</p>
<p>&quot;PTAL&quot; is short for &quot;Please take a look&quot;.</p>
</li>
</ol>
<h5 id="accept-comments-on-the-pr-page"><a class="header" href="#accept-comments-on-the-pr-page">Accept comments on the PR page</a></h5>
<p>If a review comment is in the suggestion mode where the reviewer has already made the suggested change for you (with highlighted differences), to accept the suggestion, you only need to click the &quot;Commit suggestion&quot; button. Then the suggested change is automatically committed to your PR.</p>
<p>If multiple review comments are in the suggestion mode, it is recommended to accept them in a batch. To do that, perform the following steps on the PR page:</p>
<ol>
<li>
<p>Click the &quot;Files changed&quot; tab and see the file changes. You can see multiple review comments in suggestion mode.</p>
</li>
<li>
<p>Choose the suggestions you want to commit by clicking the &quot;Add suggestion to batch&quot; button on each suggestion.</p>
</li>
<li>
<p>After all suggestions to be committed are chosen, click the &quot;Commit suggestions&quot; button on the upper right corner of the PR page. Then, you have successfully committed all suggested changes.</p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong></p>
<p>After you have addressed review comments, reviewers might also submit new comments. You need to repeat this step 2 and make sure all comments are addressed until the reviewers approve your PR and have it merged.</p>
</blockquote>
<h4 id="step-3-handle-cherry-picked-prs"><a class="header" href="#step-3-handle-cherry-picked-prs">Step 3: Handle cherry-picked PRs</a></h4>
<p>Once your PR gets approved, the repo administrator will have your PR merged into the docs upstream/master. After a few minutes, ti-chi-bot automatically creates PRs to other versions as you have specified by adding cherry-pick labels.</p>
<p>You need to perform the following steps on each one of the cherry-picked PRs:</p>
<ul>
<li>
<p>Check whether the cherry-picked content is exactly what you want to commit to that release version. If yes, please comment &quot;LGTM&quot;, which means &quot;Looks good to me&quot;. The repository administrator will merge it soon.</p>
</li>
<li>
<p>If most of your changes apply to multiple doc versions but some differences exist among versions, make changes by commenting in the cherry-picked PR instructing how you would like to make version-specific changes. Then the repository administrator will commit to the PR according to your comment before you approve it.</p>
</li>
<li>
<p>(Advanced) If any conflicts exist in the cherry-picked PR, resolve the conflicts. This is only for those who have the write permission in the repository.</p>
</li>
</ul>
<p>After the steps above are completed, the administrator will merge the cherry-picked PRs. At this point, your contribution journey is completed! ðŸŽ‰</p>
<h2 id="how-we-implement-bilingual-documentation"><a class="header" href="#how-we-implement-bilingual-documentation">How we implement bilingual documentation</a></h2>
<p>TiDB documentation is usually written in one language and then translated to another. We use GitHub labels in docs-cn and docs repos (as well as in docs-tidb-operator and docs-dm repos) to track the entire translation or alignment process.</p>
<p>The following labels are used:</p>
<ul>
<li><code>translation/doing</code>: This PR needs translation, or the translation is on the way.</li>
<li><code>translation/done</code>: This PR has been translated in another PR.</li>
<li><code>translation/from-docs</code>: This PR is translated from a docs PR.</li>
<li><code>translation/from-docs-cn</code>: This PR is translated from a docs-cn PR.</li>
<li><code>translation/no-need</code>: This PR does not need translation.</li>
</ul>
<p>The following process describes how a docs-cn PR (Chinese content) is translated and aligned to the docs repo (English content). The translation from docs to docs-cn is similar.</p>
<ol>
<li>
<p>Once a PR is created in docs-cn that updates the Chinese documentation, the repo administrator will soon add a <code>translation/doing</code> or <code>translation/no-need</code> label and an assignee (translator) to the PR. The tracking process begins.</p>
<p>The assignee regularly checks his or her PR list for translation. To check out his or her translation list, use the GitHub search syntax <code>is:pr assignee:@GitHub_ID is:merged label:translation/doing</code> in the GitHub search box on the <a href="https://github.com/pulls">GitHub Pull Requests page</a>.</p>
<p>PRs with the <code>translation/no-need</code> label are not tracked.</p>
</li>
<li>
<p>After this docs-cn PR is merged, the assignee starts the translation in the local editor.</p>
</li>
<li>
<p>Once the assignee submits the translated content in a docs PR, he or she adds the <code>translation/from-docs-cn</code> label to the docs PR, removes the <code>translation/doing</code> label from the docs-cn PR, and adds the <code>translation/done</code> label to the docs-cn PR.</p>
</li>
<li>
<p>The assignee provides the docs-cn PR link in the PR description section of the docs PR (&quot;This PR is translated from&quot;). The reviewer will know from which docs-cn PR the docs PR is translated. At the same time, a reverse link is automatically generated in the docs-cn PR.</p>
</li>
<li>
<p>After the docs PR is merged. The translation tracking process is finished. The updates in Chinese documentation are synchronized to the English documentation.</p>
</li>
</ol>
<p>If you want to apply for a translation, check the following lists of merged docs-cn/docs PRs with the <code>translation/doing</code> label, pick one PR, assign yourself with your GitHub ID, and start the process from step 2 above.</p>
<ul>
<li>The list of PR that can be translated in docs-cn: <a href="https://github.com/pingcap/docs-cn/pulls?q=is%3Apr+label%3Atranslation%2Fdoing+is%3Amreged">Pull requests Â· pingcap/docs-cn</a></li>
<li>The list of PR that can be translated in docs: <a href="https://github.com/pingcap/docs/pulls?q=is%3Apr+is%3Amerged+label%3Atranslation%2Fdoing+">Pull requests Â· pingcap/docs</a></li>
</ul>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p>Join the Slack channel: <a href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=sig-docs&amp;ref=pingcap-docs">#sig-docs</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous-topics"><a class="header" href="#miscellaneous-topics">Miscellaneous Topics</a></h1>
<h2 id="communication-channels"><a class="header" href="#communication-channels">Communication channels</a></h2>
<ul>
<li><a href="https://internals.tidb.io">TiDB Internals Forum</a>: TiDB hosts a Discourse instance for TiDB development discussions. It has many separate categories for different topics. You can discuss anything about TiDB development and community in the forum.</li>
</ul>
<h2 id="related-projects"><a class="header" href="#related-projects">Related projects</a></h2>
<ul>
<li><a href="https://github.com/tikv/tikv">TiKV</a>: TiKV is an open-source, distributed, and transactional key-value database. It is used by TiDB as the storage layer.</li>
<li><a href="https://university.pingcap.com/talent-plan/">Talent Plan</a>: Talent Plan is an open source training program initiated by PingCAP. It aims to create and combine some open source learning materials for people interested in open source, distributed systems, Rust, Golang, and other infrastructure knowledges.</li>
</ul>
<h2 id="community-events"><a class="header" href="#community-events">Community events</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introduction-of-tidb-architecture"><a class="header" href="#introduction-of-tidb-architecture">Introduction of TiDB Architecture</a></h1>
<p>Understanding TiDB talks about the architecture of TiDB, the modules it consists of, and the responsibility of each module.</p>
<h2 id="tidb-architecture"><a class="header" href="#tidb-architecture">TiDB Architecture</a></h2>
<p>When people refer to TiDB, they usually refer to the entire TiDB distributed database that includes three components: the TiDB stateless server, the Placement Driver (PD) server, and the storage server, TiKV or TiFlash. The TiDB server does not store data; it only computes and processes SQL queries. The PD server is the managing components of the entire cluster. The storage server is responsible for persistently storing data.</p>
<p>Let's see an architecture graph from TiDB stateless server's perspective.</p>
<p><img src="understand-tidb/../img/tidb-architecture.png" alt="tidb-architecture" /></p>
<p>As you can see, TiDB is a SQL engine that supports the MySQL protocol with some kind of distributed KV storage engine that supports transactions as the underlying storage.</p>
<p>Here come three significant questions.</p>
<ol>
<li>How to support MySQL protocol?</li>
<li>How to communicate with storage engine, store and load data?</li>
<li>How to implement SQL functions?</li>
</ol>
<p>This section will start with a few of brief descriptions of what modules TiDB has and what they do, and then put them together to answer these three questions.</p>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>TiDB source code is fully hosted on Github, you can see all the information from the <a href="https://github.com/pingcap/tidb">repository homepage</a>. The whole repository is developed in Golang and divided into many packages according to functional modules.</p>
<p>Most of the packages export services in the form of interfaces, and most of the functionality is concentrated in one package. But there are packages that provide basic functionality and are dependent on many packages, so these packages need special attention.</p>
<p>The main method of TiDB locates in <code>tidb-server/main.go</code>, which defines how the service is started.</p>
<p>The build system of the entire project can be found in the <code>Makefile</code>.</p>
<p>In addition to the code, there are many test cases, which can be found with suffix <code>_test.go</code>. There is also toolkit under the <code>cmd</code> directory for doing performance tests or constructing test data.</p>
<h3 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h3>
<p>TiDB has a number of modules. Table below is an overview that shows what each module does, and if you want to see the code for the relevant function, you can find the corresponding module directly.</p>
<table><thead><tr><th align="left">Package</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/pingcap/parser">pingcap/parser</a></td><td align="left">A MySQL compatible SQL parser used by TiDB, also contains the data structure definition of abstract syntax tree (AST) and other metadata.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/bindinfo">pingcap/tidb/bindinfo</a></td><td align="left">Handles all global sql bind operations, and caches the sql bind info from storage.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/config">pingcap/tidb/config</a></td><td align="left">The configuration definition.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/ddl">pingcap/tidb/ddl</a></td><td align="left">The execution logic of data definition language (DDL).</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/distsql">pingcap/tidb/distsql</a></td><td align="left">The abstraction of the distributed computing interfaces to isolate the logic between the executor and the TiKV client</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/domain">pingcap/tidb/domain</a></td><td align="left">The abstraction of a storage space in which databases and tables can be created. Like namespace, databases with the same name can exist in different domains. In most cases, a single TiDB instance only creates one Domain instance with details about the information schema and statistics.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/errno">pingcap/tidb/errno</a></td><td align="left">The definition of MySQL error code, error message, and error summary.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/executor">pingcap/tidb/executor</a></td><td align="left">The operator related code that contains the execution logic of most statements.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/expression">pingcap/tidb/expression</a></td><td align="left">The expression-related code that contains various operators and built-in functions.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/infoschema">pingcap/tidb/infoschema</a></td><td align="left">The metadata management module for SQL statements; accessed when all the operations on the information schema are executed.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/kv">pingcap/tidb/kv</a></td><td align="left">The Key-Value engine interface and some public methods; the interfaces defined in this package need to be implemented by the storage engine which is going to adapt TiDB SQL layer.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/lock">pingcap/tidb/lock</a></td><td align="left">The implementation of LOCK/UNLOCK TABLES.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/meta">pingcap/tidb/meta</a></td><td align="left">Manages the SQL metadata in the storage engine through the features of the structure package; infoschema and DDL use this module to access or modify the SQL metadata .</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/meta/autoid">pingcap/tidb/meta/autoid</a></td><td align="left">A module to generate the globally unique monotonically incremental IDs for each table, as well as the database ID and table ID.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/metrics">pingcap/tidb/metrics</a></td><td align="left">Store the metrics information of all modules.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/owner">pingcap/tidb/owner</a></td><td align="left">Some tasks in the TiDB cluster can be executed by only one instance, such as the asynchronous schema change. This owner module is used to coordinate and generate a task executor among multiple TiDB servers. Each task has its own executor.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner">pingcap/tidb/planner</a></td><td align="left">Queries optimization related code.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/plugin">pingcap/tidb/plugin</a></td><td align="left">The plugin framework of TiDB.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/privilege">pingcap/tidb/privilege</a></td><td align="left">The management interface of user privileges.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/server">pingcap/tidb/server</a></td><td align="left">Code of the MySQL protocol and connection management.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/session">pingcap/tidb/session</a></td><td align="left">Code of session management.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/binloginfo">pingcap/tidb/sessionctx/binloginfo</a></td><td align="left">Output binlog information.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/stmtctx">pingcap/tidb/sessionctx/stmtctx</a></td><td align="left">Necessary information for the statement of a session during runtime.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/variable">pingcap/tidb/sessionctx/variable</a></td><td align="left">System variable related code.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/statistics">pingcap/tidb/statistics</a></td><td align="left">Code of table statistics.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/store">pingcap/tidb/store</a></td><td align="left">Storage engine drivers, wrapping Key-Value client to meet the requirements of TiDB.</td></tr>
<tr><td align="left"><a href="https://github.com/tikv/client-go">tikv/client-go</a></td><td align="left">The Go client of TiKV.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/structure">pingcap/tidb/structure</a></td><td align="left">The structured API defined on the Transactional Key-Value API, providing structures like List, Queue, and HashMap.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/table">pingcap/tidb/table</a></td><td align="left">The abstraction of Table in SQL.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/tablecodec">pingcap/tidb/tablecodec</a></td><td align="left">Encode and decode data from SQL to Key-Value. See the codec package for the specific encoding and decoding solution for each data type.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/telemetry">pingcap/tidb/telemetry</a></td><td align="left">Code of telemetry collect and report.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/tidb-server">pingcap/tidb/tidb-server</a></td><td align="left">The main method of the TiDB service.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/types">pingcap/tidb/types</a></td><td align="left">All the type related code, including the definition of and operation on types.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/util">pingcap/tidb/util</a></td><td align="left">Utilities.</td></tr>
</tbody></table>
<p>At a glance, TiDB has 80 packages, which might let you feel overwhelmed, but not all of them are important, and some features only involve a small number of packages, so where to start to look at the source code depends on the purpose of looking at the source code.</p>
<p>If you want to understand the implementation details of a specific feature, then you can refer to the module description above and just find the corresponding module.</p>
<p>If you want to have a comprehensive understanding of the source code, then you can start from <code>tidb-server/main.go</code> and see how tidb-server starts and how it waits for and handles user requests. Then follow the code all the way through to see the exact execution of the SQL. There are also some important modules that need to be looked at to know how they are implemented. For the auxiliary modules, you can look at them selectively to get a general impression.</p>
<h3 id="sql-layer-architecture"><a class="header" href="#sql-layer-architecture">SQL Layer Architecture</a></h3>
<p><img src="understand-tidb/../img/sql-layer-architecture.png" alt="sql-layer-architecture" /></p>
<p>This is a detailed SQL layer architecture graph. You can read it from left to right.</p>
<h3 id="protocol-layer"><a class="header" href="#protocol-layer">Protocol Layer</a></h3>
<p>The leftmost is the Protocol Layer of TiDB, this is the interface to interact with Client, currently TiDB only supports MySQL protocol, the related code is in the <code>server</code> package.</p>
<p>The purpose of this layer is to manage the client connection, parse MySQL commands and return the execution result. The specific implementation is according to MySQL protocol, you can refer to <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL Client/Server Protocol document</a>. If you need to use MySQL protocol parsing and processing functions in your project, you can refer to this module.</p>
<p>The logic for connection establishment is in the <code>Run()</code> method of <code>server.go</code>, mainly in the following two lines.</p>
<pre><code class="language-go">conn, err := s.listener.Accept()
clientConn := s.newConn(conn)
go s.onConn(clientConn)
</code></pre>
<p>The entry method for a single session processing command is to call the <code>dispatch</code> method of the <code>clientConn</code> class, where the protocol is parsed and passed to a different handler.</p>
<h3 id="sql-layer"><a class="header" href="#sql-layer">SQL Layer</a></h3>
<p>Generally speaking, a SQL statement needs to go through a series of processes: </p>
<ol>
<li>syntax parsing</li>
<li>validity verification</li>
<li>building query plan </li>
<li>optimizing query plan</li>
<li>generating executor according to plan</li>
<li>executing and returning results</li>
</ol>
<p>These processes locate at the following modules:</p>
<table><thead><tr><th align="left">Package</th><th align="left">Usage</th></tr></thead><tbody>
<tr><td align="left">pingcap/tidb/sever</td><td align="left">Interface between protocol layer and SQL layer</td></tr>
<tr><td align="left">pingcap/parser</td><td align="left">SQL parsing and syntax analyze</td></tr>
<tr><td align="left">pingcap/tidb/planner</td><td align="left">Validation, query plan building, query plan optimizing</td></tr>
<tr><td align="left">pingcap/tidb/executor</td><td align="left">Executor generation and execution</td></tr>
<tr><td align="left">pingcap/tidb/distsql</td><td align="left">Send request to TiKV and aggregate return results from TiKV via TiKV Client</td></tr>
<tr><td align="left">pingcap/tidb/kv</td><td align="left">KV client interface</td></tr>
<tr><td align="left">tikv/client-go</td><td align="left">TiKV Go Client</td></tr>
</tbody></table>
<h3 id="kv-api-layer"><a class="header" href="#kv-api-layer">KV API Layer</a></h3>
<p>TiDB relies on the underlying storage engine to store and load data. It does not rely on a specific storage engine (such as TiKV), but has some requirements for the storage engine, and any engine that meets these requirements can be used (TiKV is the most suitable one).</p>
<p>The most basic requirement is &quot;Key-Value engine with transactions and Golang driver&quot;. The more advanced requirement is &quot;support for distributed computation interface&quot;, so that TiDB can push some computation requests down to the storage engine.</p>
<p>These requirements can be found in the interfaces of the <code>kv</code> package, and the storage engine needs to provide a Golang driver that implements these interfaces, which TiDB then uses to manipulate the underlying data.</p>
<p>As for the most basic requirement, these interfaces are related:</p>
<ul>
<li><code>Transaction</code>: Basic manipulation of transaction</li>
<li><code>Receiver</code>: Interface for reading data</li>
<li><code>Mutator</code>: Interface for mutating data</li>
<li><code>Storage</code>: Basic functionality provided by the driver</li>
<li><code>Snapshot</code>: Basic manipulation of data snapshot</li>
<li><code>Iterator</code>: Result of <code>Seek</code>, used to iterate data</li>
</ul>
<p>With the above interfaces, you are able to do all the required operations on the data and complete all the SQL functions. However, for more efficient computing, we have also defined an advanced computing interface, which can focus on these three interfaces or structures:</p>
<ul>
<li><code>Client</code>: Send request to storage engine</li>
<li><code>Request</code>: Payload of the request</li>
<li><code>Response</code>: Abstraction of result</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This section talks about the source structure of TiDB and the architecture of three significant components. More details will be described in the later sections.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-life-cycle-of-a-statement"><a class="header" href="#the-life-cycle-of-a-statement">The Life cycle of a Statement</a></h1>
<h2 id="mysql-protocol-package-with-command-and-statement-string"><a class="header" href="#mysql-protocol-package-with-command-and-statement-string">MySQL protocol package with command and statement string</a></h2>
<p>After connecting and getting authenticated, the server is in a <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L938">statement execution loop</a> until the client is disconnected.</p>
<p>The <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1111">dispatch</a> function checks what kind of command was sent through the MySQL protocol and dispatches the matching function, like this snippet:</p>
<pre><code class="language-golang">	switch cmd {
	// ...
	case mysql.ComQuit:
		return io.EOF
	case mysql.ComInitDB:
		if err := cc.useDB(ctx, dataStr); err != nil {
			return err
		}
		return cc.writeOK(ctx)
	case mysql.ComQuery: // Most frequently used command.
		return cc.handleQuery(ctx, dataStr)
	// ...
	}
</code></pre>
<p>Where <a href="https://github.com/pingcap/parser/blob/d4a88481405f8c59d45fc0a9c38ee24d55b9bf49/mysql/const.go#L102">mysql.ComQuery</a> is routed to <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1633">handleQuery</a>, which handles all different non-prepared statements (some commands like change database/schema or ping are handled directly in the dispatch function).</p>
<p>TiDB keep the state between statements like sql_mode, transaction state etc. in the clientConn's <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/sessionctx/context.go#L43">sessionctx.Context</a> struct.</p>
<p>The MySQL protocol is synchronous, and the typical execution flow revolves around a client sending a single query, and receiving an optional result set ending with an OK package containing the success flag and optional warnings/errors and possible metadata such as affected rows.</p>
<p>As shown here; it is possible that a client might send multiple queries in one mysql.ComQuery call, in which case the cc.ctx.Parse will return multiple results. However; this is not a common occurrence. By default, multiple statements in one mysql.ComQuery call is disabled for security reasons, like making sql injections like <code>SELECT user FROM users WHERE id = ''/* sql injection */; INSERT INTO users VALUES (null, 'EvilUser'); -- '</code>. Clients must explicitly enable the ClientMultiStatements protocol feature.</p>
<h2 id="high-level-code-for-handling-a-query"><a class="header" href="#high-level-code-for-handling-a-query">High level code for handling a query</a></h2>
<p>Real types and function names, but only high level for less distraction by too much details</p>
<p>Further explanations below.</p>
<pre><code class="language-golang">// handleQuery is the entry point for running client connection statements/queries
func (cc *clientConn) handleQuery(ctx context.Context, sql string) (error) {
	stmts, err := cc.ctx.Parse(ctx, sql)
	// ...
	for i, stmt := range stmts {
		retryable, err = cc.handleStmt(ctx, stmt, ...)
		// ...
	}
}

// handleStmt handles a single statement
func (cc *clientConn) handleStmt(ctx context.Context, stmt ast.StmtNode, ...) (bool, error) {
	resultSet, err := cc.ctx.ExecuteStmt(ctx, stmt)
	// ...
	retryable, err := cc.writeResultset(ctx, resultSet, ...)
	// ...
}

func (tc *TiDBContext) ExecuteStmt(ctx context.Context, stmt ast.StmtNode) (ResultSet, error) {
	resultSet, err := tc.Session.ExecuteStmt(ctx, stmt)
	// ...
	return resultSet, err
}

// ExecuteStmt takes an Abstract Syntax Tree and will go through the optimizer and start the execution
// and return a recordSet.
func (s *session) ExecuteStmt(ctx context.Context, stmtNode ast.StmtNode) (sqlexec.RecordSet, error) {
	// ...
	compiler := executor.Compiler{Ctx: s}
	stmt, err := compiler.Compile(ctx, stmtNode)
	// ...
	resultSet, err := runStmt(ctx, s, stmt)
	// ...
	return resultSet, err
}

// Compile compiles an ast.StmtNode to a physical plan.
func (c *Compiler) Compile(ctx context.Context, stmtNode ast.StmtNode) (*ExecStmt, error) {
	// ...
	// PrepareTxnCtx starts a goroutine to begin a transaction if needed, and creates a new transaction context.
	s.PrepareTxnCtx(ctx)

	// Preprocess resolves table names of the node, and checks some statements validation.
	err := plannercore.Preprocess(c.Ctx, stmtNode, plannercore.WithPreprocessorReturn(ret), plannercore.WithExecuteInfoSchemaUpdate(pe))
	// ...
	// Optimize does optimization and creates a Plan.
	// The node must be prepared first.
	finalPlan, names, err := planner.Optimize(ctx, c.Ctx, stmtNode, ret.InfoSchema)
}

// runStmt executes the sqlexec.Statement and commit or rollback the current transaction.
func runStmt(ctx context.Context, se *session, s sqlexec.Statement) (sqlexec.RecordSet, error) {
	rs, err := s.Exec(ctx)
	// ...
	return &amp;execStmtResult{RecordSet: rs, ...}, err
}

// writeResultset iterates over the Resultset and sends it to the client connection.
func (cc *clientConn) writeResultset(ctx context.Context, rs ResultSet ...) (bool, error) {
	retryable, err = cc.writeChunks(ctx, rs, ...)
	// ...
	return false, cc.flush(ctx)
}

// writeChunks writes data from a Chunk, which filled data by a ResultSet, into a connection.
func (cc *clientConn) writeChunks(ctx context.Context, rs ResultSet ...) (bool, error) {
	req := rs.NewChunk()
	for {
		err := rs.Next(ctx, req)
		// ...
		rowCount := req.NumRows()
		if rowCount == 0 {
			break
		}
		cc.writePacket(...)
	}
	return false, cc.writeEOF(...)
}
</code></pre>
<h2 id="statement-string-to-abstract-syntax-tree"><a class="header" href="#statement-string-to-abstract-syntax-tree">Statement string to Abstract Syntax Tree</a></h2>
<p>In <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1633">handleQuery</a> the statement string is <a href="https://github.com/pingcap/parser/blob/d4a88481405f8c59d45fc0a9c38ee24d55b9bf49/yy_parser.go#L137">parsed</a> by <a href="https://github.com/pingcap/parser">the parser, which is in its own repository</a>, that is a MySQL compatible parser parsing statements and returns an Abstract Syntax Tree (AST) representing the statement. See more in the <a href="understand-tidb/parser.html">parser section</a></p>
<p>Example of Abstract Syntax tree, the fragment of a <code>WHERE</code> clause <code>`id` &gt; 1 AND `value` = 'Second'</code> looks like:</p>
<pre><code class="language-golang">ast.BinaryOperationExpr{
  Op: opcode.LogicAnd,
  L:  ast.BinaryOperationExpr{
    Op: opcode.GT,
    L:  ast.ColumnName{Name: 'id'},
    R:  parser_driver.ValueExpr{i: 1}
  },
  R: ast.BinaryOperationExpr{
    Op: opcode.EQ,
    L:  ast.ColumnName{Name: 'value'},
    R:  parser_driver.ValueExpr{b: 'Second'}
  },
}
</code></pre>
<h2 id="ast---physical-execution-plan"><a class="header" href="#ast---physical-execution-plan">AST -&gt; Physical execution plan</a></h2>
<p>Then the statement in AST form is handled in <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1814">handleStmt</a>/<a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/session/session.go#L1620">ExecuteStmt</a> where the Abstract Syntax Tree is <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/executor/compiler.go#L50">compiled</a> first to a logical plan and then to a physical execution plan, including <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/planner/optimize.go#L100">optimizing</a> the execution plan, through a cost based optimizer. There are several steps in this process, such as name resolution, transaction management, <a href="understand-tidb/privilege.html">privilege checks</a>, handling given hints, etc.</p>
<p>One important thing to note is the <code>planner.TryFastPlan()</code> function that checks if there is a shortcut for a PointGet plan, to avoid spending too much time in the optimizer for <em>simple</em> queries, like primary key lookups.</p>
<p>For deeper understanding, please read the <a href="understand-tidb/planner.html">planner section</a></p>
<p>Example of plan from a simple select:</p>
<pre><code class="language-sql">tidb&gt; explain select id, value from t where id &gt; 1 and value = 'Second';
+--------------------------+---------+-----------+---------------+----------------------------------+
| id                       | estRows | task      | access object | operator info                    |
+--------------------------+---------+-----------+---------------+----------------------------------+
| TableReader_7            | 0.00    | root      |               | data:Selection_6                 |
| â””â”€Selection_6            | 0.00    | cop[tikv] |               | eq(test.t.value, &quot;Second&quot;)       |
|   â””â”€TableRangeScan_5     | 1.00    | cop[tikv] | table:t       | range:(1,+inf], keep order:false |
+--------------------------+---------+-----------+---------------+----------------------------------+
</code></pre>
<p>Where TableReader_7 is the task which will run in TiDB, getting already filtered data from Selection_6 scheduled on the storage nodes (TiKV/TiFlash) directly connected to the storage nodes Table/index range scan task/coprocessor, TableRangeScan_5.</p>
<h2 id="executing-the-optimized-plan"><a class="header" href="#executing-the-optimized-plan">Executing the optimized plan</a></h2>
<p>The optimized plan is executed through <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/session/session.go#L1750">runStmt</a>, which builds an <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/executor/adapter.go#L319">executor</a> from the plan and will return a record set or directly execute the statements in case no records will be returned, like <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> statements. Before returning the record set, the executor starts the execution by calling the Volcano inspired <code>Open()</code> API and the <code>Next()</code> API to retrieve the first chunk of data or execute the statement fully if no records are to be returned.</p>
<p>The executors are often including coprocessors as seen above, where tasks can be seen as stream processors and can be parallelized and delegated to storage nodes (TiKV/TiFlash).</p>
<p>For Data Manipulation Language statements, the changes are buffered in a transaction buffer on the TiDB node, which is different in how MySQL/InnoDB handles it (where the changes are done directly in the btrees and undone in case of rollback. More information in the <a href="understand-tidb/dml.html">DML section</a></p>
<h3 id="requests-sent-to-tikvtiflash-coprocessors"><a class="header" href="#requests-sent-to-tikvtiflash-coprocessors">Requests sent to TiKV/TiFlash coprocessors</a></h3>
<p>During the execution different task are executed as coprocessors and delegated/pushed down to the storage nodes (TiKV/TiFlash) for both scaling and more optimized use of the cluster.</p>
<p>This way there is less data sent between TiDB nodes and TiKV/TiFlash nodes (only filtered and aggregated results) and the computation/load are distributed across several storage nodes.</p>
<p>Common coprocessors are: TableScan (simplest form no real optimisation), IndexScan (Range reads from index), Selection (Filter on condition, <code>WHERE</code> clause etc.), LIMIT (no more than N records), TopN (Order + Limit), Aggregation (<code>GROUP BY</code>)</p>
<pre><code class="language-golang">// HandleStreamRequest handles the coprocessor stream request.
func (h *CoprocessorDAGHandler) HandleStreamRequest(ctx context.Context, req *coprocessor.Request, stream tikvpb.Tikv_CoprocessorStreamServer) error {
  e, err := h.buildDAGExecutor(req)
  err = e.Open(ctx)
  chk := newFirstChunk(e)
  for {
    chk.Reset()
    err = Next(ctx, e, chk)
    // ...
    if chk.NumRows() == 0 {
       return h.buildResponseAndSendToStream(chk, ...)
    }
  }
}
</code></pre>
<p>As seen above the Volcano inspired execution is iterating over <code>chunks</code> of data, not records one-by-one, which also allows for vectorization, which formats the chunk data so it can be processed as a vector instead of looping over each record and column one by one.</p>
<h3 id="sending-the-result-back-to-the-client"><a class="header" href="#sending-the-result-back-to-the-client">Sending the result back to the client</a></h3>
<p>If the statement returns a record set, it is handled in <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1993">writeChunks</a> which loops over the record set's <code>Next()</code> until empty and then adds some context/metadata to the MySQL OK package and flushes the data back to the client.</p>
<p>Notice that things like error handling, tracing etc. are not explained in this page.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ddl"><a class="header" href="#ddl">DDL</a></h1>
<p>Example:</p>
<pre><code class="language-sql">create table t(a bigint, b bigint);
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dml"><a class="header" href="#dml">DML</a></h1>
<p>Example:</p>
<pre><code class="language-sql">insert into t values (1, 1);
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dql"><a class="header" href="#dql">DQL</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This chapter describes the execution process of a data query statement in TiDB. Starting from the SQL processing flow, it describes how a SQL statement is sent to TiDB, how TiDB processes it after receiving the SQL statement, and how the execution result is returned.</p>
<h2 id="execution-process"><a class="header" href="#execution-process">Execution Process</a></h2>
<p>Briefly, the execution process of a SQL statement can be divided into three stages:</p>
<ol>
<li>
<p>Protocol Layer</p>
<p>Protocol layer is responsible for parsing the network protocol. Its code locates at <code>server</code> package, mainly consisting of two parts: one for connection establishing and management, every connection corresponds to one session separately; one for handling the packets read from the connection.</p>
</li>
<li>
<p>SQL Layer</p>
<p>SQL layer is the most complex part in TiDB, handling SQL statement parsing and execution. SQL is a complex language, having various data types and operators, numerous syntax combinations. Besides, TiDB uses a distributed storage engine underneath, so it will encounter many problems standalone storage engines won't.</p>
</li>
<li>
<p>KV API Layer</p>
<p>KV API layer routes requests to the right KV server and passes the results back to SQL layer. It should handle the exceptions happened in this stage.</p>
</li>
</ol>
<p>A SQL statement goes through the above three stages sequentially, get parsed and transformed, then handled by SQL layer. In SQL layer, query plans are generated and executed, retrieving data from the underneath storage engine. We'll give a detailed introduction to SQL layer.</p>
<h3 id="protocol-layer-1"><a class="header" href="#protocol-layer-1">Protocol Layer</a></h3>
<h4 id="entry"><a class="header" href="#entry">Entry</a></h4>
<p>The entry of TiDB's SQL layer is in <code>server/conn.go</code>. After a connection is established between the client and TiDB, TiDB spawns a goroutine to listen and poll on the port. In <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L911">clientConn.Run()</a>, a loop keeps reading network packets and calls <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1111">clientConn.dispatch()</a> to handle them:</p>
<pre><code class="language-go">data, err := cc.readPacket()
if err = cc.dispatch(ctx, data)
</code></pre>
<p><code>dispatch</code> handles the raw data array. The first byte of the array represents command type. Among the types, <code>COM_QUERY</code> represents data query statement. You can refer to <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL protocol</a> for more information about the data array. For <code>COM_QUERY</code>, its content is SQL statement. <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1633">clientConn.handleQuery()</a> handles the SQL statement. It calls <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/driver_tidb.go#L217">TiDBContext.ExecuteStmt()</a> in <code>server/driver_tidb.go</code>:</p>
<pre><code class="language-go">func (tc *TiDBContext) ExecuteStmt(ctx context.Context, stmt ast.StmtNode) (ResultSet, error) {
	rs, err := tc.Session.ExecuteStmt(ctx, stmt)
</code></pre>
<p><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/session/session.go#L1620">session.ExecuteStmt()</a> is the entry of the SQL layer kernel and returns the result of the SQL execution.</p>
<h4 id="exit"><a class="header" href="#exit">Exit</a></h4>
<p>After a series of operations described above, the execution results will be returned to the client in <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html">COM_QUERY response</a> format by <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1943">clientConn.writeResultSet()</a>.</p>
<h3 id="sql-layer-1"><a class="header" href="#sql-layer-1">SQL Layer</a></h3>
<p>In SQL layer, there are multiple concepts and interfaces we need to pay close attention to:</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/session/session.go#L123">Session</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/util/sqlexec/restricted_sql_executor.go#L133">RecordSet</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/planner/core/plan.go#L36">Plan</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/executor.go#L258">Executor</a></li>
</ul>
<h4 id="a-hrefunderstand-tidbsessionhtmlsessiona"><a class="header" href="#a-hrefunderstand-tidbsessionhtmlsessiona"><a href="understand-tidb/session.html">Session</a></a></h4>
<p>The most important function in <code>Session</code> is <code>ExecuteStmt</code>. It wraps calls to other modules. The SQL execution will respect environment variables in <code>Session</code> like <code>AutoCommit</code> and timezone.</p>
<h4 id="a-hrefunderstand-tidbparserhtmlparsera"><a class="header" href="#a-hrefunderstand-tidbparserhtmlparsera"><a href="understand-tidb/parser.html">Parser</a></a></h4>
<p><a href="https://github.com/pingcap/parser/blob/10b704ade769e4eb0681b74c0c223c4291073308/yy_parser.go">Parser</a> consists of <a href="https://github.com/pingcap/parser/blob/10b704ade769e4eb0681b74c0c223c4291073308/lexer.go">Lexer</a> and Yacc. It turns the SQL text to AST:</p>
<pre><code class="language-go">p := parserPool.Get().(*parser.Parser)
defer parserPool.Put(p)
p.SetSQLMode(s.sessionVars.SQLMode)
p.SetParserConfig(s.sessionVars.BuildParserConfig())
tmp, warn, err := p.Parse(sql, charset, collation)
</code></pre>
<p>In the parsing process, lexer first transforms the SQL text to tokens, and then parser accepts the tokens as inputs and generates appropriate AST nodes. For example, statement <code>SELECT * FROM t WHERE c &gt; 1;</code> matches <a href="https://github.com/pingcap/tidb/blob/45457ea8810ca7b835da4ba7f55d0eee02043ac5/parser/parser.y#L3936">SelectStmt rule</a> finally turns to the structure below:</p>
<pre><code class="language-go">type SelectStmt struct {
	dmlNode
	// SelectStmtOpts wraps around select hints and switches.
	*SelectStmtOpts
	// Distinct represents whether the select has distinct option.
	Distinct bool
	// From is the from clause of the query.
	From *TableRefsClause
	// Where is the where clause in select statement.
	Where ExprNode
	// Fields is the select expression list.
	Fields *FieldList
	// GroupBy is the group by expression list.
	GroupBy *GroupByClause
	// Having is the having condition.
	Having *HavingClause
	// WindowSpecs is the window specification list.
	WindowSpecs []WindowSpec
	// OrderBy is the ordering expression list.
	OrderBy *OrderByClause
	// Limit is the limit clause.
	Limit *Limit
	// LockInfo is the lock type
	LockInfo *SelectLockInfo
	// TableHints represents the table level Optimizer Hint for join type
	TableHints []*TableOptimizerHint
	// IsInBraces indicates whether it's a stmt in brace.
	IsInBraces bool
	// WithBeforeBraces indicates whether stmt's with clause is before the brace.
	// It's used to distinguish (with xxx select xxx) and with xxx (select xxx)
	WithBeforeBraces bool
	// QueryBlockOffset indicates the order of this SelectStmt if counted from left to right in the sql text.
	QueryBlockOffset int
	// SelectIntoOpt is the select-into option.
	SelectIntoOpt *SelectIntoOption
	// AfterSetOperator indicates the SelectStmt after which type of set operator
	AfterSetOperator *SetOprType
	// Kind refer to three kind of statement: SelectStmt, TableStmt and ValuesStmt
	Kind SelectStmtKind
	// Lists is filled only when Kind == SelectStmtKindValues
	Lists []*RowExpr
	With  *WithClause
}
</code></pre>
<p><code>From t</code> is parsed to <code>From</code> field. <code>WHERE c &gt; 1</code> is parsed to <code>Where</code> field. <code>*</code> is parsed to <code>Fields</code> field. Most data structures in <code>ast</code> package implement <code>ast.Node</code> interface. This interface has a <code>Accept</code> method, implementing the classic visitor pattern, used by following procedures to traverse the tree.</p>
<h4 id="compile"><a class="header" href="#compile">Compile</a></h4>
<p>After the AST is generated, it's going to be validated, transformed and optimized in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/compiler.go#L50">Compiler.Compile()</a>:</p>
<pre><code class="language-go">compiler := executor.Compiler{Ctx: s}
stmt, err := compiler.Compile(ctx, stmtNode)
</code></pre>
<p>There are three steps:</p>
<ol>
<li><code>plan.Preprocess</code>: do validations and name binding.</li>
<li><code>plan.Optimize</code>: make and optimize query plans, this is the core part.</li>
<li>construct <code>executor.ExecStmt</code> structure: <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/adapter.go#L186">ExecStmt</a> holds the query plans. It's the foundation for following execution.</li>
</ol>
<h4 id="a-hrefunderstand-tidbexecutionhtmlexecutora"><a class="header" href="#a-hrefunderstand-tidbexecutionhtmlexecutora"><a href="understand-tidb/execution.html">Executor</a></a></h4>
<p>While constructing the executor in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/adapter.go#L764">ExecStmt.buildExecutor()</a>, query plans are turned to executor. Then the execution engine could perform the query plans via the executor. The generated executor is encapsulated in a <code>recordSet</code> structure:</p>
<pre><code class="language-go">return &amp;recordSet{
	executor:   e,
	stmt:       a,
	txnStartTS: txnStartTS,
}
</code></pre>
<p>This structure implements <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/util/sqlexec/restricted_sql_executor.go#L133">ast.RecordSet</a> interface. It abstracts the query results and has the following methods:</p>
<pre><code class="language-go">type RecordSet interface {
	// Fields gets result fields.
	Fields() []*ast.ResultField
	// Next reads records into chunk.
	Next(ctx context.Context, req *chunk.Chunk) error
	// NewChunk create a chunk.
	NewChunk() *chunk.Chunk
	// Close closes the underlying iterator, call Next after Close will
	// restart the iteration.
	Close() error
}
</code></pre>
<p>The functionality of each method is described in the comments. In short, <code>Fields()</code> retrieves the type of each column. <code>Next()</code> returns a batch of the result. <code>Close()</code> closes the result set.</p>
<p>TiDB's execution engine executes in Volcano model. All the executors constitute an executor tree. Every upper layer gathers results from the lower layer by calling its <code>Next()</code> method. Assuming we have a SQL statement <code>SELECT c1 FROM t WHERE c2 &gt; 1;</code> and the query plan is full table scanning plus filtering, the executor tree is like:</p>
<p><img src="understand-tidb/../img/dql-volcano.png" alt="" /></p>
<p>From the above picture, we can see the data flow between executors. The starting point of a SQL statement execution, also the first <code>Next()</code> call is in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L2016">the function returning data back to the client</a>:</p>
<pre><code class="language-go">err := rs.Next(ctx, req)
</code></pre>
<p><code>rs</code> is a <code>RecordSet</code> instance. Keep calling its <code>Next</code> method to get more results to return to the client.</p>
<h2 id="overall-diagram"><a class="header" href="#overall-diagram">Overall Diagram</a></h2>
<p>The above SQL query statement execution process can in general be described as the following picture:</p>
<p><img src="understand-tidb/../img/dql-frame-diagram.png" alt="" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>Parser is responsible for interpreting a SQL string into an abstract syntax tree (AST), which is more structural and easier to process. AST can be used for preprocessing, syntactic analysis, and so on.</p>
<p>The code lives in the <a href="https://github.com/pingcap/parser">pingcap/parser</a> repo.</p>
<h2 id="understand-parser"><a class="header" href="#understand-parser">Understand Parser</a></h2>
<p>Parser is generated by a parser generator named <a href="https://github.com/cznic/parser">yacc</a>. It takes the grammar file <code>parser.y</code> as the input and outputs the source code file <code>parser.go</code>, which is the real parser imported by TiDB. Thus, the core file is <code>parser.y</code> because when the SQL syntax changes, most of the changes take place in <code>parser.y</code>.</p>
<p>In case you are unfamiliar with yacc, some concepts are listed here:</p>
<ul>
<li><strong>Terminal Symbol</strong> is also known as &quot;token&quot;. When a SQL string reaches parser, the first step is to tokenize them into an array of tokens. For example, <code>&quot;SELECT * FROM t&quot;</code> is tokenized to <code>[selectKeyword, '*', fromKeyword, identifier(t)]</code> by <a href="https://github.com/pingcap/parser/blob/ae8dec26d777272d56288fa4c9d4264ce0d31a03/lexer.go#L178">lexer.Lex()</a>.</li>
<li><strong>Non-terminal Symbol</strong> is a syntactic variable, which can represent a group of terminal/non-terminal symbols.</li>
<li><strong>Grammar Rule</strong> specifies which symbols can replace which other non-terminal symbol.</li>
<li><strong>Semantic Action</strong> defines how an AST node is constructed.</li>
</ul>
<p>An example of a grammar rule is as follows:</p>
<pre><code>AlterDatabaseStmt:
	&quot;ALTER&quot; DatabaseSym DBName DatabaseOptionList
	{
		$$ = &amp;ast.AlterDatabaseStmt{
			Name:                 $3,
			AlterDefaultDatabase: false,
			Options:              $4.([]*ast.DatabaseOption),
		}
	}
</code></pre>
<ul>
<li><code>AlterDatabaseStmt</code> is a non-terminal symbol because there is no such token.</li>
<li><code>&quot;ALTER&quot;</code> is a terminal symbol.</li>
<li><code>DatabaseSym</code>, <code>DBName</code> and <code>DatabaseOptionList</code> are non-terminal symbols that are defined in other grammar rules.</li>
<li>The pseudo-code in brackets is the semantic action. It means an AST node <code>ast.AlterDatabaseStmt</code> will be constructed when the rule is reduced by the parser. Note that a dollar character <code>$</code> followed by a number represents the binding Golang value previously (in other rules), where the number is the index of symbol in rule (1-based). <code>$$</code> represents current binding value. After goyacc substitution, this code snippet will be valid Golang code.</li>
</ul>
<p>Getting back to <code>parser.y</code>, the structure of this file is divided into three parts:</p>
<ol>
<li><code>%union</code> enumerates all the Golang types that can be passed around grammar rules.</li>
<li><code>%token</code> or <code>%type</code> declares the terminal or non-terminal symbols that will be used in grammar rules.</li>
<li>Grammar rules define the syntax of SQL and related semantic actions.</li>
</ol>
<p>Except for <code>parser.y</code>, other sub-package/files should be easy to understand, feel free to explore them by yourself:</p>
<table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody>
<tr><td>ast</td><td>The AST definition used by TiDB.</td></tr>
<tr><td>auth</td><td>Authentication-related functions.</td></tr>
<tr><td>charset</td><td>Currently supported charsets and encodings.</td></tr>
<tr><td>format</td><td>The Formatters for yacc file and the functions for restoring AST to SQL.</td></tr>
<tr><td>goyacc</td><td>The generator for parser.go.</td></tr>
<tr><td>model</td><td>Basic structures in TiDB like TableInfo, ColumnInfo...</td></tr>
<tr><td>mysql</td><td>MySQL constants, errors, privileges, types, and others.</td></tr>
<tr><td>opcode</td><td>Operator code like &lt;, &gt;, +, =...</td></tr>
<tr><td>terror</td><td>The errors used by TiDB.</td></tr>
<tr><td>test_driver</td><td>A parser driver only for unit tests.</td></tr>
<tr><td>tidb</td><td>TiDB related features' keywords.</td></tr>
<tr><td>types</td><td>The field types and evaluation types that used in TiDB.</td></tr>
</tbody></table>
<h2 id="develop-and-build"><a class="header" href="#develop-and-build">Develop and Build</a></h2>
<p>To get started with the parser development, please also take a look at <a href="https://github.com/pingcap/parser/blob/master/docs/quickstart.md">quickstart.md</a>. It shows the basic usage of the parser and it explains some concepts like parser_driver.</p>
<p>Run <code>make parser</code> in the project root directory to generate a new <code>parser.go</code>. If you want to try your new parser patches on TiDB, follow <a href="https://github.com/pingcap/parser/blob/master/docs/update-parser-for-tidb.md">this procedure</a> to have TiDB use your copy of the parser. This allows you to make changes to both the parser and TiDB and test them together.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ol>
<li>How to debug the parsing procedure?</li>
</ol>
<p>Put the test file in the <code>parser</code> package. Set <a href="https://github.com/pingcap/parser/blob/ae8dec26d777272d56288fa4c9d4264ce0d31a03/goyacc/main.go#L525"><code>yyDebug</code></a> level to <code>4</code>(or any integers &gt;= 4) before calling <code>Parse()</code>. The parser will try to show state information in each step.</p>
<ol start="2">
<li>How to resolve shift-reduce or reduce-reduce conflicts?</li>
</ol>
<p>Shift means &quot;move the next token in&quot; to match the current rule. Reduce means &quot;replace current tokens/symbols to a non-terminal symbol&quot;. Shift-reduce conflicts occur when the parser cannot decide the next step is to shift or to reduce.</p>
<p>When yacc reports such conflicts, it also keeps the file <code>y.output</code>. You can search &quot;conflict on&quot; in the file to locate which rule conflicts with other rules. Then you can try to annotate the <code>%precedence</code> to tokens, rewrite the grammar rule, or ask for help on GitHub.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="planner"><a class="header" href="#planner">Planner</a></h1>
<p>The <code>planner</code> package contains most of the codes related to SQL optimization. The input of the planner is an AST of the query returned from the parser, and the output of the planner is a plan tree that would be used for further execution.</p>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<table><thead><tr><th align="left">Package</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/cascades">tidb/planner/cascades</a></td><td align="left">The next generation Cascades model planner, which is under development and disabled by default</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/core">tidb/planner/core</a></td><td align="left">The core logic of the currently used System R model planner. The Cascades model planner also calls utility functions in this package</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/implementation">tidb/planner/implementation</a></td><td align="left">Physical implementations for the operators in Cascades planner</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/memo">tidb/planner/memo</a></td><td align="left">Intermediate results for the searching procedure of Cascades planner</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/property">tidb/planner/property</a></td><td align="left">Properties about the output of operators, including schema, stats, order property, partition property, etc</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/util">tidb/planner/util</a></td><td align="left">Common utility functions / structures shared by the two planners</td></tr>
</tbody></table>
<p>We can see that, TiDB has two planners, one is of System R model, which is defaultly used, and the other is of Cascades model, which is still under development. The unified entry function of planner module is <code>Optimize()</code>, before diving into either of the two planners, it would firstly check if there is any intervention for the planner from the &quot;SQL Plan Management&quot; module, if yes, the AST of the query would be modified before going through the optimization procedures. &quot;SQL Plan Management&quot; module is beyond the scope of this article, and it would be introduced in the <a href="understand-tidb/sql-plan-management.html">SQL Plan Management</a> section.</p>
<p>This article would only focus on introducing the System R planner, i.e, the <code>core</code> package, readers who are interested in the Cascacdes planner can refer to this <a href="https://github.com/pingcap/tidb/tree/master/docs/design/2018-08-29-new-planner.md">design</a> doc.</p>
<h2 id="optimization-procedures"><a class="header" href="#optimization-procedures">Optimization Procedures</a></h2>
<p>Ignore the trivial steps, the query optimization procedures can be briefly divided into 4 phases:</p>
<ol>
<li>build an initial logical plan</li>
<li>logically optimize the initial logical plan</li>
<li>physically optimize the logical plan</li>
<li>tidy up the physical plan</li>
</ol>
<h3 id="plan-building"><a class="header" href="#plan-building">Plan Building</a></h3>
<p>The entry function of this phase is <code>PlanBuilder.Build()</code>, it would translate the input AST to a logical plan tree from bottom up according to the predefined rules / orders. Specifically, it would check each sub-clause of the query, and build a corresponding operator for the clause. The operators are connected as a DAG, which is known as a logical plan tree.</p>
<p>A key step in this phase is translating the expressions for each clause, e.g, <code>where a = 1</code> would have a <code>Selection</code> operator built correspondingly, and an expression <code>eq(a, 1)</code> would be translated and saved in the <code>Selection operator</code>. The expression translation logics are encapsulated in a structure <code>expressionRewriter</code> and its methods. The <code>expressionRewriter</code> would traverse and transalte the AST expressions recursively, and utilize a result stack for intermediate results.</p>
<p><code>expressionRewriter</code> would not only do the simple expression transaltions, but would optimize subqueries in the expressions. The details of subquery optimization would not be explained here, because they are pretty complicated. Briefly speaking, for most of the uncorrelated subqueries, <code>expressionRewriter</code> would directly execute them and substitute them with the result constants. For correlated subqueries, or some of the uncorrelated subqueries, <code>expressionRewriter</code> would build a subtree from them and connect it with the main plan tree using a <code>LogicalJoin</code> or <code>LogicalApply</code> operator. Note that, <code>LogicalApply</code> is a special kind of join operator which can only be executed in a nested-loop approach. <code>LogicalApply</code> operator in some plan trees can be converted to a regular <code>LogicalJoin</code>, which can be executed in other more efficient join algorithms, and planner would do this conversion in the subsequent logical optimization phase if possible.</p>
<p>During the plan building process, optimization flags would be collected for each operator built. For example, if a <code>Selection</code> operator is built, then an optimization flag like <code>flagPredicatePushDown</code> would be set in the plan builder. These saved flags would be used later in the logical optimization phase.</p>
<h3 id="logical-optimization"><a class="header" href="#logical-optimization">Logical Optimization</a></h3>
<p>The entry function of this phase (also known as rule-based optimization) is <code>logicalOptimize()</code>. This function would do logically equivalent transformations for the initial plan tree according to relational algebra, and the result plan tree should be better than the initial one from the execution efficiency perspective in principle. Specifically, <code>logicalOptimize()</code> would traverse all the logical optimization rules predefined as <code>optRuleList</code> in order, and check if a rule is applicable by referring to the optimization flags saved during the plan building phase. If the flag is set for a rule, planner would traverse the plan tree from top down, and apply the transformations implied by the rule to the subtree satisfying the rule prerequisites.</p>
<p>An example logical optimization rule is &quot;column pruning&quot;, for each operator in the plan tree, it would collect the columns needed by the upper operators, and prune the unneeded columns from the output. Another example rule is &quot;decorrelation&quot;, it would try to pull up operators referring correlated columns, and resolve the column dependency, hence convert the <code>LogicalApply</code> operator to a regular <code>LogicalJoin</code>.</p>
<h3 id="physical-optimization"><a class="header" href="#physical-optimization">Physical Optimization</a></h3>
<p>The entry function of this phase (also known as cost-based optimization) is <code>physicalOptimize()</code>, it would do cost based enumeration for the implementations of each logical operator, and find a combination of all operators with the lowest cost as the final physical plan. Specifically, each logical operator would implement an interface function <code>exhaustPhysicalPlans()</code> to list all the possible physical algorithms, e.g, <code>LogicalAggregation</code> would have two possible implementations including <code>PhysicalStreamAggregation</code> and <code>PhysicalHashAggregation</code>. Each implementation may require specific properties for its child's output, e.g, <code>PhysicalStreamAggregation</code> would require that the child's output rows should be in order of the <code>GROUP BY</code> columns. These properties are recorded in <code>PhysicalProperty</code> structure, and passed down to the enumeration procedure of the child operators.</p>
<p>Once the planner knows the specific implementation of the plan tree, or of a subtree, it can compute a cost for this implementation. The cost of one implementation is calculated as a sum of its resource consumptions including CPU, Memory, Network, IO, etc. For each kind of resource specifically, the consumption is measured based on a unit factor (e.g, scanFactor is the unit factor for IO consumption, which means the cost of scanning 1 byte data on TiKV or TiFlash), and the estimated number of rows / bytes to be processed by this operator. Note that, these unit factors can be customized by setting system variables like <code>tidb_opt_xxx_factor</code> to fit clusters of different hardware configurations. Each implementation of the whole logical plan tree would have a cost then, planner would choose the one with the lowest cost for execution.</p>
<p>One thing worth mention is that, TiDB supports pushing some operators down to storage engine to speed up the query execution, e.g, we can push <code>Selection</code> operator down to the coprocessor of TiKV, and reduce the rows returned from TiKV to TiDB through the network. The logic about deciding whether to push operators down to storage engine or not is piggybacked on the search framework of the physical optimization. Specifically, it is achieved by introducing <code>TaskType</code> field into <code>PhysicalProperty</code>, for example, once the planner wants to push down a <code>Limit</code> operator to TiKV, it would enumerate an implementation <code>PhysicalLimit</code> which has <code>CopXXXTaskType</code> as the <code>TaskType</code> of the required <code>PhysicalProperty</code> for its child. Once the child of <code>PhysicalLimit</code> has generated a TiKV implementation, these two plan snippets would be concatenated in <code>attach2Task()</code> interface, hence achieving the operator pushdown for storage engine.</p>
<h3 id="post-optimization"><a class="header" href="#post-optimization">Post Optimization</a></h3>
<p>The entry function of this phase is <code>postOptimize()</code>. The query optimization has almost finished when coming here, this phase would not apply big changes to the plan, it would only do some clean and tidy up works. The jobs in this phase include a new round of projection elimination(the first round is applied in logical optimization), and projection injection to simplify the code implementations of executor package, and so on.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This section talks about the brief steps of query optimization, and the corresponding entry functions for each step.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="table-statistics"><a class="header" href="#table-statistics">Table Statistics</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-based-optimization"><a class="header" href="#rule-based-optimization">Rule-based Optimization</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cost-based-optimization"><a class="header" href="#cost-based-optimization">Cost-based Optimization</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plan-cache"><a class="header" href="#plan-cache">Plan Cache</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sql-plan-management"><a class="header" href="#sql-plan-management">SQL Plan Management</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="execution"><a class="header" href="#execution">Execution</a></h1>
<p>The <code>executor</code> package contains most of the codes related to execution. The input of the executor is a plan tree of the query returned from the planner, and the output of the executor is the result of the query. The entry function of execution module is <code>executorBuild::build</code>, the output result is fetched in <code>clientConn::writeChunks</code>.</p>
<h2 id="execution-framework"><a class="header" href="#execution-framework">Execution Framework</a></h2>
<p>TiDB builds the computing engine based on the distributed storage provided by TiKV. The TiKV server implements a coprocessor framework to support distributed computing. The computing operations will be pushed to the TiKV coprocessor as far as possible to accelerate the computation speed. That is to say, a sub-plan of the SQL execution plan will be executed in parallel on different TiKV servers, and the result of each sub-plan will be collected to a TiDB server to compute for the final result.</p>
<p>The processing model of the execution plan tree is known as the Volcano iterator model. The essential of the Volcano model is abstracted to 3 interfaces: <code>Open</code>, <code>Next</code>, and <code>Close</code>. All operators offer the same interfaces and the implementation is opaque.</p>
<p><code>Open</code> will be invoked in turn for each operator to init the needed resources before computing. Conversely, <code>Close</code> will release the resources. To obtain the query output, the final operator in the plan tree will keep invoking <code>Next</code> until no tuple is pulled from its child.</p>
<p>It's easy to understand how the Volcano model works for single-process execution. For parallelism issues, the Volcano introduces an operator called <code>Exchange</code> at any desired point in a plan tree. Further explanation about the parallelism-related issues would be introduced in the <a href="understand-tidb/parallel-execution-framework.html">Parallel Execution Framework</a> section.</p>
<h2 id="vectorized-execution"><a class="header" href="#vectorized-execution">Vectorized Execution</a></h2>
<p>Vectorization uses the Volcano iteration model where each operator has a <code>Next</code> method that produces result tuples. However, each <code>Next</code> call fetches a block of tuples instead of just one tuple.</p>
<p>The main principle of vectorized execution is batched execution on a columnar data representation: every &quot;work&quot; primitive function that manipulates data does not work on a single data item, but on a vector (an array) of such data items that represents multiple tuples. The idea behind vectorized execution is to amortize the iterator call overhead by performing as much as possible inside the data manipulation methods. For example, this work can be to hash 1000s of values, compare 1000s of string pairs, update a 1000 aggregates, or fetch a 1000 values from 1000s of addresses.</p>
<p>Columnar Different from the row-oriented data representation, columnar format organize data by column rather by row. By storing data in columns rather than rows, the database can more precisely access the data it needs to answer a query rather than scanning and discarding unwanted data in rows. The memory columnar data representation in TiDB is defined as <code>Chunk</code>, which is inspired by <a href="https://arrow.apache.org/">Apache Arrow</a>.</p>
<p>The detailed definition and usage of <code>Chunk</code> will be introduced in the <a href="understand-tidb/implementation-of-vectorized-execution.html">Implementation of Vectorized Execution</a> section.</p>
<h2 id="memory-management-mechanism"><a class="header" href="#memory-management-mechanism">Memory Management Mechanism</a></h2>
<p>In TiDB, we set a memory usage quota for a query, and introduce two interfaces called <code>Tracker</code> and <code>OOMAction</code> for memory management.</p>
<p>The <code>Tracker</code> is used to track the memory usage of each element. The <code>OOMAction</code> is used to abstract the strategies to be used when the memory usage of a SQL exceeds the memory quota.</p>
<p>For example, we define the spill to disk strategy as <code>SpillDiskAction</code>. <code>SpillDiskAction</code> might be triggered by <code>HashJoin</code> or <code>Sort</code> when the memory quota is exceeded. If a query requires an order guarantee, and there is no index to guarantee the order, then the execution must sort the input before proceeding. If the input is small then the sort occurs in memory. We can split the input into multiple partitions and perform a merge sort on them. If the input is large, the <code>SpillDiskAction</code> will be triggered, an external sort algorithm is used. External sorting algorithms generally fall into two ways, sorting and merge. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined, and the final result will be outputted.</p>
<p>For more details, you can refers to the <a href="understand-tidb/memory-management-mechanism.html">Memory Management Mechanism</a> section.</p>
<h2 id="typical-operators"><a class="header" href="#typical-operators">Typical Operators</a></h2>
<p>TiDB implements multiple algorithms for the Join, Aggregation, Sort operators, and so on. We'll take some of them for detailed introduction. If you are interested, you can refer to the <a href="understand-tidb/implementation-of-typical-operators.html">Implementation of Typical Operators</a> section.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parallel-execution-framework"><a class="header" href="#parallel-execution-framework">Parallel Execution Framework</a></h1>
<p>In order to make full use of the multi-core ability of modern hardware, most popular DBMS have implemented the ability of parallel execution SQL execution engine.</p>
<p>There are three common parallel implementations: Intra operator parallelism, Exchange operator, and Morsel-Driven parallelism. And TiDB adopts the first approach.</p>
<h2 id="tidb-implementation"><a class="header" href="#tidb-implementation">TiDB Implementation</a></h2>
<p>In intra-operator parallelism, multiple goroutines will be created inside the operator for parallel processing. The creation, termination and synchronization of the goroutines are handled by the operator itself.</p>
<p>Most operators will create multiple goroutines in <code>Open()</code> or the first call of <code>Next()</code>. And they will wait on channels for input Chunk. Also, a special channel is responsible for notifying whether to stop the computation. And <code>WaitGroup</code> can be used to wait for the termination of all goroutines. This usually happens when <code>Close()</code> is called.</p>
<p>Taking HashJoin as an example, all workers will be started at the first call of <code>Next()</code>, including:</p>
<ol>
<li>buildSideFetcher: Will call <code>buildSideExec.Next()</code> to fetch input Chunk.</li>
<li>builderWorker: Receive data from the buildSideFetcher and build the HashTable.</li>
<li>probeSideFetcher: Wait for the end of building of the HashTable and call <code>probeSideExec.Next()</code> to fetch input Chunk.</li>
<li>probeWorker: Receive data from the probeSideFetcher and then probe the HashTable.</li>
</ol>
<p>When the main goroutine calls <code>HashJoinExec.Next()</code>, it will read data from the result channel and send an empty Chunk to the resource channel. When <code>HashJoinExec.Close()</code> is called, a special channel will be closed and all workers waiting on the channel will exit.</p>
<p>The parallel implementations of operators are various. For example, HashAgg is divided into two stages. Each stage will start multiple goroutines (partialWorkers and finalWorkers).</p>
<p>It is worth noting that we still use the traditional Volcano-model, the <code>Next()</code> is only called by a single thread. The parallelism only occurs in the internal processing of the operator.</p>
<p>The degree of parallelism (DOP) can be controlled by the session variable. For example, <code>tidb_executor_concurrency</code> is 5 by default. It means HashJoin will create five goroutines to probe HashTable. You can also control the parallelism of a specific operator by changing the session variable, such as <code>tidb_hash_join_concurrency</code>.</p>
<p>At present, most important operators have implemented intra-operator parallelism:</p>
<ol>
<li>Join: HashJoin, IndexJoin, IndexHashJoin, IndexMergeJoin</li>
<li>Apply: ParallelApply</li>
<li>Aggregation: HashAgg</li>
<li>Other: Union, Projection</li>
<li>Reader: TableReader, IndexReader</li>
</ol>
<p>Other operators are still single threaded: TopN, Limit, Sort, MergeJoin, StreamAgg, Selection, WindowFunc. But some of them (TopN, Limit, StreamAgg, Selection) can be pushed down to TiKV.</p>
<h2 id="other-parallelism-implementation"><a class="header" href="#other-parallelism-implementation">Other Parallelism Implementation</a></h2>
<p>Intra operator parallelism is the most intuitive way to implement parallelism, but its implementation is complex, because every operator needs to implement parallelism independently. What's worse, too many threads will increase the scheduling overhead. Although, the use of goroutines can alleviate this problem.</p>
<p>A more traditional way to implement parallelism is to use the exchange operator. By encapsulating the parallel logic into the exchange operator, all other operators only need to consider the single thread implementation.</p>
<p>The exchange operator is responsible for data exchange between different threads. The internal implementation of exchange is divided into two parts: sender and receiver. And data is transferred from sender to receiver in different ways, such as hash partition, random distribution or sort merge.</p>
<p>There are usually two ways to control DOP:</p>
<ol>
<li>Users can use hints to specify DOP explicitly.</li>
<li>The optimizer can choose DOP according to the table size of the scan operation automatically.</li>
</ol>
<p>This approach requires the optimizer to generate parallel plans. Generally, plan generation is divided into two stages. The first stage generates serial plans, and the second stage generates its corresponding parallel plans. The second stage is mainly responsible for inserting the exchange operator into the plan tree at the appropriate position. Both heuristic rules and cost model can be used to get the optimal parallel plan.</p>
<p>Currently, TiDB has a simplified implementation of exchange operator: <code>Shuffle Operator</code>. It can make MergeJoin, StreamAgg and WindowFunc run in parallel. And you can enable MergeJoin to be parallel by setting <code>tidb_merge_join_concurrency</code> be greater than 1.</p>
<p>For Morsel-Driven, it implements parallelism by dividing data into fixed size blocks (Morsel: usually 100000 rows). And a customized scheduler will be responsible for task scheduling to achieve better load balancing. And TiDB doesn't use this approach for now.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation-of-vectorized-execution"><a class="header" href="#implementation-of-vectorized-execution">Implementation of Vectorized Execution</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-mechanism-1"><a class="header" href="#memory-management-mechanism-1">Memory Management Mechanism</a></h1>
<p>TiDB's memory management basically consists of a memory usage quota settings for each query, and two interfaces, called <code>Tracker</code> and <code>OOMAction</code>.</p>
<h2 id="tracker"><a class="header" href="#tracker">Tracker</a></h2>
<p><code>Tracker</code> tracks the memory usage of each element with a tree structure.</p>
<p>Genral use cases:</p>
<pre><code class="language-text">                                               /--- Tracker(Component in Executor, e.g. list/rowContainer/worker)
                                               |           ...
                    /--- Tracker(Executor1) ---+--- Tracker(Component)
                    |
Tracker(Session) ---+--- Tracker(Executor2)
      |             |         ...
      |             \--- Tracker(Executor3)
 OOM-Action1
      |
      |
 OOM-Action2
     ...
</code></pre>
<p>When a component allocates some memory, it will call the function <code>Tracker.Consume(bytes)</code> to tell the <code>Tracker</code> how much memory it uses. <code>Tracker.Comsume</code> will traverse all its ancestor nodes, accumulate memory usage and trigger OOM-Action when exceeded.</p>
<h2 id="oom-action"><a class="header" href="#oom-action">OOM-Action</a></h2>
<p><code>OOM-Action</code> is a series of actions grouped in a linked list to reduce memory usage. Each node on the linked list abstracts a strategy to be used when the memory usage of a SQL exceeds the memory quota. For example, we define the spill to disk strategy as <code>SpillDiskAction</code>, rate limit strategy as <code>rateLimitAction</code> and cancel strategy as <code>PanicOnExceed</code>.</p>
<h3 id="rate-limit"><a class="header" href="#rate-limit">Rate Limit</a></h3>
<p>TiDB supports dynamic memory control for the operator that reads data. By default, this operator uses the maximum number of threads that <code>tidb_disql_scan_concurrency</code> allows to read data. When the memory usage of a single SQL execution exceeds <code>tidb_mem_quota_query</code> each time, the operator that reads data stops one thread.</p>
<p>We use <code>rateLimitAction</code> to dynamically control the data reading speed of <code>TableReader</code>.</p>
<h3 id="spill-disk"><a class="header" href="#spill-disk">Spill Disk</a></h3>
<p>TiDB supports disk spill for execution operators. When the memory usage of a SQL execution exceeds the memory quota, tidb-server can spill the intermediate data of execution operators to the disk to relieve memory pressure. Operators supporting disk spill include Sort, MergeJoin, HashJoin, and HashAgg.</p>
<h4 id="spilldiskaction"><a class="header" href="#spilldiskaction">SpillDiskAction</a></h4>
<p>We use <code>SpillDiskAction</code> to control the spill disk of <code>HashJoin</code> and <code>MergeJoin</code>. The data will be placed in Chunk unit when spilling. We can get any data in Chunk through random I/O.</p>
<h4 id="sortandspilldiskaction"><a class="header" href="#sortandspilldiskaction">SortAndSpillDiskAction</a></h4>
<p>We use <code>SortAndSpillDiskAction</code> to control the spill disk of <code>Sort</code>.</p>
<p>If the input of <code>SortExec</code> is small, then it sorts in memory. If the input is large, the <code>SortAndSpillDiskAction</code> will be triggered, and an external sort algorithm will be used. We can split the input into multiple partitions and perform a merge sort on them.</p>
<p>External sorting algorithms generally have two stages, sort and merge. In the sort stage, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge stage, the sorted subfiles are combined, and the final result will be outputted.</p>
<h4 id="aggspilldiskaction"><a class="header" href="#aggspilldiskaction">AggSpillDiskAction</a></h4>
<p>We use <code>AggSpillDiskAction</code> to control the spill disk of <code>HashAgg</code>. When <code>AggSpillDiskAction</code> is triggered, it will switch HashAgg executor to spill-mode, and the memory usage of HashAgg won't grow.</p>
<p>We use the following algorithm to control the memory increasing:</p>
<ol>
<li>When the memory usage is higher than the <code>mem-quota-query</code>, switch the HashAgg executor to spill-mode.</li>
<li>When HashAgg is in spill-mode, keep the tuple in the hash map no longer growing.
a. If the processing key exists in the Map, aggregate the result.
b. If the processing key doesn't exist in the Map, spill the data to disk.</li>
<li>After all data have been processed, output the aggregate result in the map, clear the map. Then read the spilling data from disk, repeat the Step1-Step3 until all data gets aggregated.</li>
</ol>
<p>As we can see, unlike other spilling implementations, <code>AggSpillDiskAction</code> does not make the memory drop immediately, but keeps the memory no longer growing. </p>
<h3 id="logcancel"><a class="header" href="#logcancel">Log/Cancel</a></h3>
<p>When the above methods cannot control the memory within the threshold, we will try to use <code>PanicOnExceed</code> to cancel the SQL or use <code>LogOnExceed</code> to log the SQL info.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation-of-typical-operators"><a class="header" href="#implementation-of-typical-operators">Implementation of Typical Operators</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<p>The transaction engine in TiDB is responsible to provide ACID guarantees for all the read and write requests. It consists of the client/coordinator part in the TiDB repository and the server/participant part in the TiKV repository. </p>
<p>This document is mainly about the TiDB part.</p>
<h2 id="the-architecture"><a class="header" href="#the-architecture">The Architecture</a></h2>
<p>In TiDB the transaction write flow is like this:</p>
<p><img src="understand-tidb/../img/transaction-architecture.png" alt="transaction-architecture" /></p>
<p>After the transaction starts in a session, all the reads and writes will use a snapshot to fetch data, and the written content will be buffered in the memory of the transaction. When the <code>commit</code> statement is received from the client, the Percolator protocol will be used to commit these changes to the storage system.</p>
<h2 id="the-interface"><a class="header" href="#the-interface">The Interface</a></h2>
<p>In TiDB, the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/kv/kv.go#L181-L234"><code>Transaction</code></a> interface defines the commonly used transaction operations.</p>
<pre><code class="language-go">type Transaction interface {
	// Commit commits the transaction operations to KV store.
	Commit(context.Context) error
	// Rollback undoes the transaction operations to KV store.
	Rollback() error
	// LockKeys tries to lock the entries with the keys in KV store.
	// Will block until all keys are locked successfully or an error occurs.
	LockKeys(ctx context.Context, lockCtx *LockCtx, keys ...Key) error
	// SetOption sets an option with a value, when val is nil, uses the default
	// value of this option.
	SetOption(opt int, val interface{})
	// GetOption returns the option
	GetOption(opt int) interface{}
	...
	// StartTS returns the transaction start timestamp.
	StartTS() uint64
	// Valid returns if the transaction is valid.
	// A transaction become invalid after commit or rollback.
	Valid() bool
	// GetMemBuffer return the MemBuffer binding to this transaction.
	GetMemBuffer() MemBuffer
	// GetSnapshot returns the Snapshot binding to this transaction.
	GetSnapshot() Snapshot
}
</code></pre>
<p>These are common interfaces the transaction will provide.</p>
<p>For example, <code>Commit</code> will be used to commit the current ongoing transaction. The transaction is considered ongoing before the <code>Commit</code> operation is triggered. The two-phase commit processing will be used to commit a transaction and it will finally become committed or aborted. </p>
<p><a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/session/txn.go#L50-L71"><code>LazyTxn</code></a> is a wrapper of the transaction implementations, when the SQL statements are executed using a standalone session context, <code>LazyTxn</code> will be used to do things likeï¼š</p>
<ul>
<li>Return the memory buffer for write.</li>
<li>Set specific operations or flags for the current transaction.</li>
<li>Return the snapshot of this transaction.</li>
<li>Commit the current transaction.</li>
<li>Lock specific keys.</li>
</ul>
<h2 id="the-statement-execution"><a class="header" href="#the-statement-execution">The Statement Execution</a></h2>
<p>Usually, the first thing that will be done executing a statement is to <code>activate</code> the related transaction</p>
<p>By default, TiDB provides the snapshot isolation level. Thus, in each new transaction, a new global strong snapshot will be fetched first, before executing statements.</p>
<p>In TiDB, the snapshot is represented by a global TSO which is fetched from the PD server, and it acts as the unique identifier for this transaction. After this operation, a transaction is regarded as <code>activated</code>.</p>
<p>For the read SQL statements, the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/snapshot.go">snapshot</a> will be used to provide a global strong consistent snapshot, all the reads will check data visibility using this snapshot. Most executors will set the timestamp doing the build, and the transaction could be activated by the building process. Some commonly used <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/snapshot.go#L40">snapshot</a> APIs are as below:</p>
<pre><code class="language-go">// BatchGet gets all the keys' value from kv-server and returns a map contains key/value pairs.
// The map will not contain nonexistent keys.
func (s *tikvSnapshot) BatchGet(ctx context.Context, keys []kv.Key) (map[string][]byte, error) {
	data, err := s.KVSnapshot.BatchGet(ctx, toTiKVKeys(keys))
	return data, extractKeyErr(err)
}

// Get gets the value for key k from snapshot.
func (s *tikvSnapshot) Get(ctx context.Context, k kv.Key) ([]byte, error) {
	data, err := s.KVSnapshot.Get(ctx, k)
	return data, extractKeyErr(err)
}
</code></pre>
<p>For the write SQL statements, they will write data into the transaction memory buffer temporarily until the <code>commit</code> operation is triggered. There are 3 main interfaces which will write query data into the memory buffer. Here is the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/table/table.go#L166">table</a> API:</p>
<pre><code class="language-go">// Table is used to retrieve and modify rows in table.
type Table interface {
	// AddRecord inserts a row which should contain only public columns
	AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...AddRecordOption) (recordID kv.Handle, err error)

	// UpdateRecord updates a row which should contain only writable columns.
	UpdateRecord(ctx context.Context, sctx sessionctx.Context, h kv.Handle, currData, newData []types.Datum, touched []bool) error

	// RemoveRecord removes a row in the table.
	RemoveRecord(ctx sessionctx.Context, h kv.Handle, r []types.Datum) error
}
</code></pre>
<p>Every statement will use a <code>staging</code> buffer during its execution. If it's successful, the staging content will be merged into the transaction memory buffer.</p>
<p>For example, <code>AddRecord</code> will try to write a row into the current statement staging buffer, and the <code>RemoveRecord</code> will try to remove a row from the staging statement buffer. The existing transaction memory buffer will not be affected if the statement has failed.</p>
<p>The memory buffer implementation is wrapped in <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/unionstore_driver.go#L27-L29">memBuffer</a>. The internal implementation is <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/internal/unionstore/memdb.go"><code>MemDB</code> struct</a>.</p>
<p>The memory buffer is an ordered map and it provides the <code>staging</code> and <code>discard</code> utilities. For example, the memory content generated by a statement will be discarded if its execution has failed.</p>
<h2 id="the-two-phase-commit"><a class="header" href="#the-two-phase-commit">The Two-phase Commit</a></h2>
<p>After the statement execution phase, the <code>commit</code> statement will trigger the commit execution for the current transaction. In TiDB, the Percolator protocol is used as the distributed transaction protocol, it's a two-phase protocol.</p>
<p>In the first stage, the transaction coordinator (TiDB server) will try to prewrite all the related keys. If all of them are successful, the transaction coordinator will then commit the primary key. After that the transaction is considered committed successfully, and a success message will be responded to the client. All the other keys will be committed asynchronously.</p>
<p>All the changes in the transaction memory buffer will be converted into <a href="https://github.com/pingcap/kvproto/blob/dc1709169bb155de3bea6b28c871215387942994/proto/kvrpcpb.proto#L882">mutations</a> which will be used by the two-phase committer. These mutations will be grouped by their region locations, and prewrite requests will be sent to their region leaders.</p>
<p>If all the prewrite requests are processed successfully, the commit request for the primary key will be sent to TiKV first. If the primary key commit is successful, the transaction is considered committed and will respond to the client with successful results.</p>
<h2 id="recommended-reading"><a class="header" href="#recommended-reading">Recommended Reading</a></h2>
<ul>
<li><a href="https://tikv.org/deep-dive/distributed-transaction/percolator/">Percolator</a></li>
<li><a href="https://research.google/pubs/pub36726/">Large-scale Incremental Processing Using Distributed Transactions and Notifications</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction-on-tikv"><a class="header" href="#transaction-on-tikv">Transaction on TiKV</a></h1>
<p><a href="understand-tidb/transaction.html">The previous section</a> introduces the architecture of the transaction engine and several implementation details in TiDB part. This document is mainly about the TiKV part.</p>
<p>As described in the previous section, the distributed transaction coordinator is <code>tidb-server</code> which receives and processes <code>COMMIT</code> query, and the transaction participants involved are <code>tikv-server</code>s.</p>
<h1 id="transactional-protocol"><a class="header" href="#transactional-protocol">Transactional Protocol</a></h1>
<p>The RPC interfaces in TiDB are defined in <a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L77">a protobuf file</a>, based on the Percolator model.</p>
<p>These interfaces will be used by the transaction coordinator to drive the whole commit process. For example <code>Prewrite</code> will be used to write the lock record in TiKV:</p>
<pre><code class="language-proto">message PrewriteRequest {
    Context context = 1;
    // The data to be written to the database.
    repeated Mutation mutations = 2;
    // The client picks one key to be primary (unrelated to the primary key concept in SQL). This
    // key's lock is the source of truth for the state of a transaction. All other locks due to a
    // transaction will point to the primary lock.
    bytes primary_lock = 3;
    // Identifies the transaction being written.
    uint64 start_version = 4;
    uint64 lock_ttl = 5;
    // TiKV can skip some checks, used for speeding up data migration.
    bool skip_constraint_check = 6;
    // For pessimistic transaction, some mutations don't need to be locked, for example, non-unique index key.
    repeated bool is_pessimistic_lock = 7;
    // How many keys this transaction involves in this region.
    uint64 txn_size = 8;
    // For pessimistic transactions only; used to check if a conflict lock is already committed.
    uint64 for_update_ts = 9;
    // If min_commit_ts &gt; 0, this is a large transaction request, the final commit_ts
    // will be inferred from `min_commit_ts`.
    uint64 min_commit_ts = 10;
    // When async commit is enabled, `secondaries` should be set as the key list of all secondary
    // locks if the request prewrites the primary lock.
    bool use_async_commit = 11;
    repeated bytes secondaries = 12;
    // When the transaction involves only one region, it's possible to commit the transaction
    // directly with 1PC protocol.
    bool try_one_pc = 13;
    // The max commit ts is reserved for limiting the commit ts of 1PC or async commit, which can be used to avoid
    // inconsistency with schema change.
    uint64 max_commit_ts = 14;
}
</code></pre>
<ul>
<li><code>mutations</code> are changes made by the transaction.</li>
<li><code>start_version</code> is the transaction identifier fetched from PD.</li>
<li><code>for_update_ts</code> is used by the pessimistic transactions.</li>
<li><code>try_one_pc</code> field is used if the transaction is committed using <code>one-phase</code> protocol.</li>
<li><code>use_async_commit</code> and <code>secondaries</code> will be used if the transaction is committed in the <code>async-commit</code> mode.</li>
</ul>
<p>Besides <code>prewrite</code> request, there are some other important request types:</p>
<ul>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L125"><code>pessimistic_lock</code> request</a> is used to lock a key. Note pessimistic locking happens in the transaction execution phase, for example a <code>select for update</code> statement will need to pessimistically lock the corresponding rows.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L268"><code>commit</code> request</a> is used to commit a key. After commit the write content is visible to other read or write transactions.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/master/proto/kvrpcpb.proto#L206"><code>check_txn_status</code> request</a> will be used to check the status of a given transaction, so that it could be decided how to process the conflicts.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L374"><code>resolve</code> request</a> will be used to help doing the transaction crash recovery.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/master/proto/kvrpcpb.proto#L247"><code>check_secondary_locks</code> request</a> is a special API, it will be used if the commit mode of the transaction is <code>async-commit</code>.</li>
</ul>
<h1 id="transaction-scheduler"><a class="header" href="#transaction-scheduler">Transaction Scheduler</a></h1>
<p><img src="understand-tidb/../img/transaction_scheduler.png" alt="transaction-scheduler" /></p>
<p>The receiving input transaction requests will be translated into transaction <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/commands/mod.rs#L114">commands</a>. Then the transaction <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/scheduler.rs#L286">scheduler</a> will handle these transaction commands, it will first try to fetch the needed key <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/latch.rs#L22">latches</a> (latch is used to sequence all the transaction commands on the same key)ï¼Œthen try to fetch a storage <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/components/tikv_kv/src/lib.rs#L191">snapshot</a> for the current transaction processing.</p>
<p>The task will be processed as a <a href="https://doc.rust-lang.org/stable/std/future/trait.Future.html">future</a>. The future processing is done in the transaction scheduler thread-pool. Usually, there will be some tasks like conflict and constraint checks, write mutation generations. For example, the prewrite request processing will need to check if there is already a conflict <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/actions/prewrite.rs#L45">lock</a> or a conflict committed write <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/actions/prewrite.rs#L59">record</a>.</p>
<h1 id="transaction-log-replication"><a class="header" href="#transaction-log-replication">Transaction Log Replication</a></h1>
<p>In TiDB, the key space is split into different ranges or regions. Each region is a raft group and its leader will be responsible for handling its key range related read/write requests. </p>
<p>If the transaction command processing in the transaction scheduler is successful, the generated transaction writes will be written into the raft log engine by the region leaders in <code>raftStore</code> (raft store will be introduced in other documents in details). The work flow is like this:</p>
<p><img src="understand-tidb/../img/raftStore.png" alt="RaftStore" /></p>
<p>The writes generated by transaction commands will be sent to the raft peer message task queue first, then the raft batch system will poll each raft peer and handle these requests in the raft thread-pool. After all the raft logs are persisted on majority raft group members, they are regarded as <code>commit</code>. Then the correspond apply task be delivered to the apply worker pool to apply the actual write contents to the storage engine, after that the transaction command processing is considered successful and the callback will be invoked to response <code>OK</code> results to the RPC client.</p>
<h1 id="transaction-record-in-tikv"><a class="header" href="#transaction-record-in-tikv">Transaction Record In TiKV</a></h1>
<p>In TiDB, a transaction is considered committed only if its primary key lock is committed successfully (if async commit protocol is not used). The actual key and value written into storage engine is in the following format:</p>
<table><thead><tr><th>CF</th><th align="left">RocksDB Key</th><th>RocksDB Value</th></tr></thead><tbody>
<tr><td>Lock</td><td align="left">user_key</td><td>lock_info</td></tr>
<tr><td>Default</td><td align="left">{user_key}{start_ts}</td><td>user_value</td></tr>
<tr><td>Write</td><td align="left">{user_key}{commit_ts}</td><td>write_info</td></tr>
</tbody></table>
<p>After <code>prewrite</code>, the lock correspond records for the transaction will be written into the storage. Read and write conflicts on the &quot;locked&quot; key will need to consider if it's safe to bypass the lock or it must try to resolve the encountered locks. As <code>commit_ts</code> is part of the stored key, there could be different historical versions for it, and GC is responsible to clean up all the old versions which will not be needed any more. GC mechanism will be introduced in another document.</p>
<h1 id="transaction-recovery"><a class="header" href="#transaction-recovery">Transaction Recovery</a></h1>
<p>In TiDB, the transaction coordinator (in <code>tidb-server</code>) is stateless and it will not persist any information. If the transaction coordinator fails for example the <code>tidb-server</code> crashes, the transaction context in memory will get lost, and as the coordinator is gone the normal commit processing will stop. How to recover the transaction state and make a decision if it should commit or abort? </p>
<p>Actually, there is no special mechanism to recover the undetermined-status transactions, the recovery is done by other concurrent conflict transactions, or the conflict transactions will help decide the actual states of the undetermined-status transactions. The lock resolve process will be triggered if the current ongoing transaction encounters locks of other transactions doing reads or writes. The whole resolve process will be introduced in other documents in details.</p>
<h1 id="transaction-optimizations"><a class="header" href="#transaction-optimizations">Transaction Optimizations</a></h1>
<p>Normally the transaction commit will need two phases, the <code>prewrite</code> phase and <code>commit</code> phase. Under certain circumstances transaction commit could be done in a single phase for example the generated transaction mutations could be processed by a single region leader. This optimization is called one-phase commit in TiDB.</p>
<p>The final transaction status is determined by the commit status of the primary key lock, so the response to the client has to wait until the primary key commit has finished. This wait could be saved using the <code>async-commit</code> protocol so the latency of commit processing could be reduced.</p>
<p>They will both be introduced other documents in details.</p>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>This section talks about the brief steps of transaction processing in the TiKV part, and related interfaces, implementations and optimizations.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="optimistic-transaction"><a class="header" href="#optimistic-transaction">Optimistic Transaction</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lock-resolver"><a class="header" href="#lock-resolver">Lock Resolver</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pessimistic-transaction"><a class="header" href="#pessimistic-transaction">Pessimistic Transaction</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="async-commit"><a class="header" href="#async-commit">Async Commit</a></h1>
<p>Async commit is an optimization of two phase commit introduced in TiDB 5.0. The optimization greatly reduces the latency of the two phase commit process.</p>
<p>This document talks about the implementation of async commit in TiDB. It is recommended that you have learned about the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theories of async commit</a> first.</p>
<p>This document refers to the code of <a href="https://github.com/pingcap/tidb/tree/v5.2.1">TiDB v5.2.1</a>, the corresponding <a href="https://github.com/tikv/client-go/tree/daddf73a0706d78c9e980c91c97cc9ed100f1919">client-go</a> and <a href="https://github.com/tikv/tikv/tree/v5.2.1">TiKV v5.2.1</a>.</p>
<h2 id="tidb-part"><a class="header" href="#tidb-part">TiDB part</a></h2>
<h3 id="preparations"><a class="header" href="#preparations">Preparations</a></h3>
<p>Async commit does not change the behavior during transaction execution. The changes begin from <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1112">2PC execution</a>.</p>
<p>Because we need to record the key list in the primary lock, it is not suitable to use the async commit protocol for large transactions. And binlog does not support async commit, so we disable async commit if binlog is enabled. These checks can be found <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L999">here</a>.</p>
<p>And in the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theory blog</a>, we proves that using a latest timestamp from PD can guarantee linearizability. You can find the code <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1191">here</a>. Actually, it is not always necessary to get this timestamp, the comment <a href="https://github.com/pingcap/tidb/blob/v5.2.1/session/session.go#L559">here</a> explains it:</p>
<pre><code class="language-go">// priority of the sysvar is lower than `start transaction with causal consistency only`
if val := s.txn.GetOption(kv.GuaranteeLinearizability); val == nil || val.(bool) {
    // We needn't ask the TiKV client to guarantee linearizability for auto-commit transactions
    // because the property is naturally holds:
    // We guarantee the commitTS of any transaction must not exceed the next timestamp from the TSO.
    // An auto-commit transaction fetches its startTS from the TSO so its commitTS &gt; its startTS &gt; the commitTS
    // of any previously committed transactions.
    s.txn.SetOption(kv.GuaranteeLinearizability,
                    sessVars.TxnCtx.IsExplicit &amp;&amp; sessVars.GuaranteeLinearizability)
}
</code></pre>
<p>Later, we also calculate a <code>maxCommitTS</code>. This will be discussed later in the DDL compatibility part.</p>
<h3 id="prewrite"><a class="header" href="#prewrite">Prewrite</a></h3>
<p>If we decide to use async commit, we need to provide some <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L131">extra information</a> to enable the async commit protocol, the <code>UseAsyncCommit</code> flag and the secondary keys:</p>
<pre><code class="language-go">req := &amp;kvrpcpb.PrewriteRequest{/* ommitted */}
if c.isAsyncCommit() {
    if batch.isPrimary {
        req.Secondaries = c.asyncSecondaries()
    }
    req.UseAsyncCommit = true
}
</code></pre>
<p>If the <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L292">prewriting succeeds</a>, there are two cases.</p>
<p>If TiKV cannot proceed the async-commit protocol successfully, (probably because the calculated commit TS exceeds <code>maxCommitTS</code>), we fallback to the traditional percolator protocol. Otherwise, the prewrite request succeeds, so we can update the global <code>MinCommitTS</code>.</p>
<pre><code class="language-go">// 0 if the min_commit_ts is not ready or any other reason that async
// commit cannot proceed. The client can then fallback to normal way to
// continue committing the transaction if prewrite are all finished.
if prewriteResp.MinCommitTs == 0 {
    c.setAsyncCommit(false)
} else {
    c.mu.Lock()
    if prewriteResp.MinCommitTs &gt; c.minCommitTS {
        c.minCommitTS = prewriteResp.MinCommitTs
    }
    c.mu.Unlock()
}
</code></pre>
<p>However, if any response of prewrite is finally lost due to RPC reasons, it is impossible for us to know whether the prewriting succeeds. And it also means we cannot know whether the transaction succeeds. In this case, we can only <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L187">return an &quot;undetermined error&quot;</a> and the client connection will be closed:</p>
<pre><code class="language-go">defer func() {
    if err != nil {
        // If we fail to receive response for async commit prewrite, it will be undetermined whether this
        // transaction has been successfully committed.
        // If prewrite has been cancelled, all ongoing prewrite RPCs will become errors, we needn't set undetermined
        // errors.
        if (c.isAsyncCommit() || c.isOnePC()) &amp;&amp; sender.GetRPCError() != nil &amp;&amp; atomic.LoadUint32(&amp;c.prewriteCancelled) == 0 {
            c.setUndeterminedErr(errors.Trace(sender.GetRPCError()))
        }
    }
}()
</code></pre>
<p>But don't worry, this does not happen very often. It is safe to retry a prewrite which temporarily fails due to network reasons. The above problem only happens if a prewrite request has been sent, but later retries all fail due to RPC errors.</p>
<h3 id="commit"><a class="header" href="#commit">Commit</a></h3>
<p>The whole commit process is <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1370">done asynchronously in background</a>. This is why the optimization is called &quot;async commit&quot;:</p>
<pre><code class="language-go">if c.isAsyncCommit() {
    // For async commit protocol, the commit is considered success here.
    c.txn.commitTS = c.commitTS
    go func() {
        commitBo := retry.NewBackofferWithVars(c.store.Ctx(), CommitSecondaryMaxBackoff, c.txn.vars)
        c.commitMutations(commitBo, c.mutations)
    }()
    return nil
}
</code></pre>
<p>It does not matter even if some temporary error happens in the commit process. Anyone who encounters these uncommitted async-commit locks is able to finally commit them. Next, we will talk about this.</p>
<h3 id="transaction-recovery-1"><a class="header" href="#transaction-recovery-1">Transaction recovery</a></h3>
<p>If a reader encounters an expired async-commit lock, it needs to resolve this lock.</p>
<p>As usual, the primary lock is checked first to get the transaction information. If it is using the async-commit protocol, the primary lock is never cleaned in <code>CheckTxnStatus</code>. Then we call the <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L732"><code>resolveLockAsync</code> function</a> to resolve this transaction.</p>
<p>First, it checks all secondary locks. After that we should know the commit TS of this transaction. If all locks exist or some key has been committed, we can calculate a real commit TS. And if some lock does not exist, the commit TS is zero which indicates the transaction should be rolled back.</p>
<pre><code class="language-go">resolveData, err := lr.checkAllSecondaries(bo, l, &amp;status)
if err != nil {
    return err
}
status.commitTS = resolveData.commitTs
</code></pre>
<p>Then we can use this commit TS to resolve all the locks in this transaction.</p>
<p>Another case is when the transaction is actually not an async-commit transaction. Some keys are prewritten with the async-commit protocol while some keys fail and fallback. Such a case can be <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L674">detected</a> when checking secondary locks:</p>
<pre><code class="language-go">if !lockInfo.UseAsyncCommit {
    return &amp;nonAsyncCommitLock{}
}
</code></pre>
<p>And then, we will <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L341">retry the lock resolving process</a> assuming the transaction is not an async-commit transaction. And now, <code>CheckTxnStatus</code> can clean up an expired primary lock:</p>
<pre><code class="language-go">if _, ok := errors.Cause(err).(*nonAsyncCommitLock); ok {
    err = resolve(l, true)
}
</code></pre>
<h3 id="ddl-compatibility"><a class="header" href="#ddl-compatibility">DDL compatibility</a></h3>
<p>Without async commit, we check whether the schema changes before the second phase of the commit. But as the transaction is committed after prewriting all the locks, we don't have the chance to check the schema version. Here we use a trick to work around the problem.</p>
<p>For DDLs which involve data reorganizations, we <a href="https://github.com/pingcap/tidb/blob/cd8fb24c5f7ebd9d479ed228bb41848bd5e97445/ddl/ddl.go#L691">delay</a> 3 seconds by default. Then, before doing 2PC, we <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1625">set <code>MaxCommitTS</code></a> to 2 seconds later from now:</p>
<pre><code class="language-go">func (c *twoPhaseCommitter) calculateMaxCommitTS(ctx context.Context) error {
	// Amend txn with current time first, then we can make sure we have another SafeWindow time to commit
	currentTS := oracle.ComposeTS(int64(time.Since(c.txn.startTime)/time.Millisecond), 0) + c.startTS
	_, _, err := c.checkSchemaValid(ctx, currentTS, c.txn.schemaVer, true)
	if err != nil {
		return errors.Trace(err)
	}

	safeWindow := config.GetGlobalConfig().TiKVClient.AsyncCommit.SafeWindow
	maxCommitTS := oracle.ComposeTS(int64(safeWindow/time.Millisecond), 0) + currentTS

	c.maxCommitTS = maxCommitTS
	return nil
}
</code></pre>
<p>Therefore, all async-commit transaction using the old schema should be committed before DDL reorganization happens. So, the DDL reorganization will not miss these data.</p>
<h2 id="tikv-part"><a class="header" href="#tikv-part">TiKV part</a></h2>
<h3 id="concurrency-manager"><a class="header" href="#concurrency-manager">Concurrency manager</a></h3>
<p>As discussed in the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theory blog</a>, TiKV needs to record the max TS and set some memory locks for ongoing prewrite requests.</p>
<p>For simplicity, we use a global component to implement it. We call it the &quot;concurrency manager&quot;.</p>
<p>The methods provided by the concurrency manager can be found in <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/concurrency_manager/src/lib.rs">this file</a>.</p>
<p>It is very easy to update the max TS. It's just an atomic operation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_max_ts(&amp;self, new_ts: TimeStamp) {
    if new_ts != TimeStamp::max() {
        self.max_ts.fetch_max(new_ts.into_inner(), Ordering::SeqCst);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>It is a bit complex for memory locks.</p>
<p>The memory locks can have multiple accessors. Of course, the first one is the prewrite process. And because all readers need to check the memory locks, they are accessors of the memory locks, too. The locks can be removed from the table when there are no accessors.</p>
<p>So the memory table just owns a weak reference to the lock. We define the table like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LockTable(pub Arc&lt;SkipMap&lt;Key, Weak&lt;KeyHandle&gt;&gt;&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>To add a memory lock and be able to write lock information, the <code>lock_key</code> method needs to be called to get a lock guard. The locking process is a bit tricky to handle various possiblities in the multi-thread environment. If interested, you can refer to <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/concurrency_manager/src/lock_table.rs#L22">the code</a> for details.</p>
<h3 id="prewrite-1"><a class="header" href="#prewrite-1">Prewrite</a></h3>
<p>The code of prewrite can be found <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L405">here</a>. We will talk about some key points in the code about async commit.</p>
<p>In TiKV, <code>secondary_keys</code> and <code>try_one_pc</code> in the prewrite request are used to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L411-L415">determine the type</a> of the prewrite:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let commit_kind = match (&amp;self.secondary_keys, self.try_one_pc) {
    (_, true) =&gt; CommitKind::OnePc(self.max_commit_ts),
    (&amp;Some(_), false) =&gt; CommitKind::Async(self.max_commit_ts),
    (&amp;None, false) =&gt; CommitKind::TwoPc,
};
<span class="boring">}
</span></code></pre></pre>
<p>Only when prewriting the primary lock, secondary locks need to be written in the lock:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut secondaries = &amp;self.secondary_keys.as_ref().map(|_| vec![]);
if Some(m.key()) == async_commit_pk {
    secondaries = &amp;self.secondary_keys;
}
<span class="boring">}
</span></code></pre></pre>
<p>In the prewrite action, async commit does not change the checks. What is different is in the <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L367"><code>write_lock</code> function</a>.</p>
<p>Besides setting secondary keys in the primary lock, it calls <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L367"><code>async_commit_timestamps</code></a> to set <code>min_commit_ts</code> in the lock.</p>
<p>Here is the simplified code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let final_min_commit_ts = key_guard.with_lock(|l| {
    let max_ts = txn.concurrency_manager.max_ts();

    let min_commit_ts = cmp::max(cmp::max(max_ts, start_ts), for_update_ts).next();
    let min_commit_ts = cmp::max(lock.min_commit_ts, min_commit_ts);

    let max_commit_ts = max_commit_ts;
    if (!max_commit_ts.is_zero() &amp;&amp; min_commit_ts &gt; max_commit_ts) {
        return Err(ErrorInner::CommitTsTooLarge {
            start_ts,
            min_commit_ts,
            max_commit_ts,
        });
    }

    lock.min_commit_ts = min_commit_ts;
    *l = Some(lock.clone());
    Ok(min_commit_ts)
})?;

txn.guards.push(key_guard);
<span class="boring">}
</span></code></pre></pre>
<p>The final <code>min_commit_ts</code> is set to the maximum of (max TS + 1) and the original <code>min_commit_ts</code>. And if the <code>min_commit_ts</code> is greater than <code>max_commit_ts</code>, a <code>CommitTsTooLarge</code> is returned and triggers a fallback to non-async commit.</p>
<p>The operation is done while locked to guarantee the atomicity of getting the max TS and setting the <code>min_commit_ts</code> in the lock.</p>
<p>The key guard is saved until the lock is successfully written into RocksDB. Before that, readers are able to check the locks in order not to break any constraint. We can release the guard to remove the lock in the memory table after the readers can read the lock from the RocksDB.</p>
<h4 id="fallback-to-non-async-commit"><a class="header" href="#fallback-to-non-async-commit">Fallback to non-async commit</a></h4>
<p>The client may provide a <code>max_commit_ts</code> constraint. If the calculated <code>min_commit_ts</code> is larger than the <code>max_commit_ts</code>, we need to fallback to non-async commit. </p>
<p>When the <code>CommitTsTooLarge</code> error happens, the lock will still be written, but in the lock <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L406">there will be no <code>use_async_commit</code> flag</a> and no secondary keys will be recorded:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Err(Error(box ErrorInner::CommitTsTooLarge { .. })) = &amp;res {
    lock.use_async_commit = false;
    lock.secondaries = Vec::new();
}
<span class="boring">}
</span></code></pre></pre>
<p>After any key encounters this error, we <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L501">don't need to do async commit prewrite</a> for later keys:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> Err(MvccError(box MvccErrorInner::CommitTsTooLarge { .. })) | Ok((..)) =&gt; {
    // fallback to not using async commit or 1pc
    props.commit_kind = CommitKind::TwoPc;
    async_commit_pk = None;
    self.secondary_keys = None;
    // release memory locks
    txn.guards = Vec::new();
    final_min_commit_ts = TimeStamp::zero();
}
<span class="boring">}
</span></code></pre></pre>
<p>When any key in a transaction fallbacks to non-async commit mode, the transaction will be considered as a non-async commit transaction.</p>
<h3 id="memory-lock-checking"><a class="header" href="#memory-lock-checking">Memory lock checking</a></h3>
<p>All transactional reading requests need to update max TS and check memory locks. If the <code>min_commit_ts</code> of the lock is not larger than the snapshot timestamp of the reading, it is not safe to proceed this read. Then, an error will be returned and the client needs to retry later.</p>
<p>Here is <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/mod.rs#L1808">an example</a> in the storage module:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update max_ts and check the in-memory lock table before getting the snapshot
if !pb_ctx.get_stale_read() {
    concurrency_manager.update_max_ts(start_ts);
}
let isolation_level = pb_ctx.get_isolation_level();
if isolation_level == IsolationLevel::Si {
    for key in keys.clone() {
        concurrency_manager
            .read_key_check(key, |lock| {
                Lock::check_ts_conflict(Cow::Borrowed(lock), key, start_ts, bypass_locks)
            })
            .map_err(|e| txn::Error::from_mvcc(e))?;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="check-transaction-status"><a class="header" href="#check-transaction-status">Check transaction status</a></h3>
<p>We use <code>CheckTxnStatus</code> to get the status of the primary lock and use <code>CheckSecondaryLocks</code> for secondary locks.</p>
<p>In <code>CheckTxnStatus</code>, we cannot remove the primary lock simply because it is expired because the transaction may have prewritten all the locks. So we always just return the lock information for async commit locks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if lock.use_async_commit {
    if force_sync_commit {
        // The fallback case
    } else {
        return Ok((TxnStatus::uncommitted(lock, false), None));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The idea of <code>CheckSecondaryLocks</code> is simple. If any lock in the list of secondary keys does not exist, remove the lock and write rollback if necessary. And if any lock has been committed, the transaction is committed. You can refer to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/check_secondary_locks.rs#L54">its implementation</a> for details.</p>
<h3 id="update-max-ts-on-region-changes"><a class="header" href="#update-max-ts-on-region-changes">Update max TS on region changes</a></h3>
<p>In TiKV, we must guarantee that when a key is prewritten using the async-commit protocol, all readings at this key have updated the max TS. Now we update the max TS on the local TiKV. But there are some other cases we missed. If the reading happens on other TiKVs, then the region leader is transfered to the current TiKV or the region is merged into a region whose leader is on this TiKV, the max TS can be incorrect.</p>
<p>So, for safety, we choose to get a latest timestamp from PD when a region <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/raftstore/src/store/peer.rs#L1391">becomes leader</a> or a region <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/raftstore/src/store/fsm/peer.rs#L2992">is merged</a>.</p>
<p>Before the max TS is updated, the corresponding region is not allowed to proceed an async-commit prewrite. The property is checked <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L364">here</a>.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>This is how the &quot;async commit&quot; optimization is implemented in TiDB.</p>
<p>Due to limited space, some subtle problems such as non-unique timestamps and the compatibility with follower read are not involved.</p>
<p>During the implementation of async commit, many problems blocking one-phase commit (1PC) are solved. So it becomes relatively easy to implement 1PC in TiDB. The next document will introduce the implementation details of 1PC.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="1pc"><a class="header" href="#1pc">1PC</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mvcc-garbage-collection"><a class="header" href="#mvcc-garbage-collection">MVCC garbage collection</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="session"><a class="header" href="#session">Session</a></h1>
<p>The <code>session</code> package (and related packages such as <code>sessionctx</code> and <code>sessionctx/variable</code>) are responsible for maintaining the state of both sessions and transactions.</p>
<h2 id="new-session-origins"><a class="header" href="#new-session-origins">New session origins</a></h2>
<p>New connections are first established in the <code>server</code> package. After some initial protocol negotiation, the <code>server</code> package <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/server/driver_tidb.go#L181-L186">calls</a> <code>session.CreateSession()</code>. This function then calls <code>session.createSessionWithOpt()</code> (via <code>CreateSessionWithOpt()</code>) which creates the session.</p>
<p>Sessions used for internal server operations are usually created in a different manner, with the sessionctx being retrieved from a pool of sessions maintained by <code>domain</code>. For example:</p>
<pre><code class="language-go">dom := domain.GetDomain(e.ctx)
sysSessionPool := dom.SysSessionPool()
ctx, err := sysSessionPool.Get()
if err != nil {
    return nil, err
}
restrictedCtx := ctx.(sessionctx.Context)
restrictedCtx.GetSessionVars().InRestrictedSQL = true
</code></pre>
<p>Internal sessions will not show up in the output of <code>SHOW PROCESSLIST</code>, and skip all privilege checks because they do not have a privilege manager handle attached.</p>
<h2 id="system-variable-state"><a class="header" href="#system-variable-state">System variable state</a></h2>
<p>System variables follow similar semantics to MySQL:</p>
<ul>
<li>If a variable includes <code>SESSION</code> scope, the value is copied to the session state when the session is created.</li>
<li>Any changes to the <code>GLOBAL</code> value will not apply to any existing sessions.</li>
</ul>
<p>The state of the variables is stored in <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/session.go#L432-L958"><code>sessionVars</code></a>. The raw <em>string</em> values are stored in a map named <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/session.go#L449-L450"><code>systems</code></a>. This string value is used for persistence in the <code>mysql.global_variables</code> table.</p>
<p>For many variables, as well as a <em>string</em> value there is a typed field in <code>sessionVars</code>. For example:</p>
<p><code>SessionVars.systems[&quot;tidb_skip_utf8_check&quot;]</code> (string) maps to <code>SessionVars.SkipUTF8Check</code> (bool).</p>
<p>The typed value is set when the <code>SetSession</code> attached to the <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L1029-L1032">system variable definition</a> is called. For <code>tidb_skip_utf8_check</code> this is as follows:</p>
<pre><code class="language-go">{Scope: ScopeGlobal | ScopeSession, Name: TiDBSkipUTF8Check, Value: BoolToOnOff(DefSkipUTF8Check), Type: TypeBool, SetSession: func(s *SessionVars, val string) error {
	s.SkipUTF8Check = TiDBOptOn(val)
	return nil
}},
</code></pre>
<p>The <code>SetSession</code> function can also be considered an <code>Init</code> function, since it is called when the session is created and the values are copied from global scope. To disable <code>SetSession</code> from being called on creation, <code>skipInit</code> can be set to <code>true</code>. For example with <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L745-L752"><code>CharsetDatabase</code></a>:</p>
<pre><code class="language-go">{Scope: ScopeGlobal | ScopeSession, Name: CharsetDatabase, Value: mysql.DefaultCharset, skipInit: true, Validation: func(vars *SessionVars, normalizedValue string, originalValue string, scope ScopeFlag) (string, error) {
    return checkCharacterSet(normalizedValue, CharsetDatabase)
}, SetSession: func(s *SessionVars, val string) error {
	if cs, err := charset.GetCharsetInfo(val); err == nil {
		s.systems[CollationDatabase] = cs.DefaultCollation
	}
	return nil
}},
</code></pre>
<p>In the above example, skipping the <code>SetSession</code> function is useful because it prevents the <code>CollationDatabase</code> from being overwritten when the session is initialized. This is only expected if the user issues a statement to change the <code>CharsetDatabase</code> value.</p>
<h3 id="differences-from-mysql"><a class="header" href="#differences-from-mysql">Differences from MySQL</a></h3>
<p>In TiDB, changes to <code>GLOBAL</code> scoped system variables are propagated to other TiDB servers in the cluster and persist across restarts. The notification event to other servers is sent via an etcd channel in the call <code>domain.GetDomain(s).NotifyUpdateSysVarCache()</code>:</p>
<pre><code class="language-go">// replaceGlobalVariablesTableValue executes restricted sql updates the variable value
// It will then notify the etcd channel that the value has changed.
func (s *session) replaceGlobalVariablesTableValue(ctx context.Context, varName, val string) error {
	stmt, err := s.ParseWithParams(ctx, `REPLACE INTO %n.%n (variable_name, variable_value) VALUES (%?, %?)`, mysql.SystemDB, mysql.GlobalVariablesTable, varName, val)
	if err != nil {
		return err
	}
	_, _, err = s.ExecRestrictedStmt(ctx, stmt)
	domain.GetDomain(s).NotifyUpdateSysVarCache() // &lt;-- the notification happens here
	return err
}
</code></pre>
<p>Because <code>GLOBAL</code> scoped variables are propagated to other servers, TiDB also has a special concept of &quot;instance-scoped variables&quot;. An instance scoped variable is actually a <code>SESSION</code> scoped variable that has a <code>GetSession</code> method which returns data that is specific to an instance. For example, <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L1315-L1321"><code>tidb_general_log</code></a>:</p>
<pre><code class="language-go">{Scope: ScopeSession, Name: TiDBGeneralLog, Value: BoolToOnOff(DefTiDBGeneralLog), Type: TypeBool, skipInit: true, SetSession: func(s *SessionVars, val string) error {
	ProcessGeneralLog.Store(TiDBOptOn(val))
	return nil
}, GetSession: func(s *SessionVars) (string, error) {
	return BoolToOnOff(ProcessGeneralLog.Load()), nil
}},
</code></pre>
<p>The decision to make an option such as <code>tidb_general_log</code> instance scoped is because it references a file on the local filesystem. This may create issues when global, as the path may not be writable on each tidb-server in the cluster.</p>
<p>As you can see by the <code>Scope: Session</code>, instance-scoped variables are not natively handled by the sysvar framework, but are instead denoted by the <code>GetSession()</code> function reading from a global location. The documentation for <a href="https://docs.pingcap.com/tidb/dev/system-variables#tidb_general_log"><code>tidb_general_log</code></a> also notes it as &quot;instance&quot; scoped by convention.</p>
<h2 id="transaction-state"><a class="header" href="#transaction-state">Transaction state</a></h2>
<p>The <code>session</code> struct (<code>s.txn</code>) is responsible for keeping modified key-value pairs in a <a href="https://github.com/pingcap/tidb/blob/bfbea9c3ef4232d76296a9c8390eb8b7da5bf45d/session/txn.go#L46-L71"><code>LazyTxn</code></a> until the transaction commits. A <code>commit</code> statement only sets the session variable state that it is <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/executor/simple.go#L701-L703">no longer in an active transaction</a>:</p>
<pre><code class="language-go">func (e *SimpleExec) executeCommit(s *ast.CommitStmt) {
	e.ctx.GetSessionVars().SetInTxn(false)
}
</code></pre>
<p>The function <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/session/tidb.go#L242-L267"><code>autoCommitAfterStmt()</code></a> which is called as part of <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/session/tidb.go#L207-L224"><code>finishStmt()</code></a> is responsible for committing the transaction:</p>
<pre><code class="language-go">if !sessVars.InTxn() {
	if err := se.CommitTxn(ctx); err != nil {
		if _, ok := sql.(*executor.ExecStmt).StmtNode.(*ast.CommitStmt); ok {
			err = errors.Annotatef(err, &quot;previous statement: %s&quot;, se.GetSessionVars().PrevStmt)
		}
		return err
	}
	return nil
}
</code></pre>
<p>The <code>session.CommitTxn()</code> function will handle the <code>commit</code>, including retry (if permitted). There is also special handling for both pessimistic and optimistic transactions, as well as removing the key-value pairs which apply to temporary tables from the transaction buffer.</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="understand-tidb/the-lifecycle-of-a-statement.html">The lifecycle of a statement</a></li>
<li><a href="understand-tidb/privilege.html">Privilege management</a></li>
<li><a href="understand-tidb/transaction.html">Transaction</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="privilege"><a class="header" href="#privilege">Privilege</a></h1>
<p>At its core, TiDB's approach to user privileges is similar to that of MySQL:</p>
<ul>
<li>The privileges are stored in tables such as <code>mysql.user</code> and <code>mysql.db</code>.</li>
<li>The privilege tables are then loaded into an <a href="https://github.com/pingcap/tidb/blob/master/privilege/privileges/cache.go">in-memory cache</a>. The cache is then used by the privilege manager to determine the privileges of a user.</li>
<li>The cache is automatically updated when using privilege control statements such as <code>GRANT</code> and <code>REVOKE</code>. The statement <code>FLUSH PRIVILEGES</code> can also be used to manually reload the cache for when manual changes are made to the privilege tables.</li>
</ul>
<h2 id="behavior-differences-from-mysql"><a class="header" href="#behavior-differences-from-mysql">Behavior differences from MySQL</a></h2>
<p>Implicit updates to the privilege cache (i.e. when <code>GRANT</code> or <code>REVOKE</code> statements are executed) run immediately on the instance of TiDB that is executing the statement. A <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/domain/domain.go#L1355-L1373">notification is also sent to all TiDB instances</a> to rebuild their cache. This notification is sent asynchronously, so it is possible that when a load balancer is used, the cache will be out of date when attempting to reconnect to a TiDB instance immediately.</p>
<p>Because the asynchronous notifications do not guarantee delivery, TiDB will also <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/domain/domain.go#L852-L908">automatically rebuild the privilege cache</a> every 5-10 minutes in a loop. This behavior is not strictly MySQL compatible, because in MySQL the privilege cache will only ever be rebuilt from a <code>FLUSH PRIVILEGES</code> statement, a restart, or a privilege control statement.</p>
<p>Client certificate options are stored in the <code>mysql.global_priv</code> table instead of the <code>mysql.user</code> table. This behavior is not intentional, and may be changed in the future.</p>
<h2 id="adding-privilege-checks-to-a-statement"><a class="header" href="#adding-privilege-checks-to-a-statement">Adding privilege checks to a statement</a></h2>
<p>Some privilege checks are automatically assigned during plan building, for example ensuring that you have permissions to the tables that will be accessed. These checks are skipped for <code>information_schema</code> tables, and should you add an additional statement (such as <code>SHOW xyz</code>), you will also need to ensure that privilege checks are added.</p>
<p>Should you need to add privilege checks there are two options:</p>
<ol>
<li>
<p>During plan building you can attach <code>visitInfo</code> to the plan (examples: <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/planner/core/planbuilder.go#L745"><code>SET CONFIG</code></a>, <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/planner/core/planbuilder.go#L2378-L2380"><code>SHOW BACKUPS</code></a>)</p>
</li>
<li>
<p>In the executor function which handles the statement (examples: <a href="https://github.com/pingcap/tidb/blob/1a54708a7f8f86515236626c78e97a33d8adf583/executor/show.go#L368-L380"><code>SHOW PROCESSLIST</code></a>).</p>
</li>
</ol>
<p>The first option is recommended, as it is much less verbose. However, <code>visitInfo</code> does not handle cases where the statement can behave differently depending on the permissions of the user executing it. All users can execute the <code>SHOW PROCESSLIST</code> statement, but to see the sessions of other users requires the <code>PROCESS</code> privilege.</p>
<p><code>visitInfo</code> also only supports <strong>AND</strong> semantics. For complex scenarios (such as <code>DROP USER</code> requiring either <code>CREATE USER</code> <strong>OR</strong> <code>DELETE</code> privileges on the <code>mysql.user</code> table), option 2 is required.</p>
<h3 id="manually-checking-with-the-privilege-manager"><a class="header" href="#manually-checking-with-the-privilege-manager">Manually checking with the privilege manager</a></h3>
<p>For (2) above, manual checks should follow the following pattern:</p>
<pre><code class="language-go">checker := privilege.GetPrivilegeManager(e.ctx)
if checker != nil &amp;&amp; !checker.RequestVerification(ctx.GetSessionVars().ActiveRoles, schema.Name.L, table.Name.L, &quot;&quot;, mysql.AllPrivMask) {
    /* do something */
}
..
if checker == nil || !checker.RequestDynamicVerification(ctx.GetSessionVars().ActiveRoles, &quot;RESTRICTED_TABLES_ADMIN&quot;, false) {
    /* do something */
}
</code></pre>
<p>The check for <code>checker != nil</code> is important because for internal SQL statements the privilege manager is not present. These statements are expected to fall through and satisfy the privilege check.</p>
<h3 id="static-and-dynamic-privileges"><a class="header" href="#static-and-dynamic-privileges">Static and dynamic privileges</a></h3>
<p>Privileges fall into two categories:</p>
<ul>
<li>Static privileges: These are the &quot;traditional&quot; privileges such as <code>INSERT</code>, <code>UPDATE</code>, <code>SELECT</code>, <code>DELETE</code>, <code>SUPER</code>, <code>PROCESS</code> which have existed in MySQL for a long time. They can <em>usually</em> be assigned to a user on either a global or database/table level.</li>
<li>Dynamic privileges: These are new privileges such as <code>BACKUP_ADMIN</code>, <code>RESTORE_ADMIN</code>, <code>CONNECTION_ADMIN</code>. They can only be assigned on a global level, and each have their own &quot;grantable&quot; attribute.</li>
</ul>
<p>Dynamic privileges were introduced in MySQL 8.0 (and <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-dynamic-privileges.md">TiDB 5.1</a>) to solve a specific issue, which is that the <code>SUPER</code> privilege is too coarse. There are many scenarios where a user needs to be assigned the <code>SUPER</code> privilege to perform a specific action, but too many other privileges are granted at the same time.</p>
<p>Any statements added to TiDB <strong>should no longer require</strong> the <code>SUPER</code> privilege directly. Instead, a dynamic privilege should be added <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/privilege/privileges/cache.go#L1009">which will be satified</a> by the <code>SUPER</code> privilege.</p>
<h3 id="security-enhanced-mode"><a class="header" href="#security-enhanced-mode">Security Enhanced Mode</a></h3>
<p>TiDB features an extension to MySQL called <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-security-enhanced-mode.md">Security Enhanced Mode</a> (SEM), which is disabled by default. One of the main aims of SEM is to reduce the privileges of <code>SUPER</code> and instead require specific &quot;restricted&quot; dynamic privileges instead. The design is inspired by features such as &quot;Security Enhanced Linux&quot; (SeLinux) and AppArmor.</p>
<p>SEM plugs directly into the privilege manager, but the hard coded list of restricted objects lives in <a href="https://github.com/pingcap/tidb/blob/master/util/sem/sem.go"><code>./util/sem/*</code></a>. It is expected that over time SEM will protect against additional operations which are considered to be high risk or too broad.</p>
<h3 id="recommended-reading-1"><a class="header" href="#recommended-reading-1">Recommended Reading</a></h3>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-security-enhanced-mode.md">Technical Design: Security Enhanced Mode</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-dynamic-privileges.md">Technical Design: Dynamic Privileges</a></li>
<li><a href="https://dev.mysql.com/worklog/task/?id=8131">MySQL Worklog: Pluggable Dynamic Privileges</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plugin"><a class="header" href="#plugin">Plugin</a></h1>
<p>The plugin API allows TiDB to be extended with new features such as audit logging or IP allow/deny listing.</p>
<p>Sample code is provided for a basic audit logging plugin at <a href="https://github.com/pingcap/tidb/tree/master/plugin/conn_ip_example"><code>plugin/conn_ip_example/</code></a>. For an example on compiling TiDB and this plugin:</p>
<pre><code class="language-bash">plugin=&quot;conn_ip_example&quot;
cd cmd/pluginpkg
go install
cd ../../plugin/$plugin
pluginpkg -pkg-dir . -out-dir .
cd ../..
 
./bin/tidb-server -plugin-dir plugin/$plugin -plugin-load $plugin-1
</code></pre>
<p>An explanation of what this does:</p>
<ul>
<li><code>cd cmd/pluginpkg</code> and <code>go install</code> compiles the command line utility called <code>pluginpkg</code>, which is used to build the plugin.</li>
<li><code>pluginpkg -pkg-dir . -out-dir .</code> reads the plugin code + <code>manifest.toml</code> file and generates a shared object file for the plugin (<code>conn_ip_example-1.so</code>).</li>
<li>When the tidb-server starts, it can load plugins in a specified directory (<code>plugin-dir</code>).</li>
</ul>
<p>You can confirm which plugins are installed with the <code>SHOW PLUGINS</code> statement:</p>
<pre><code class="language-sql">mysql&gt; show plugins;
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
| Name            | Status       | Type  | Library                                                                              | License | Version |
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
| conn_ip_example | Ready-enable | Audit | /home/morgo/go/src/github.com/morgo/tidb/plugin/conn_ip_example/conn_ip_example-1.so |         | 1       |
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
1 row in set (0.00 sec)
</code></pre>
<h2 id="customizing-the-example-plugin"><a class="header" href="#customizing-the-example-plugin">Customizing the example plugin</a></h2>
<p>The manifest file describes the capabilities of the plugin, and which features it implements. For a basic version:</p>
<pre><code class="language-toml">name = &quot;conn_ip_example&quot;
kind = &quot;Audit&quot;
description = &quot;just a test&quot;
version = &quot;1&quot;
license = &quot;&quot; # Suggested: APLv2 or GPLv3. See https://choosealicense.com/ for details
validate = &quot;Validate&quot;
onInit = &quot;OnInit&quot;
onShutdown = &quot;OnShutdown&quot;
export = [
    {extPoint=&quot;OnGeneralEvent&quot;, impl=&quot;OnGeneralEvent&quot;},
    {extPoint=&quot;OnConnectionEvent&quot;, impl=&quot;OnConnectionEvent&quot;}
]
</code></pre>
<p>In addition to this basic example, plugins can also implement an <a href="https://github.com/pingcap/tidb/blob/d58d39e9476f2503a1e8790f78a0d25272d0aabe/plugin/spi.go#L51"><code>OnFlush</code></a> function. This is called when the statement <code>FLUSH TIDB PLUGINS pluginName</code> is executed. TiDB does not require plugins to implement a <code>OnFlush</code> function, but when specified it will call this method on all TiDB nodes in the cluster.</p>
<h3 id="onconnectionevent"><a class="header" href="#onconnectionevent">OnConnectionEvent</a></h3>
<p>The <code>OnConnectionEvent</code> is called when a new connection is initially created (<code>event plugin.ConnectionEvent == plugin.PreAuth</code>) and again when the connection is successfully established (<code>event plugin.ConnectionEvent == plugin.Connected</code>).</p>
<p>To prevent a connection from being created, an error should be returned for the event <code>plugin.PreAuth</code>.</p>
<h3 id="ongeneralevent"><a class="header" href="#ongeneralevent">OnGeneralEvent</a></h3>
<p>The <code>OnGeneralEvent</code> is called:</p>
<ul>
<li>Before a statement starts execution (<code>event plugin.GeneralEvent == plugin.Starting</code>)</li>
<li>Ater a statement has completed execution (<code>event plugin.GeneralEvent == plugin.Completed</code>)</li>
</ul>
<p>General events are useful for auditing operations performed by users. Because <a href="https://github.com/pingcap/tidb/blob/b2a1d21284b75e3137f499d8954071a7b32f7b3b/sessionctx/variable/session.go#L432-L436"><code>sctx SessionVars</code></a> is available in the <code>OnGeneralEvent</code> function, it is possible to obtain a lot of additional information about the statement being executed. For example:</p>
<ul>
<li><code>sctx.User</code> contains the <code>*auth.UserIdentity</code> of the user who is executing this session, and <code>sctx.ActiveRoles</code> contains the list of active roles associated with the session.</li>
<li><code>sctx.DBName</code> contains the name of the database the user is executing in.</li>
<li><code>sctx.StmtCtx</code> contains the context of the statement that was executed. For example <code>sctx.StmtCtx.SQLDigest()</code> can be called to get a digest of the executed statement, and <code>sctx.StmtCtx.Tables</code> contains a slice of tables that are accessed by the statement.</li>
</ul>
<p>The current implementation of <code>OnGeneralEvent</code> does not permit errors to be returned. It is possible that this may change in a future version, since this will allow pre-execution checks to be performed on statements.</p>
<h2 id="additional-reading"><a class="header" href="#additional-reading">Additional Reading</a></h2>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2018-12-10-plugin-framework.md">Plugin Framework RFC Proposal</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="project-management"><a class="header" href="#project-management">Project Management</a></h1>
<p>Practices for managing the TiDB project:</p>
<ul>
<li><a href="project-management/release-train-model.html">Release Train Model</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="release-train-model"><a class="header" href="#release-train-model">Release Train Model</a></h1>
<h2 id="what-is-the-release-train-model"><a class="header" href="#what-is-the-release-train-model">What is the release train model?</a></h2>
<p>Before introducing the concept of the release train model, let us take a review of the delivery mode of TiDB in the past.</p>
<p>In releases earlier than v5.0, the release frequency of TiDB major versions was a year or half a year, which is quite a long development cycle. The long development cycle has both benefits and drawbacks as follows:</p>
<ul>
<li>Benefits: the longer a development cycle is, the more features one release can deliver.</li>
<li>Drawbacks: the longer a development cycle is, the more difficulties we have to coordinate regression and acceptance tests, and the more possibly a delay happens. Also, if new feature requests are received during the long development cycle, these new features are added to the development backlog after the start of the development cycle. In this case, development tasks are hardly converged before the release date.</li>
</ul>
<p>Starting from v5.0, TiDB adopts the release train model, which is a product development model for requirements gathering, analysis, decision making, release, and issue feedback.</p>
<p>Just like a train delivering goods, decisions need to be made about the priorities of the goods, destination, arrival time, which train to load on, which carriage, etc., before the train departs.</p>
<p>The benefits of moving to the release train model are as follows:</p>
<ol>
<li>A shorter feedback cycle: users can benefit from features shipped faster.</li>
<li>Easier predictability for contributors and users:
<ol>
<li>Developers and reviewers can decide in advance the target release to deliver specific features.</li>
<li>If a feature misses a release train, we have a good idea of when the feature will show up later.</li>
<li>Users know when to expect their features.</li>
</ol>
</li>
<li>Transparency. There will be a published cut-off date (AKA code freeze) for the release and people will know about the date in advance. Hopefully this will remove the contention around which features will be included in the release.</li>
<li>Quality. we've seen issues pop up in release candidates due to last-minute features that didn't have proper time to bake in. More time between code freeze and release will let us test more, document more and resolve more issues.</li>
<li>Project visibility and activity. Having frequent releases improves our visibility and gives the community more opportunities to talk about TiDB.</li>
</ol>
<p>Because nothing is ever perfect, the release train model has some downsides as well:</p>
<ol>
<li>Most notably, for features that miss the code-freeze date for a release, we have to wait for a few months to catch the next release train. Most features will reach users faster as per benefit #1, but it is possible that a few features missing the code-freeze date might lose out.</li>
<li>With the frequent releases, users need to figure out which release to use. Also, having frequent new releases to upgrade may be a bit confusing.</li>
<li>Frequent releases means more branches. To fix a bug of an old release, we need to work on more old branches.</li>
</ol>
<p>We decided to experiment with release train model and see if the benefits for us as a community exceed the drawbacks. </p>
<h2 id="how-will-tidb-development-process-look-like"><a class="header" href="#how-will-tidb-development-process-look-like">How will TiDB development process look like?</a></h2>
<p>At this stage we are planning to make a release every two months.</p>
<p>Thus, a typical development cycle takes two months, which we call a sprint. For example, the development cycle of v5.2 is from the end of June to the end of August and is called Sprint 4.</p>
<p>Two weeks before the release date, the release manager will create a branch for the new release based on the master branch, publish a list of features to be included in the release, and also announce the code-freeze, after which only fixes for blocking bugs can be merged. This announcement will be posted on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<p>For the release train model, we strictly ensure that a release happens on the planned date. For example, we decide to deliver the v5.2 release by the end of August so we will stick to it. If any features cannot be completed by the code-freeze date, we will drop them and avoid taking them into the new release branch. In this case, the development in the master branch can still work as usual and those features will be moved to the following release. </p>
<p>Ideally, we would have started stabilization once we create the new release branch. After the code-freeze date, only pull requests of blocker bugs can be merged to the new release branch. In a rare scenario, it is possible that few features pass the code freeze bar but still fail to be completed on time. Such features will also be dropped from the release train in the end to meet the release deadline.</p>
<h2 id="what-happens-if-features-are-not-completed"><a class="header" href="#what-happens-if-features-are-not-completed">What happens if features are not completed?</a></h2>
<p>Different features have different complexities. Some features can be implemented within a single release while some features span multiple releases. With the release train model, to ensure that ongoing features do not affect the stability of the release, we have two approaches as follows:</p>
<ol>
<li>
<p>Ensure that each feature is split into testable units and only testable units get merged. This means that a good set of unit tests and system tests are written for sub-tasks before they are merged. This approach ensures that the master branch is in a relatively stable state and can be released at any time.</p>
</li>
<li>
<p>Use feature branches. For a specific feature, the feature developers create a branch from the master branch and ensure that the branch is in sync with the master branch from time to time. Only when the feature developers and reviewers have a high level of confidence in the feature stability, the feature can be merged into master. This approach brings the additional overhead of branching and performing merges from time to time.</p>
</li>
</ol>
<p>In practice, the right approach can be a mix of both. The feature developers need to make the decesion depending on the complexity of the feature.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

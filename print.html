<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TiDB Development Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">TiDB Development Guide</a></li><li class="chapter-item expanded "><a href="get-started/introduction.html"><strong aria-hidden="true">1.</strong> Get Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="get-started/install-golang.html"><strong aria-hidden="true">1.1.</strong> Install Golang</a></li><li class="chapter-item expanded "><a href="get-started/build-tidb-from-source.html"><strong aria-hidden="true">1.2.</strong> Get the code, build and run</a></li><li class="chapter-item expanded "><a href="get-started/setup-an-ide.html"><strong aria-hidden="true">1.3.</strong> Setup an IDE</a></li><li class="chapter-item expanded "><a href="get-started/write-and-run-unit-tests.html"><strong aria-hidden="true">1.4.</strong> Write and run unit tests</a></li><li class="chapter-item expanded "><a href="get-started/debug-and-profile.html"><strong aria-hidden="true">1.5.</strong> Debug and profile</a></li><li class="chapter-item expanded "><a href="get-started/commit-code-and-submit-a-pull-request.html"><strong aria-hidden="true">1.6.</strong> Commit code and submit a pull request</a></li></ol></li><li class="chapter-item expanded "><a href="contribute-to-tidb/introduction.html"><strong aria-hidden="true">2.</strong> Contribute to TiDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribute-to-tidb/community-guideline.html"><strong aria-hidden="true">2.1.</strong> Community Guideline</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/report-an-issue.html"><strong aria-hidden="true">2.2.</strong> Report an Issue</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/issue-triage.html"><strong aria-hidden="true">2.3.</strong> Issue Triage</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/contribute-code.html"><strong aria-hidden="true">2.4.</strong> Contribute Code</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/cherrypick-a-pr.html"><strong aria-hidden="true">2.5.</strong> Cherry-pick a Pull Request</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/review-a-pr.html"><strong aria-hidden="true">2.6.</strong> Review a Pull Request</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/make-a-proposal.html"><strong aria-hidden="true">2.7.</strong> Make a Proposal</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/code-style-and-quality-guide.html"><strong aria-hidden="true">2.8.</strong> Code Style and Quality Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/write-document.html"><strong aria-hidden="true">2.9.</strong> Write Document</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/release-notes-style-guide.html"><strong aria-hidden="true">2.10.</strong> Release Notes Language Style Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/committer-guide.html"><strong aria-hidden="true">2.11.</strong> Committer Guide</a></li><li class="chapter-item expanded "><a href="contribute-to-tidb/miscellaneous-topics.html"><strong aria-hidden="true">2.12.</strong> Miscellaneous Topics</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/introduction.html"><strong aria-hidden="true">3.</strong> Understand TiDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/the-lifecycle-of-a-statement.html"><strong aria-hidden="true">3.1.</strong> The Lifecycle of a Statement</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/ddl.html"><strong aria-hidden="true">3.1.1.</strong> DDL</a></li><li class="chapter-item expanded "><a href="understand-tidb/dml.html"><strong aria-hidden="true">3.1.2.</strong> DML</a></li><li class="chapter-item expanded "><a href="understand-tidb/dql.html"><strong aria-hidden="true">3.1.3.</strong> DQL</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/parser.html"><strong aria-hidden="true">3.2.</strong> Parser</a></li><li class="chapter-item expanded "><a href="understand-tidb/planner.html"><strong aria-hidden="true">3.3.</strong> Planner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/table-statistics.html"><strong aria-hidden="true">3.3.1.</strong> Table Statistics</a></li><li class="chapter-item expanded "><a href="understand-tidb/rbo.html"><strong aria-hidden="true">3.3.2.</strong> Rule-based Optimization</a></li><li class="chapter-item expanded "><a href="understand-tidb/cbo.html"><strong aria-hidden="true">3.3.3.</strong> Cost-based Optimization</a></li><li class="chapter-item expanded "><a href="understand-tidb/plan-cache.html"><strong aria-hidden="true">3.3.4.</strong> Plan Cache</a></li><li class="chapter-item expanded "><a href="understand-tidb/sql-plan-management.html"><strong aria-hidden="true">3.3.5.</strong> SQL Plan Management</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/execution.html"><strong aria-hidden="true">3.4.</strong> Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/parallel-execution-framework.html"><strong aria-hidden="true">3.4.1.</strong> Parallel Execution Framework</a></li><li class="chapter-item expanded "><a href="understand-tidb/implementation-of-vectorized-execution.html"><strong aria-hidden="true">3.4.2.</strong> Implementation of Vectorized Execution</a></li><li class="chapter-item expanded "><a href="understand-tidb/memory-management-mechanism.html"><strong aria-hidden="true">3.4.3.</strong> Memory Management Mechanism</a></li><li class="chapter-item expanded "><a href="understand-tidb/implementation-of-typical-operators.html"><strong aria-hidden="true">3.4.4.</strong> Implementation of Typical Operators</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/transaction.html"><strong aria-hidden="true">3.5.</strong> Transaction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="understand-tidb/transaction-on-tikv.html"><strong aria-hidden="true">3.5.1.</strong> Transaction on TiKV</a></li><li class="chapter-item expanded "><a href="understand-tidb/optimistic-transaction.html"><strong aria-hidden="true">3.5.2.</strong> Optimistic Transaction</a></li><li class="chapter-item expanded "><a href="understand-tidb/lock-resolver.html"><strong aria-hidden="true">3.5.3.</strong> Lock Resolver</a></li><li class="chapter-item expanded "><a href="understand-tidb/pessimistic-transaction.html"><strong aria-hidden="true">3.5.4.</strong> Pessimistic Transaction</a></li><li class="chapter-item expanded "><a href="understand-tidb/async-commit.html"><strong aria-hidden="true">3.5.5.</strong> Async Commit</a></li><li class="chapter-item expanded "><a href="understand-tidb/1pc.html"><strong aria-hidden="true">3.5.6.</strong> 1PC</a></li><li class="chapter-item expanded "><a href="understand-tidb/mvcc-garbage-collection.html"><strong aria-hidden="true">3.5.7.</strong> MVCC garbage collection</a></li></ol></li><li class="chapter-item expanded "><a href="understand-tidb/session.html"><strong aria-hidden="true">3.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="understand-tidb/privilege.html"><strong aria-hidden="true">3.7.</strong> Privilege</a></li><li class="chapter-item expanded "><a href="understand-tidb/plugin.html"><strong aria-hidden="true">3.8.</strong> Plugin</a></li></ol></li><li class="chapter-item expanded "><a href="project-management/introduction.html"><strong aria-hidden="true">4.</strong> Project Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project-management/release-train-model.html"><strong aria-hidden="true">4.1.</strong> Releases Train Model</a></li><li class="chapter-item expanded "><a href="project-management/tidb-versioning.html"><strong aria-hidden="true">4.2.</strong> TiDB Versioning</a></li></ol></li><li class="chapter-item expanded "><a href="extending-tidb/introduction.html"><strong aria-hidden="true">5.</strong> Extending TiDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extending-tidb/add-a-function.html"><strong aria-hidden="true">5.1.</strong> Add a function</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">TiDB Development Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/pingcap/tidb-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tidb-development-guide"><a class="header" href="#tidb-development-guide">TiDB Development Guide</a></h1>
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
<p><a href="index.html#contributors-"><img src="https://img.shields.io/badge/all_contributors-35-orange.svg?style=flat-square" alt="All Contributors" /></a></p>
<!-- ALL-CONTRIBUTORS-BADGE:END -->
<h2 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h2>
<ul>
<li><strong>The target audience</strong> of this guide is TiDB contributors, both new and experienced.</li>
<li><strong>The objective</strong> of this guide is to help contributors become an expert of TiDB, who is familiar with its design and implementation and thus is able to use it fluently in the real world as well as develop TiDB itself deeply.</li>
</ul>
<h2 id="the-structure-of-this-guide"><a class="header" href="#the-structure-of-this-guide">The structure of this guide</a></h2>
<p>At present, the guide is composed of the following parts:</p>
<ol>
<li><strong>Get started:</strong> Setting up the development environment, build and connect to the tidb-server, the subsections are based on an imagined newbie user journey.</li>
<li><strong>Contribute to TiDB</strong> helps you quickly get involved in the TiDB community, which illustrates what contributions you can make and how to quickly make one.</li>
<li><strong>Understand TiDB</strong>: helps you to be familiar with basic distributed database concepts, build a knowledge base in your mind, including but not limited to SQL language, key components, algorithms in a distributed database. The audiences who are already familiar with these concepts can skip this section.</li>
<li><strong>Project Management</strong>: helps you to participate in team working, lead feature development, manage projects in the TiDB community.</li>
</ol>
<h2 id="contributors-"><a class="header" href="#contributors-">Contributors ✨</a></h2>
<p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p>
<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/LittleFall"><img src="https://avatars.githubusercontent.com/u/30543181?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Zhi Qi</b></sub></a><br /><a href="index.html#content-LittleFall" title="Content">🖋</a></td>
    <td align="center"><a href="https://tisonkun.org"><img src="https://avatars.githubusercontent.com/u/18818196?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tison</b></sub></a><br /><a href="index.html#content-tisonkun" title="Content">🖋</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Atisonkun" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="http://zz-jason.github.io/"><img src="https://avatars.githubusercontent.com/u/5268763?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Jian Zhang</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Azz-jason" title="Reviewed Pull Requests">👀</a> <a href="index.html#content-zz-jason" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/qiancai"><img src="https://avatars.githubusercontent.com/u/79440533?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Grace Cai</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aqiancai" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://ichn.xyz"><img src="https://avatars.githubusercontent.com/u/29735669?v=4?s=100" width="100px;" alt=""/><br /><sub><b>虎</b></sub></a><br /><a href="index.html#content-ichn-hu" title="Content">🖋</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aichn-hu" title="Reviewed Pull Requests">👀</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/bb7133"><img src="https://avatars.githubusercontent.com/u/1174042?v=4?s=100" width="100px;" alt=""/><br /><sub><b>bb7133</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Abb7133" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://www.linkedin.com/in/gregabramowitzweber"><img src="https://avatars.githubusercontent.com/u/1183?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Greg Weber</b></sub></a><br /><a href="index.html#content-gregwebs" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/djshow832"><img src="https://avatars.githubusercontent.com/u/29590578?v=4?s=100" width="100px;" alt=""/><br /><sub><b>djshow832</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adjshow832" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="http://www.zenlife.tk"><img src="https://avatars.githubusercontent.com/u/1420062?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tiancaiamao</b></sub></a><br /><a href="index.html#content-tiancaiamao" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/tomdewan"><img src="https://avatars.githubusercontent.com/u/50153616?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tomdewan</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Atomdewan" title="Reviewed Pull Requests">👀</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/disksing"><img src="https://avatars.githubusercontent.com/u/12077877?v=4?s=100" width="100px;" alt=""/><br /><sub><b>disksing</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adisksing" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://www.hawkingrei.com/blog/"><img src="https://avatars.githubusercontent.com/u/3427324?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Weizhen Wang</b></sub></a><br /><a href="index.html#content-hawkingrei" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/TomShawn"><img src="https://avatars.githubusercontent.com/u/41534398?v=4?s=100" width="100px;" alt=""/><br /><sub><b>TomShawn</b></sub></a><br /><a href="index.html#content-TomShawn" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/mjonss"><img src="https://avatars.githubusercontent.com/u/5520054?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Mattias Jonsson</b></sub></a><br /><a href="index.html#content-mjonss" title="Content">🖋</a></td>
    <td align="center"><a href="http://www.tocker.ca/"><img src="https://avatars.githubusercontent.com/u/57982?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Morgan Tocker</b></sub></a><br /><a href="index.html#content-morgo" title="Content">🖋</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Amorgo" title="Reviewed Pull Requests">👀</a></td>
  </tr>
  <tr>
    <td align="center"><a href="http://databaseblog.myname.nl"><img src="https://avatars.githubusercontent.com/u/1272980?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Daniël van Eeden</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Adveeden" title="Reviewed Pull Requests">👀</a> <a href="index.html#content-dveeden" title="Content">🖋</a></td>
    <td align="center"><a href="https://xxchan.github.io"><img src="https://avatars.githubusercontent.com/u/37948597?v=4?s=100" width="100px;" alt=""/><br /><sub><b>xxchan</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Axxchan" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://www.iamhlbx.xyz"><img src="https://avatars.githubusercontent.com/u/50866227?v=4?s=100" width="100px;" alt=""/><br /><sub><b>iamhlbx</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3AHuGanghui" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/sunxiaoguang"><img src="https://avatars.githubusercontent.com/u/3982329?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Xiaoguang Sun</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Asunxiaoguang" title="Reviewed Pull Requests">👀</a> <a href="index.html#content-sunxiaoguang" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/eurekaka"><img src="https://avatars.githubusercontent.com/u/6261973?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Kenan Yao</b></sub></a><br /><a href="index.html#content-eurekaka" title="Content">🖋</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://about.me/li.su"><img src="https://avatars.githubusercontent.com/u/528332?v=4?s=100" width="100px;" alt=""/><br /><sub><b>lysu</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Alysu" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/cfzjywxk"><img src="https://avatars.githubusercontent.com/u/3692139?v=4?s=100" width="100px;" alt=""/><br /><sub><b>cfzjywxk</b></sub></a><br /><a href="index.html#content-cfzjywxk" title="Content">🖋</a> <a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Acfzjywxk" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://blog.tongmu.me"><img src="https://avatars.githubusercontent.com/u/9587680?v=4?s=100" width="100px;" alt=""/><br /><sub><b>you06</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Ayou06" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/ekexium"><img src="https://avatars.githubusercontent.com/u/31720476?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ziqian Qin</b></sub></a><br /><a href="https://github.com/pingcap/tidb-dev-guide/pulls?q=is%3Apr+reviewed-by%3Aekexium" title="Reviewed Pull Requests">👀</a></td>
    <td align="center"><a href="https://github.com/zhangyangyu"><img src="https://avatars.githubusercontent.com/u/3690895?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Xiang Zhang</b></sub></a><br /><a href="index.html#content-zhangyangyu" title="Content">🖋</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/XuHuaiyu"><img src="https://avatars.githubusercontent.com/u/9039012?v=4?s=100" width="100px;" alt=""/><br /><sub><b>HuaiyuXu</b></sub></a><br /><a href="index.html#content-XuHuaiyu" title="Content">🖋</a></td>
    <td align="center"><a href="https://sticnarf.me"><img src="https://avatars.githubusercontent.com/u/17217495?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yilin Chen</b></sub></a><br /><a href="index.html#content-sticnarf" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/tangenta"><img src="https://avatars.githubusercontent.com/u/24713065?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tangenta</b></sub></a><br /><a href="index.html#content-tangenta" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/wshwsh12"><img src="https://avatars.githubusercontent.com/u/14054293?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Shenghui Wu</b></sub></a><br /><a href="index.html#content-wshwsh12" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/winoros"><img src="https://avatars.githubusercontent.com/u/7846227?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yiding Cui</b></sub></a><br /><a href="index.html#content-winoros" title="Content">🖋</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/MyonKeminta"><img src="https://avatars.githubusercontent.com/u/9948422?v=4?s=100" width="100px;" alt=""/><br /><sub><b>MyonKeminta</b></sub></a><br /><a href="index.html#content-MyonKeminta" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/mengxin9014"><img src="https://avatars.githubusercontent.com/u/22741979?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Meng Xin</b></sub></a><br /><a href="index.html#content-mengxin9014" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/Mini256"><img src="https://avatars.githubusercontent.com/u/5086433?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Mini256</b></sub></a><br /><a href="index.html#content-Mini256" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/qw4990"><img src="https://avatars.githubusercontent.com/u/7499936?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yuanjia Zhang</b></sub></a><br /><a href="index.html#content-qw4990" title="Content">🖋</a></td>
    <td align="center"><a href="https://github.com/yahonda"><img src="https://avatars.githubusercontent.com/u/73684?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Yasuo Honda</b></sub></a><br /><a href="index.html#content-yahonda" title="Content">🖋</a></td>
  </tr>
</table>
<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->
<p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="get-started"><a class="header" href="#get-started">Get Started</a></h1>
<p>Let's start your TiDB journey! There's a lot to learn, but every journey starts somewhere. In this chapter, we'll discuss:</p>
<ul>
<li><a href="get-started/install-golang.html">Install Golang</a></li>
<li><a href="get-started/build-tidb-from-source.html">Get the code, build and run</a></li>
<li><a href="get-started/setup-an-ide.html">Setup an IDE</a></li>
<li><a href="get-started/write-and-run-unit-tests.html">Write and run unit tests</a></li>
<li><a href="get-started/debug-and-profile.html">Debug and profile</a></li>
<li><a href="get-started/commit-code-and-submit-a-pull-request.html">Commit code and submit a pull request</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="install-golang"><a class="header" href="#install-golang">Install Golang</a></h1>
<p>To build TiDB from source code, you need to install Go in your development environment first. If Go is not installed yet, you can follow the instructions in this document for installation.</p>
<h2 id="install-go-119"><a class="header" href="#install-go-119">Install Go 1.19</a></h2>
<p>Currently, TiDB uses Go 1.19 to compile the code. To install Go 1.19, go to <a href="https://golang.org/dl/">Go's download page</a>, choose version 1.19, and then follow the <a href="https://golang.org/doc/install">installation instructions</a>.</p>
<h2 id="manage-the-go-toolchain-using-gvm"><a class="header" href="#manage-the-go-toolchain-using-gvm">Manage the Go toolchain using gvm</a></h2>
<p>If you are using Linux or MacOS, you can manage Go versions with <a href="https://github.com/moovweb/gvm">Go Version Manager (gvm)</a> easily.</p>
<p>To install gvm, run the following command:</p>
<pre><code class="language-bash">curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer | sh
</code></pre>
<p>Once you have gvm installed, you can use it to manage multiple different Go compilers with different versions. Let's install Go 1.19 and set it as default:</p>
<pre><code class="language-bash">gvm install go1.19
gvm use go1.19 --default
</code></pre>
<p>Now, you can type <code>go version</code> in the shell to verify the installation:</p>
<pre><code class="language-bash">go version
# OUTPUT:
# go version go1.19 linux/amd64
</code></pre>
<p>In the next chapter, you will learn how to obtain the TiDB source code and how to build it.</p>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="get-the-code-build-and-run"><a class="header" href="#get-the-code-build-and-run">Get the code, build, and run</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><code>git</code>: The TiDB source code is hosted on GitHub as a git repository. To work with the git repository, please <a href="https://git-scm.com/downloads">install <code>git</code></a>.</li>
<li><code>go</code>: TiDB is a Go project. Therefore, you need a working Go environment to build it. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li><code>gcc</code>: <code>gcc</code> command is required to use <code>cgo</code> while building. To install <code>gcc</code>, search for appropriate install guide for your OS.</li>
<li><code>mysql</code> client (optional): After building TiDB from source, you can use the official <a href="https://dev.mysql.com/downloads/mysql/">MySQL client</a> to connect to TiDB. It is not required if you want to build TiDB only.</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
<p>TiDB could compile and run on Windows 10. However, it is not expected to be deployed on Windows, where you might encounter many compatibility problems. To have a better experience, we recommend you <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">install WSL2</a> first.</p>
</blockquote>
<h2 id="clone"><a class="header" href="#clone">Clone</a></h2>
<p>Clone the source code to your development machine:</p>
<pre><code class="language-bash">git clone https://github.com/pingcap/tidb.git
</code></pre>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<p>Build TiDB from the source code:</p>
<pre><code class="language-bash">cd tidb
make
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Now that you have the <code>tidb-server</code> binary under the <code>bin</code> directory, execute it for a TiDB server instance:</p>
<pre><code class="language-bash">./bin/tidb-server
</code></pre>
<p>This starts the TiDB server listening on port 4000 with embedded <code>unistore</code>.</p>
<h2 id="connect"><a class="header" href="#connect">Connect</a></h2>
<p>You can use the official MySQL client to connect to TiDB:</p>
<pre><code class="language-bash">mysql -h 127.0.0.1 -P 4000 -u root -D test --prompt=&quot;tidb&gt; &quot; --comments
</code></pre>
<p>where</p>
<ul>
<li><code>-h 127.0.0.1</code> sets the Host to local host loopback interface</li>
<li><code>-P 4000</code> uses port 4000</li>
<li><code>-u root</code> connects as root user (<code>-p</code> not given; the development build has no password for root.)</li>
<li><code>-D test</code> uses the Schema/Database test</li>
<li><code>--prompt &quot;tidb&gt; &quot;</code> sets the prompt to distinguish it from a connection to MySQL</li>
<li><code>--comments</code> preserves comments like <code>/*T![clustered_index NONCLUSTERED */</code> instead of stripping them when sending the query to the server.</li>
</ul>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="setup-an-ide"><a class="header" href="#setup-an-ide">Setup an IDE</a></h1>
<p>Using an IDE is recommended as it makes it a lot easier to work with the TiDB code, for example to see the fields of a <code>struct</code>. However it is not required to use a specific IDE or editor. You can use the IDE or editor of your choice.</p>
<h2 id="goland"><a class="header" href="#goland">GoLand</a></h2>
<p>You can use <a href="https://www.jetbrains.com/go/">GoLand</a> to easily run or debug TiDB in many situations.</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li><code>go</code>: TiDB is a Go project. Therefore, you need a working Go environment to build it. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li>TiDB source code: See the previous <a href="get-started/build-tidb-from-source.html">Get the code, build and run</a> section to get the source code.</li>
</ul>
<h3 id="download-goland"><a class="header" href="#download-goland">Download GoLand</a></h3>
<p>Download GoLand from <a href="https://www.jetbrains.com/go/download">here</a> and install it.</p>
<h3 id="open-the-tidb-source-code-in-goland"><a class="header" href="#open-the-tidb-source-code-in-goland">Open the TiDB source code in GoLand</a></h3>
<p>Follow the <a href="https://www.jetbrains.com/help/go/quick-start-guide-goland.html#open-project">instructions</a> and open the  TiDB source code in GoLand.</p>
<p><img src="get-started/../img/open-tidb-in-goland.png" alt="Open TiDB source code in GoLand" /></p>
<h3 id="populate-run-configurations"><a class="header" href="#populate-run-configurations">Populate run configurations</a></h3>
<p>Under the root directory of the TiDB source code, execute the following commands to add config files:</p>
<pre><code class="language-bash">mkdir -p .idea/runConfigurations/ &amp;&amp; cd .idea/runConfigurations/

cat &lt;&lt;EOF &gt; unistore_4000.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;unistore 4000&quot; type=&quot;GoApplicationRunConfiguration&quot; factoryName=&quot;Go Application&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;kind value=&quot;PACKAGE&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb/tidb-server&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF

cat &lt;&lt;EOF &gt; playground_attach_4001.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;playground attach 4001&quot; type=&quot;GoApplicationRunConfiguration&quot; factoryName=&quot;Go Application&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;parameters value=&quot;--path=127.0.0.1:2379 --store=tikv --status=10081 -P 4001 &quot; /&gt;
    &lt;kind value=&quot;PACKAGE&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$/tidb-server/main.go&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb/tidb-server&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF

cat &lt;&lt;EOF &gt; unit_test.xml
&lt;component name=&quot;ProjectRunConfigurationManager&quot;&gt;
  &lt;configuration default=&quot;false&quot; name=&quot;unit test&quot; type=&quot;GoTestRunConfiguration&quot; factoryName=&quot;Go Test&quot;&gt;
    &lt;module name=&quot;tidb&quot; /&gt;
    &lt;working_directory value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;go_parameters value=&quot;-i&quot; /&gt;
    &lt;framework value=&quot;gocheck&quot; /&gt;
    &lt;kind value=&quot;DIRECTORY&quot; /&gt;
    &lt;package value=&quot;github.com/pingcap/tidb&quot; /&gt;
    &lt;directory value=&quot;\$PROJECT_DIR\$/planner/core&quot; /&gt;
    &lt;filePath value=&quot;\$PROJECT_DIR\$&quot; /&gt;
    &lt;pattern value=&quot;TestEnforceMPP&quot; /&gt;
    &lt;method v=&quot;2&quot; /&gt;
  &lt;/configuration&gt;
&lt;/component&gt;
EOF
</code></pre>
<p>Now, confirm there are three config files:</p>
<pre><code class="language-bash">ls
# OUTPUT:
# playground_attach_4001.xml
# unistore_4000.xml
# unit_test.xml
</code></pre>
<h3 id="run-or-debug"><a class="header" href="#run-or-debug">Run or debug</a></h3>
<p>Now you can see the run/debug configs right upper the window.</p>
<p><img src="get-started/../img/run-configs.png" alt="Run Configs" /></p>
<p>The first config is <code>unistore 4000</code>, which enables you to run/debug TiDB independently without TiKV, PD, and TiFlash.</p>
<p><img src="get-started/../img/unistore-config.png" alt="unistore config" /></p>
<p><img src="get-started/../img/unistore-output.png" alt="unistore output" /></p>
<p>The second config is <code>playground attach 4001</code>, which enables you to run/debug TiDB by attaching to an existing cluster; for example, a cluster deployed with <a href="https://docs.pingcap.com/tidb/stable/tiup-playground"><code>tiup playground</code></a>.</p>
<p>After the server process starts, you can connect to the origin TiDB by port 4000, or connect to your TiDB by port 4001 at the same time.</p>
<p><img src="get-started/../img/playground-attach-config.png" alt="playground attach config" />
<img src="get-started/../img/playground-attach-debug.png" alt="playground attach debug" /></p>
<p>The third config is <code>unit test</code>, which enables you to run/debug unit tests. You may modify the <code>Directory</code> and <code>Pattern</code> to run other tests.</p>
<p><img src="get-started/../img/unit-test-config.png" alt="unit test config" />
<img src="get-started/../img/unit-test-output.png" alt="unit test output" /></p>
<p>If you encounter any problems during your journey, do not hesitate to reach out on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>VS Code is a generic IDE that has good extensions for working with Go and TiDB.</p>
<p><img src="get-started/../img/vscode_tide.png" alt="VS Code with TiDE" /></p>
<h3 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h3>
<ul>
<li><code>go</code>: TiDB is a Go project thus its building requires a working <code>go</code> environment. See the previous <a href="get-started/install-golang.html">Install Golang</a> section to prepare the environment.</li>
<li>TiDB source code: See the previous <a href="get-started/build-tidb-from-source.html">Get the code, build and run</a> section to get the source code.</li>
</ul>
<h3 id="download-vs-code"><a class="header" href="#download-vs-code">Download VS Code</a></h3>
<p>Download VS Code from <a href="https://code.visualstudio.com/Download">here</a> and install it.</p>
<p>Now install these extensions:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=golang.Go">Go</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=dragonly.ticode">TiDE</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=github.vscode-pull-request-github">GitHub Pull Requests and Issues</a></li>
</ul>
<h3 id="work-with-tidb-code-in-vs-code"><a class="header" href="#work-with-tidb-code-in-vs-code">Work with TiDB code in VS Code</a></h3>
<p>Open the folder containing TiDB code via <code>File→Open Folder</code>. See the <a href="https://code.visualstudio.com/docs">VS Code docs</a> for how to edit and commit code.</p>
<p>There is <a href="https://github.com/tidb-incubator/tide/blob/HEAD/doc/guide.md">detailed guide</a> explaining how to use the TiDE extension.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-and-run-unit-tests"><a class="header" href="#write-and-run-unit-tests">Write and run unit tests</a></h1>
<p>The TiDB project runs unit tests using <a href="https://github.com/stretchr/testify">testify</a>.</p>
<p>You may find tests using <a href="http://github.com/pingcap/check">pingcap/check</a> which is a fork of <a href="https://github.com/go-check/check">go-check/check</a>, but since that framework is poorly maintained, we are migrating to testify.</p>
<p>You can check the background and progress on the migration <a href="https://github.com/pingcap/tidb/issues/26022">tracking issue</a>.</p>
<h2 id="how-to-write-unit-tests"><a class="header" href="#how-to-write-unit-tests">How to write unit tests</a></h2>
<p>We use testify to write unit tests. Basically, it is out-of-the-box <a href="https://pkg.go.dev/testing">testing</a> with testify assertions.</p>
<h3 id="testmain"><a class="header" href="#testmain">TestMain</a></h3>
<p>When you run tests, Golang compiles each package along with any files with names with suffix <code>_test.go</code>. Thus, a test binary contains tests in a package.</p>
<p>Golang testing provides a mechanism to support doing extra setup or teardown before or after testing by writing a package level unique function:</p>
<pre><code class="language-go">func TestMain(m *testing.M)
</code></pre>
<p>After all tests finish, we leverage the function to detect Goroutine leaks by <a href="https://github.com/uber-go/goleak">goleak</a>.</p>
<p>Before you write any unit tests in a package, create a file named <code>main_test.go</code> and setup the scaffolding:</p>
<pre><code class="language-go">func TestMain(m *testing.M) {
    goleak.VerifyTestMain(m)
}
</code></pre>
<p>You can also put global variables or helper functions of the test binary in this file.</p>
<h3 id="assertion"><a class="header" href="#assertion">Assertion</a></h3>
<p>Let's write a basic test for the utility function <code>StrLenOfUint64Fast</code>:</p>
<pre><code class="language-go">func TestStrLenOfUint64Fast(t *testing.T) {
    for i := 0; i &lt; 1000000; i++ {
        num := rand.Uint64()
        expected := len(strconv.FormatUint(num, 10))
        actual := StrLenOfUint64Fast(num)
        require.Equal(t, expected, actual)
    }
}
</code></pre>
<p>Golang testing detects test functions from <code>*_test.go</code> files of the form:</p>
<pre><code class="language-go">func TestXxx(*testing.T)
</code></pre>
<p>where <code>Xxx</code> does not start with a lowercase letter. The function name identifies the test routine.</p>
<p>We follow this pattern but use testify assertions instead of out-of-the-box methods, like <code>Error</code> or <code>Fail</code>, since they are too low level to use.</p>
<p>We mostly use <code>require.Xxx</code> for assertions, which is imported from <code>github.com/stretchr/testify/require</code>. If the assertions fail, the test fails immediately, and we tend to fail tests fast.</p>
<p>Below are the most frequently used assertions:</p>
<pre><code class="language-go">func Equal(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{})
func EqualValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{})
func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{})
func Nil(t TestingT, object interface{}, msgAndArgs ...interface{})
func NoError(t TestingT, err error, msgAndArgs ...interface{})
func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{})
func True(t TestingT, value bool, msgAndArgs ...interface{})
</code></pre>
<p>You can find other assertions follow the <a href="https://pkg.go.dev/github.com/stretchr/testify/require">documentation</a>.</p>
<h3 id="parallel"><a class="header" href="#parallel">Parallel</a></h3>
<p>Golang testing provides a method of <code>testing.T</code> to run tests in parallel:</p>
<pre><code class="language-go">t.Parallel()
</code></pre>
<p>We leverage this function to run tests as parallel as possible, so that we make full use of the available resource.</p>
<p>When some tests should be run in serial, use Golang testing <a href="https://pkg.go.dev/testing#hdr-Subtests_and_Sub_benchmarks">subtests</a> and parallel the parent test only. In this way, tests in the same subtests set run in serial.</p>
<pre><code class="language-go">func TestParent(t *testing.T) {
    t.Parallel()
    // &lt;setup code&gt;
    t.Run(&quot;Serial 0&quot;, func(t *testing.T) { ... })
    t.Run(&quot;Serial 1&quot;, func(t *testing.T) { ... })
    t.Run(&quot;Serial 2&quot;, func(t *testing.T) { ... })
    // &lt;tear-down code&gt;
}
</code></pre>
<p>Generally, if a test modifies global configs or fail points, it should be run in serial.</p>
<p>When writing parallel tests, there are several common considerations.</p>
<p>In Golang, the loop iterator variable is a single variable that takes different value in each loop iteration. Thus, when you run this code it is highly possible to see the last element used for every iteration. You may use below paradigm to work around.</p>
<pre><code class="language-go">func TestParallelWithRange(t *testing.T) {
    for _, test := range tests {
        // copy iterator variable into a new variable, see issue #27779 in tidb repo
        test := test
        t.Run(test.Name, func(t *testing.T) {
            t.Parallel()
            ...
        })
    }
}
</code></pre>
<h3 id="test-kits"><a class="header" href="#test-kits">Test kits</a></h3>
<p>Most of our tests are much more complex than what we describe above. For example, to set up a test, we may create a mock storage, a mock session, or even a local database instance.</p>
<p>These functions are known as test kits. Some are used in one package so we implement them in place; others are quite common so we move it to the <code>testkit</code> directory.</p>
<p>When you write complex unit tests, you may take a look at what test kits we have now and try to leverage them. If we don’t have a test kit for your issue and your issue is considered common, add one.</p>
<h2 id="how-to-run-unit-tests"><a class="header" href="#how-to-run-unit-tests">How to run unit tests</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running all tests</a></h3>
<p>You can always run all tests by executing the <code>gotest</code> target in Makefile:</p>
<pre><code>make gotest
</code></pre>
<p>This is almost equivalent to <code>go test ./...</code> but it enables and disables fail points before and after running tests.</p>
<p><a href="https://github.com/pingcap/failpoint">pingcap/failpoint</a> is an implementation of <a href="https://www.freebsd.org/cgi/man.cgi?query=fail">failpoints</a> for Golang. A fail point is used to add code points where you can inject errors. Fail point is a code snippet that is only executed when the corresponding fail point is active.</p>
<h3 id="running-a-single-test"><a class="header" href="#running-a-single-test">Running a single test</a></h3>
<p>To run a single test, you can manually repeat what <code>make gotest</code> does and narrow the scope in one test or one package:</p>
<pre><code>make failpoint-enable
cd domain
go test -v -run TestSchemaValidator # or with any other test flags
cd ..
make failpoint-disable
</code></pre>
<p>or if it is an older test not using testify</p>
<pre><code>make failpoint-enable
(cd planner/core ; go test -v -run &quot;^TestT$&quot; -check.f TestBinaryOpFunction )
make failpoint-disable
</code></pre>
<p>If one want to compile the test into a debug binary for running in a debugger, one can also use <code>go test -gcflags=&quot;all=-N -l&quot; -o ./t</code>, which removes any optimisations and outputs a <code>t</code> binary file ready to be used, like <code>dlv exec ./t</code> or combine it with the above to only debug a single test <code>dlv exec ./t -- -test.run &quot;^TestT$&quot; -check.f TestBinaryOpFunction</code>.</p>
<p>Notice there is also an <code>ut</code> utility for running tests, see <code>Makefile</code> and <code>tools/bin/ut</code>.</p>
<p>To display information on all the test flags, enter <code>go help testflag</code>.</p>
<p>If you develop with GoLand, you can also run a test from the IDE with manually enabled and disabled fail points. See the <a href="https://www.jetbrains.com/help/go/performing-tests.html">documentation</a> for details.</p>
<p><img src="get-started/../img/goland-run-tests.png" alt="GoLand Run Tests" /></p>
<p>As shown above, you can run tests of the whole package, of a test, or of a subtest, by click the corresponding gutter icon.</p>
<p>If you develop with VS Code, you can also run a test from the editor with manually enabled and disabled fail points. See the <a href="https://code.visualstudio.com/docs/languages/go#_test">documentation</a> for details.</p>
<p><img src="get-started/../img/vscode-run-tests.png" alt="VS Code Run Tests" /></p>
<p>As shown above, you can run tests of the whole package, of a test, or of a file.</p>
<h3 id="running-tests-for-a-pull-request"><a class="header" href="#running-tests-for-a-pull-request">Running tests for a pull request</a></h3>
<blockquote>
<p>If you haven't joined the organization, you should wait for a member to comment with <code>/ok-to-test</code> to your pull request.</p>
</blockquote>
<p>Before you merge a pull request, it must pass all tests.</p>
<p>Generally, continuous integration (CI) runs the tests for you; however, if you want to run tests with conditions or rerun tests on failure, you should know how to do that, the the rerun guide comment will be sent when the CI tests failed.</p>
<h4 id="retest"><a class="header" href="#retest"><code>/retest</code></a></h4>
<p>Rerun all failed CI test cases. </p>
<h4 id="test-test1-testn"><a class="header" href="#test-test1-testn"><code>/test {{test1}} {{testN}}</code></a></h4>
<p>Run given CI failed tests.</p>
<h4 id="ci-parameters"><a class="header" href="#ci-parameters">CI parameters</a></h4>
<p>CI jobs accepts the following parameters passed from <strong>pull request title</strong>:</p>
<p>format: <code>&lt;origin pr title&gt; | &lt;the CI args pairs&gt;</code></p>
<p>CI args pairs:</p>
<ul>
<li><code>tikv=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tikv to use.</li>
<li><code>pd=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which pd to use.</li>
<li><code>tidb-test=&lt;branch&gt;|&lt;pr/$num&gt;</code> specifies which tidb-test to use.</li>
</ul>
<p>For example:</p>
<pre><code>pkg1: support xxx feature | tidb-test=pr/1234
pkg2: support yyy feature | tidb-test=release-6.5 tikv=pr/999
</code></pre>
<h2 id="how-to-find-failed-tests"><a class="header" href="#how-to-find-failed-tests">How to find failed tests</a></h2>
<p>There are several common causes of failed tests.</p>
<h3 id="assertion-failed"><a class="header" href="#assertion-failed">Assertion failed</a></h3>
<p>The most common cause of failed tests is that assertion failed. Its failure report looks like:</p>
<pre><code>=== RUN   TestTopology
    info_test.go:72: 
            Error Trace:    info_test.go:72
            Error:          Not equal: 
                            expected: 1282967700000
                            actual  : 1628585893
            Test:           TestTopology
--- FAIL: TestTopology (0.76s)
</code></pre>
<p>To find this type of failure, enter <code>grep -i &quot;FAIL&quot;</code> to search the report output.</p>
<h3 id="data-race"><a class="header" href="#data-race">Data race</a></h3>
<p>Golang testing supports detecting data race by running tests with the <code>-race</code> flag. Its failure report looks like:</p>
<pre><code>[2021-06-21T15:36:38.766Z] ==================
[2021-06-21T15:36:38.766Z] WARNING: DATA RACE
[2021-06-21T15:36:38.766Z] Read at 0x00c0055ce380 by goroutine 108:
...
[2021-06-21T15:36:38.766Z] Previous write at 0x00c0055ce380 by goroutine 169:
[2021-06-21T15:36:38.766Z]   [failed to restore the stack]
</code></pre>
<h3 id="goroutine-leak"><a class="header" href="#goroutine-leak">Goroutine leak</a></h3>
<p>We use goleak to detect goroutine leak for tests. Its failure report looks like:</p>
<pre><code>goleak: Errors on successful test run: found unexpected goroutines:
[Goroutine 104 in state chan receive, with go.etcd.io/etcd/pkg/logutil.(*MergeLogger).outputLoop on top of the stack:
goroutine 104 [chan receive]:
go.etcd.io/etcd/pkg/logutil.(*MergeLogger).outputLoop(0xc000197398)
    /go/pkg/mod/go.etcd.io/etcd@v0.5.0-alpha.5.0.20200824191128-ae9734ed278b/pkg/logutil/merge_logger.go:173 +0x3ac
created by go.etcd.io/etcd/pkg/logutil.NewMergeLogger
    /go/pkg/mod/go.etcd.io/etcd@v0.5.0-alpha.5.0.20200824191128-ae9734ed278b/pkg/logutil/merge_logger.go:91 +0x85

</code></pre>
<p>To  determine the source of package leaks, see the <a href="https://github.com/uber-go/goleak/#determine-source-of-package-leaks">documentation</a></p>
<h3 id="timeout"><a class="header" href="#timeout">Timeout</a></h3>
<p>After @tiancaiamao introduced the timeout checker for continuous integration, every test case should run in at most five seconds.</p>
<p>If a test case takes longer, its failure report looks like:</p>
<pre><code>[2021-08-09T03:33:57.661Z] The following test cases take too long to finish:
[2021-08-09T03:33:57.661Z] PASS: tidb_test.go:874: tidbTestSerialSuite.TestTLS  7.388s
[2021-08-09T03:33:57.661Z] --- PASS: TestCluster (5.20s)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debug-and-profile"><a class="header" href="#debug-and-profile">Debug and profile</a></h1>
<p>In this section, you will learn:</p>
<ul>
<li>How to debug TiDB</li>
<li>How to pause the execution at any line of code to inspect values and stacks</li>
<li>How to profile TiDB to catch a performance bottleneck</li>
</ul>
<h2 id="use-delve-for-debugging"><a class="header" href="#use-delve-for-debugging">Use delve for debugging</a></h2>
<p><a href="https://github.com/go-delve/delve">Delve</a> is a debugger for the Go programming language. It provides a command-line debugging experience similar to the GNU Project debugger (GDB), but it is much more Go native than GDB itself.</p>
<h3 id="install-delve"><a class="header" href="#install-delve">Install delve</a></h3>
<p>To install delve, see the <a href="https://github.com/go-delve/delve/tree/master/Documentation/installation">installation guide</a>. After the installation, depending on how you set your environment variables, you will have an executable file named <code>dlv</code> in either <code>$GOPATH/bin</code> or <code>$HOME/go/bin</code>. You can then run the following command to verify the installation:</p>
<pre><code>$ dlv version
Delve Debugger
Version: 1.5.0
Build: $Id: ca5318932770ca063fc9885b4764c30bfaf8a199 $
</code></pre>
<h3 id="attach-delve-to-a-running-tidb-process"><a class="header" href="#attach-delve-to-a-running-tidb-process">Attach delve to a running TiDB process</a></h3>
<p>Once you get the TiDB server running, you can attach the delve debugger.</p>
<p>For example, you can build and run a standalone TiDB server by running the following commands in the root directory of the source code:</p>
<pre><code class="language-bash">make server
./bin/tidb-server
</code></pre>
<p>You can then start a new shell and use <code>ps</code> or <code>pgrep</code> to find the PID of the tidb server process you just started:</p>
<pre><code class="language-bash">pgrep tidb-server
# OUTPUT:
# 1394942
</code></pre>
<p>If the output lists multiple PIDs, it indicates that you might have multiple TiDB servers running at the same time. To determine the PID of the tidb server you are planning to debug, you can use commands such as <code>ps $PID</code>, where <code>$PID</code> is the PID you are trying to know more about:</p>
<pre><code class="language-bash">ps 1394942
# OUTPUT:
#     PID TTY      STAT   TIME COMMAND
# 1394942 pts/11   SNl    0:02 ./bin/tidb-server
</code></pre>
<p>Once you get the PID, you can attach delve to it by running the following command:</p>
<pre><code class="language-bash">dlv attach 1394942
</code></pre>
<p>You might get error messages of the kernel security setting as follows:</p>
<pre><code>Could not attach to pid 1394942: this could be caused by a kernel security setting, try writing &quot;0&quot; to /proc/sys/kernel/yama/ptrace_scope
</code></pre>
<p>To resolve the error, follow the instructions provided in the error message and execute the following command as the root user to override the kernel security setting:</p>
<pre><code class="language-bash">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope
</code></pre>
<p>Then retry attaching delve onto the PID, and it should work.</p>
<p>If you've worked with GDB, the delve debugging interface will look familiar to you. It is an interactive dialogue that allows you to interact with the execution of the tidb server attached on. To learn more about delve, you can type help into the dialogue and read the <code>help</code> messages.</p>
<h3 id="use-delve-for-debugging-1"><a class="header" href="#use-delve-for-debugging-1">Use delve for debugging</a></h3>
<p>After attaching delve to the running TiDB server process, you can now set breakpoints. TiDB server will pause execution at the breakpoints you specify.</p>
<p>To create a breakpoint, you can write:</p>
<pre><code>break [name] &lt;linespec&gt;
</code></pre>
<p>where <code>[name]</code> is the name for the breakpoint, and <code>&lt;linespec&gt;</code> is the position of a line of code in the source code. Note the name is optional.</p>
<p>For example, the following command creates a breakpoint at the <code>Next</code> function of <code>HashJoinExec</code>. (The line number can be subject to change due to the modification of the source code).</p>
<pre><code class="language-bash">dlv debug tidb-server/main.go
# OUTPUT:
# Type 'help' for list of commands.
# (dlv) break executor/join.go:653
# Breakpoint 1 (enabled) set at 0x36752d8 for github.com/pingcap/tidb/executor.(*HashJoinExec).Next() ./executor/join.go:653
# (dlv)
</code></pre>
<p>Once the execution is paused, the context of the execution is fully preserved. You are free to inspect the values of different variables, print the calling stack, and even jump between different goroutines. Once you finish the inspection, you can resume the execution by stepping into the next line of code or continue the execution until the next breakpoint is encountered.</p>
<p>Typically, when you use a debugger, you need to take the following steps:</p>
<ol>
<li>Locate the code and set a breakpoint.</li>
<li>Prepare data so that the execution will get through the breakpoint, and pause at the specified breakpoint as expected.</li>
<li>Inspect values and follow the execution step by step.</li>
</ol>
<h3 id="using-delve-to-debug-a-test-case"><a class="header" href="#using-delve-to-debug-a-test-case">Using delve to debug a test case</a></h3>
<p>If a test case fails, you can also use delve to debug it. Get the name of the test case, go to the corresponding package directory, and then run the following command to start a debugging session that will stop at the entry of the test:</p>
<pre><code>dlv test -- -run TestName
</code></pre>
<h3 id="understand-how-tidb-works-through-debugging"><a class="header" href="#understand-how-tidb-works-through-debugging">Understand how TiDB works through debugging</a></h3>
<p>Besides debugging problems, you can also use the debugger to understand how TiDB works through tracking the execution step by step.</p>
<p>To understand TiDB internals, it's critical that you understand certain functions. To better understand how TiDB works, you can pause the execution of these TiDB functions, and then run TiDB step by step.</p>
<p>For example:</p>
<ol>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/executor/compiler.go#L48"><code>executor/compiler.go:Compile</code></a> is where each SQL statement is compiled and optimized.</li>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/planner/optimize.go#L80"><code>planner/planner.go:Optimize</code></a> is where the SQL optimization starts.</li>
<li><a href="https://github.com/pingcap/tidb/blob/5c95062cc34d6d37e2e921f9bddba6205b43ee3a/executor/adapter.go#L312"><code>executor/adapter.go:ExecStmt.Exec</code></a> is where the SQL plan turns into executor and where the SQL execution starts.</li>
<li>Each executor's <code>Open</code>, <code>Next</code>, and <code>Close</code> function marks the volcano-style execution logic.</li>
</ol>
<p>When you are reading the TiDB source code, you are strongly encouraged to set a breakpoint and use the debugger to trace the execution whenever you are confused or uncertain about the code.</p>
<h2 id="using-pprof-for-profiling"><a class="header" href="#using-pprof-for-profiling">Using <code>pprof</code> for profiling</a></h2>
<p>For any database system, performance is always important. If you want to know where the performance bottleneck is, you can use a powerful Go profiling tool called <code>pprof</code>.</p>
<h3 id="gather-runtime-profiling-information-through-http-end-points"><a class="header" href="#gather-runtime-profiling-information-through-http-end-points">Gather runtime profiling information through HTTP end points</a></h3>
<p>Usually, when TiDB server is running, it exposes a profiling end point through HTTP at <code>http://127.0.0.1:10080/debug/pprof/profile</code>. You can get the profile result by running the following commands:</p>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/profile?seconds=45&quot; &gt; profile.profile
go tool pprof -http 127.0.0.1:4001 profile.profile
</code></pre>
<p>The commands capture the profiling information for 45 seconds, and then provide a web view of the profiling result at <code>127.0.0.1:4001</code>. This view contains a <a href="http://www.brendangregg.com/flamegraphs.html">flame graph</a> of the execution and more views that can help you diagnose the performance bottleneck.</p>
<p>You can also gather other runtime information through this end point. For example:</p>
<ul>
<li>Goroutine:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/goroutine&quot; &gt; goroutine.profile
</code></pre>
<ul>
<li>Trace:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/trace?seconds=3&quot; &gt; trace.profile
go tool trace -http 127.0.0.1:4001 trace.profile
</code></pre>
<ul>
<li>Heap:</li>
</ul>
<pre><code class="language-bash">curl -G &quot;127.0.0.1:10080/debug/pprof/heap&quot; &gt; heap.profile
go tool pprof -http 127.0.0.1:4001 heap.profile
</code></pre>
<p>To learn how the runtime information is analyzed, see Go's <a href="https://golang.org/doc/diagnostics">diagnostics document</a>.</p>
<h3 id="profiling-during-benchmarking"><a class="header" href="#profiling-during-benchmarking">Profiling during benchmarking</a></h3>
<p>When you are proposing a performance-related feature for TiDB, we recommend that you also include a benchmark result as proof of the performance gain or to show that your code won't introduce any performance regression. In this case, you need to write your own benchmark test like in <code>executor/benchmark.go</code>.</p>
<p>For example, if you want to benchmark the window functions, because <code>BenchmarkWindow</code> are already in the benchmark tests, you can run the following commands to get the benchmark result:</p>
<pre><code class="language-bash">cd executor
go test -bench BenchmarkWindow -run BenchmarkWindow -benchmem
</code></pre>
<p>If you find any performance regression, and you want to know the cause of it, you could use a command like the following:</p>
<pre><code class="language-bash">go test -bench BenchmarkWindow -run BenchmarkWindow -benchmem -memprofile memprofile.out -cpuprofile profile.out
</code></pre>
<p>Then, you can use the steps described above to generate and analyze the profiling information.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="commit-the-code-and-submit-a-pull-request"><a class="header" href="#commit-the-code-and-submit-a-pull-request">Commit the code and submit a pull request</a></h1>
<p>The TiDB project uses <a href="https://git-scm.com/">Git</a> to manage its source code. To contribute to the project, you need to get familiar with Git features so that your changes can be incorporated into the codebase.</p>
<p>This section addresses some of the most common questions and problems that new contributors might face. This section also covers some Git basics; however if you find that the content is a little difficult to understand, we recommend that you first read the following introductions to Git:</p>
<ul>
<li>The &quot;Beginner&quot; and &quot;Getting Started&quot; sections of <a href="https://www.atlassian.com/git/tutorials">this tutorial</a> from Atlassian</li>
<li><a href="https://docs.github.com/en/github/getting-started-with-github/set-up-git">Documentation</a> and <a href="https://guides.github.com/introduction/git-handbook/">guides</a> for beginners from Github</li>
<li>A more in-depth <a href="https://git-scm.com/book/en/v2/">book</a> from Git</li>
</ul>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Before you create a pull request, make sure that you've installed Git, forked <a href="https://github.com/pingcap/tidb">pingcap/tidb</a>, and cloned the upstream repo to your PC. The following instructions use the command line interface to interact with Git; there are also several GUIs and IDE integrations that can interact with Git too.</p>
<p>If you've cloned the upstream repo, you can reference it using <code>origin</code> in your local repo. Next, you need to set up a remote for the repo your forked using the following command:</p>
<pre><code class="language-bash">git remote add dev https://github.com/your_github_id/tidb.git
</code></pre>
<p>You can check the remote setting using the following command:</p>
<pre><code class="language-bash">git remote -v
# dev    https://github.com/username/tidb.git (fetch)
# dev    https://github.com/username/tidb.git (push)
# origin    https://github.com/pingcap/tidb.git (fetch)
# origin    https://github.com/pingcap/tidb.git (push)
</code></pre>
<h2 id="standard-process"><a class="header" href="#standard-process">Standard Process</a></h2>
<p>The following is a normal procedure that you're likely to use for the most common minor changes and PRs:</p>
<ol>
<li>
<p>Ensure that you're making your changes on top of master and get the latest changes:</p>
<pre><code class="language-bash">git checkout master
git pull master
</code></pre>
</li>
<li>
<p>Create a new branch for your changes:</p>
<pre><code class="language-bash">git checkout -b my-changes
</code></pre>
</li>
<li>
<p>Make some changes to the repo and test them.</p>
</li>
</ol>
<p>If the repo is buiding with <a href="https://bazel.build/">Bazel</a> tool, you should update the bazel files(*.bazel, DEPS.bzl) also.</p>
<ol start="4">
<li>
<p>Commit your changes and push them to your <code>dev</code> remote repository:</p>
<pre><code class="language-bash"># stage files you created/changed/deleted
git add path/to/changed/file.go path/to/another/changed/file.go

# commit changes staged, make sure the commit message is meaningful and readable
git commit -s -m &quot;pkg, pkg2, pkg3: what's changed&quot;

# optionally use `git status` to check if the change set is correct
# git status

# push the change to your `dev` remote repository
git push --set-upstream dev my-changes
</code></pre>
</li>
<li>
<p>Make a PR from your fork to the master branch of pingcap/tidb. For more information on how to make a PR, see <a href="https://guides.github.com/activities/forking/#making-a-pull-request">Making a Pull Request</a> in GitHub Guides.</p>
</li>
</ol>
<p>When making a PR, look at the <a href="https://raw.githubusercontent.com/pingcap/tidb/master/.github/pull_request_template.md">PR template</a> and follow the commit message format, PR title format, and checklists.</p>
<p>After you create a PR, if your reviewer requests code changes, the procedure for making those changes is similar to that of making a PR, with some steps skipped:</p>
<ol>
<li>
<p>Switch to the branch that is the head and get the latest changes:</p>
<pre><code class="language-bash">git checkout my-changes
git pull
</code></pre>
</li>
<li>
<p>Make, stage, and commit your additional changes just like before.</p>
</li>
<li>
<p>Push those changes to your fork:</p>
<pre><code class="language-bash">git push
</code></pre>
</li>
</ol>
<p>If your reviewer requests for changes with GitHub suggestion, you can commit the suggestion from the webpage. GitHub provides <a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request#applying-suggested-changes">documentation</a> for this case.</p>
<h2 id="conflicts"><a class="header" href="#conflicts">Conflicts</a></h2>
<p>When you edit your code locally, you are making changes to the version of pingcap/tidb that existed when you created your feature branch. As such, when you submit your PR it is possible that some of the changes that have been made to pingcap/tidb since then conflict with the changes you've made.</p>
<p>When this happens, you need to resolve the conflicts before your changes can be merged. First, get a local copy of the conflicting changes: checkout your local master branch with <code>git checkout master</code>, then <code>git pull master</code> to update it with the most recent changes.</p>
<h3 id="rebasing"><a class="header" href="#rebasing">Rebasing</a></h3>
<p>You're now ready to start the rebasing process. Checkout the branch with your changes and execute <code>git rebase master</code>.</p>
<p>When you rebase a branch on master, all the changes on your branch are reapplied to the most recent version of master. In other words, Git tries to pretend that the changes you made to the old version of master were instead made to the new version of master. During this process, you should expect to encounter at least one &quot;rebase conflict.&quot; This happens when Git's attempt to reapply the changes fails because your changes conflict with other changes that have been made. You can tell that this happened because you'll see lines in the output that look like:</p>
<pre><code class="language-text">CONFLICT (content): Merge conflict in file.go
</code></pre>
<p>When you open these files, you'll see sections of the form</p>
<pre><code class="language-text">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Original code
=======
Your code
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8fbf656... Commit fixes 12345
</code></pre>
<p>This represents the lines in the file that Git could not figure out how to rebase. The section between <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> and <code>=======</code> has the code from master, while the other side has your version of the code. You'll need to decide how to deal with the conflict. You may want to keep your changes, keep the changes on master, or combine the two.</p>
<p>Generally, resolving the conflict consists of two steps: First, fix the particular conflict. Edit the file to make the changes you want and remove the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> lines in the process. Second, check the surrounding code. If there was a conflict, it's likely there are some logical errors lying around too!</p>
<p>Once you're all done fixing the conflicts, you need to stage the files that had conflicts in them via git add. Afterwards, run <code>git rebase --continue</code> to let Git know that you've resolved the conflicts and it should finish the rebase.</p>
<p>Once the rebase has succeeded, you'll want to update the associated branch on your fork with <code>git push --force-with-lease</code>.</p>
<h2 id="advanced-rebasing"><a class="header" href="#advanced-rebasing">Advanced rebasing</a></h2>
<p>If your branch contains multiple consecutive rewrites of the same code, or if the rebase conflicts are extremely severe, you can use <code>git rebase --interactive master</code> to gain more control over the process. This allows you to choose to skip commits, edit the commits that you do not skip, change the order in which they are applied, or &quot;squash&quot; them into each other.</p>
<p>Alternatively, you can sacrifice the commit history like this:</p>
<pre><code class="language-bash"># squash all the changes into one commit so you only have to worry about conflicts once
git rebase -i $(git merge-base master HEAD)  # and squash all changes along the way
git rebase master
# fix all merge conflicts
git rebase --continue
</code></pre>
<p>Squashing commits into each other causes them to be merged into a single commit. Both the upside and downside of this is that it simplifies the history. On the one hand, you lose track of the steps in which changes were made, but the history becomes easier to work with.</p>
<p>You also may want to squash together just the last few commits, possibly because they only represent &quot;fixups&quot; and not real changes. For example, <code>git rebase --interactive HEAD~2</code> allows you to edit the two commits only.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-tidb"><a class="header" href="#contribute-to-tidb">Contribute to TiDB</a></h1>
<p>TiDB is developed by an open and friendly community. Everybody is cordially welcome to join the community and contribute to TiDB. We value all forms of contributions, including, but not limited to:</p>
<ul>
<li>Code reviewing of the existing patches</li>
<li>Documentation and usage examples</li>
<li>Community participation in forums and issues</li>
<li>Code readability and developer guide
<ul>
<li>We welcome contributions that add code comments and code refactor to improve readability</li>
<li>We also welcome contributions to docs to explain the design choices of the internal</li>
</ul>
</li>
<li>Test cases to make the codebase more robust</li>
<li>Tutorials, blog posts, talks that promote the project</li>
</ul>
<p>Here are guidelines for contributing to various aspect of the project:</p>
<ul>
<li><a href="contribute-to-tidb/community-guideline.html">Community Guideline</a></li>
<li><a href="contribute-to-tidb/report-an-issue.html">Report an Issue</a></li>
<li><a href="contribute-to-tidb/issue-triage.html">Issue Triage</a></li>
<li><a href="contribute-to-tidb/contribute-code.html">Contribute Code</a></li>
<li><a href="contribute-to-tidb/cherrypick-a-pr.html">Cherry-pick a Pull Request</a></li>
<li><a href="contribute-to-tidb/review-a-pr.html">Review a Pull Request</a></li>
<li><a href="contribute-to-tidb/make-a-proposal.html">Make a Proposal</a></li>
<li><a href="contribute-to-tidb/code-style-and-quality-guide.html">Code Style and Quality Guide</a></li>
<li><a href="contribute-to-tidb/write-document.html">Write Document</a></li>
<li><a href="contribute-to-tidb/contribute-to-tidb/release-notes-style-guide.html">Release Notes Language Style Guide</a></li>
<li><a href="contribute-to-tidb/committer-guide.html">Committer Guide</a></li>
<li><a href="contribute-to-tidb/miscellaneous-topics.html">Miscellaneous Topics</a></li>
</ul>
<p>Any other question? Reach out to the <a href="https://internals.tidb.io/">TiDB Internals forum</a> to get help!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="community-guideline"><a class="header" href="#community-guideline">Community Guideline</a></h1>
<p>TiDB community aims to provide harassment-free, welcome and friendly experience for everyone. The first and most important thing for any participant in the community is be friendly and respectful to others. Improper behaviors will be warned and punished.</p>
<p>We appreciate any contribution in any form to TiDB community. Thanks so much for your interest and enthusiasm on TiDB!</p>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>TiDB community refuses any kind of harmful behavior to the community or community members. Everyone should read our <a href="https://github.com/pingcap/community/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a> and keep proper behavior while participating in the community.</p>
<h2 id="governance"><a class="header" href="#governance">Governance</a></h2>
<p>TiDB development governs by two kind of groups:</p>
<ul>
<li><a href="https://github.com/pingcap/community/tree/master/toc">TOC</a>: TOC serves as the main bridge and channel for coordinating and information sharing across companies and organizations. It is the coordination center for solving problems in terms of resource mobilization, technical research and development direction in the current community and cooperative projects.</li>
<li><a href="https://github.com/pingcap/community/tree/master/teams">teams</a>: Teams are persistent open groups that focus on a part of the TiDB projects. A team has its reviewer, committer and maintainer, and owns one or more repositories. Team level decision making comes from its maintainers.</li>
</ul>
<p>A typical promoted path for a TiDB developer is from user to reviewer, then committer and maintainer, finally maybe a TOC member. But gaining more roles doesn't mean you have any privilege over other community members or even any right to control them. Everyone in TiDB community are equal and share the responsibility to collaborate constructively with other contributors, building a friendly community. The roles are a natural reward for your substantial contribution in TiDB development and provide you more rights in the development workflow to enhance your efficiency. Meanwhile, they request some additional responsibilities from you:</p>
<ul>
<li>Now that you are a member of team reviewers/committers/maintainers, you are representing the project and your fellow team members whenever you discuss TiDB with anyone. So please be a good person to defend the reputation of the team.</li>
<li>Committers/maintainers have the right to merge pull requests, so bear the additional responsibility of handling the consequences of accepting a change into the codebase or documentation. That includes reverting or fixing it if it causes problems as well as helping out the release manager in resolving any problems found during the pre-release testing cycle. While all contributors are free to help out with this part of the process, and it is most welcome when they do, the actual responsibility rests with the committers/maintainers that merged the change.</li>
<li>Reviewers/committers/maintainers also bear the primary responsibility for guiding contributors the right working procedure, like deciding when changes proposed on the issue tracker should be escalated to <a href="https://internals.tidb.io">internal.tidb.io</a> for wider discussion, as well as suggesting the use of the <a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB Design Documents</a> process to manage the design and justification of complex changes, or changes with a potentially significant impact on end users.</li>
</ul>
<p>There should be no blockers to contribute with no roles. It's totally fine for you to reject the promotion offer if you don't want to take the additional responsibilities or for any other reason. Besides, except for code or documentation contribution, any kind of contribution for the community is highly appreciated. Let's grow TiDB ecosystem through our contributions of this community.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="report-an-issue"><a class="header" href="#report-an-issue">Report an Issue</a></h1>
<p>If you think you have found an issue in TiDB, you can report it to the <a href="https://github.com/pingcap/tidb/issues">issue tracker</a>. If you would to like to report issues to TiDB documents or this development guide, they are in separate GitHub repositories, so you need to file issues to corresponding issue tracker, <a href="https://github.com/pingcap/docs/issues">TiDB document issue tracker</a> and <a href="https://github.com/pingcap/tidb-dev-guide/issues">TiDB Development Guide issue tracker</a>. Read <a href="contribute-to-tidb/write-document.html">Write Document</a> for more details.</p>
<h2 id="checking-if-an-issue-already-exists"><a class="header" href="#checking-if-an-issue-already-exists">Checking if an issue already exists</a></h2>
<p>The first step before filing an issue report is to see whether the problem has already been reported. You can <a href="https://docs.github.com/en/github/administering-a-repository/finding-information-in-a-repository/using-search-to-filter-issues-and-pull-requests">use the search bar to search existing issues</a>. This doesn't always work, and sometimes it's hard to know what to search for, so consider this extra credit. We won't mind if you accidentally file a duplicate report. Don't blame yourself if your issue is closed as duplicated. We highly recommend if you are not sure about anything of your issue report, you can turn to <a href="https://internals.tidb.io">internal.tidb.io</a> for a wider audience and ask for discussion or help.</p>
<h2 id="filing-an-issue"><a class="header" href="#filing-an-issue">Filing an issue</a></h2>
<p>If the problem you're reporting is not already in the issue tracker, you can <a href="https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue">open a GitHub issue</a> with your GitHub account. TiDB uses issue template for different kinds of issues. Issue templates are a bundle of questions to collect necessary information about the problem to make it easy for other contributors to participate. For example, a bug report issue template consists of four questions:</p>
<ul>
<li>Minimal reproduce step.</li>
<li>What did you expect to see?</li>
<li>What did you see instead?</li>
<li>What is your TiDB version?</li>
</ul>
<p>Answering these questions give the details about your problem so other contributors or TiDB users could pick up your issue more easily. </p>
<p>As previous section shows, duplicated issues should be reduced. To help others who encountered the problem find your issue, except for problem details answered in the issue template, a descriptive title which contains information that might be unique to it also helps. This can be the components your issue belongs to or database features used in your issue, the conditions that trigger the bug, or part of the error message if there is any. </p>
<h2 id="making-good-issues"><a class="header" href="#making-good-issues">Making good issues</a></h2>
<p>Except for a good title and detailed issue message, you can also add suitable labels to your issue via <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#type">/label</a>, especially which component the issue belongs to and which versions the issue affects. Many committers and contributors only focus on certain subsystems of TiDB. Setting the appropriate component is important for getting their attention. Some issues might affect multiple releases. You can query <a href="contribute-to-tidb/issue-triage.html">Issue Triage chapter</a> for more information about what need to do with such issues.</p>
<p>If you are able to, you should take more considerations on your issue:</p>
<ul>
<li>Does the feature fit well into TiDB's architecture? Will it scale and keep TiDB flexible for the future, or will the feature restrict TiDB in the future?</li>
<li>Is the feature a significant new addition (rather than an improvement to an existing part)? If yes, will the community commit to maintaining this feature?</li>
<li>Does this feature align well with currently ongoing efforts?</li>
<li>Does the feature produce additional value for TiDB users or developers? Or does it introduce the risk of regression without adding relevant user or developer benefit?</li>
</ul>
<p>Deep thoughts could help the issue proceed faster and help build your own reputation in the community.</p>
<h2 id="understanding-the-issues-progress-and-status"><a class="header" href="#understanding-the-issues-progress-and-status">Understanding the issue's progress and status</a></h2>
<p>Once your issue is created, other contributors might take part in. You need to discuss with them, provide more information they might want to know, address their comments to reach consensus and make the progress proceeds. But please realize there are always more pending issues than contributors are able to handle, and especially TiDB community is a global one, contributors reside all over the world and they might already be very busy with their own work and life. Please be patient! If your issue gets stale for some time, it's okay to ping other participants, or take it to <a href="https://internals.tidb.io">internal.tidb.io</a> for more attention.</p>
<h2 id="disagreement-with-a-resolution-on-the-issue-tracker"><a class="header" href="#disagreement-with-a-resolution-on-the-issue-tracker">Disagreement with a resolution on the issue tracker</a></h2>
<p>As humans, we will have differences of opinions from time to time. First and foremost, please be respectful that care, thought, and volunteer time went into the resolution.</p>
<p>With this in mind, take some time to consider any comments made in association with the resolution of the issue. On reflection, the resolution steps may seem more reasonable than you initially thought.</p>
<p>If you still feel the resolution is incorrect, then raise a thoughtful question on <a href="https://internals.tidb.io">internal.tidb.io</a>. Further argument and disrespectful discourse on <a href="https://internals.tidb.io">internal.tidb.io</a> after a consensus has been reached amongst the committers is unlikely to win any converts.</p>
<h2 id="reporting-security-vulnerabilities"><a class="header" href="#reporting-security-vulnerabilities">Reporting security vulnerabilities</a></h2>
<p>Security issues are not suitable to report in public early, so different tracker strategy is used. Please refer to the <a href="https://github.com/pingcap/tidb/security/policy">dedicated process</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="issue-triage"><a class="header" href="#issue-triage">Issue Triage</a></h1>
<p>TiDB uses an issue-centric workflow for development. Every problem, enhancement and feature starts with an issue. For bug issues, you need to perform some more triage operations on the issues.</p>
<h2 id="diagnose-issue-severity"><a class="header" href="#diagnose-issue-severity">Diagnose issue severity</a></h2>
<p>The severity of a bug reflects the level of impact that the bug has on users when they use TiDB. The greater the impact, the higher severity the bug is. For higher severity bugs, we need to fix them faster. Although the impact of bugs can not be exhausted, they can be divided into four levels.</p>
<h3 id="critical"><a class="header" href="#critical">Critical</a></h3>
<p>The bug affects critical functionality or critical data. It might cause huge losses to users and does not have a workaround. Some typical critical bugs are as follows:</p>
<ul>
<li>Invalid query result (correctness issues)
<ul>
<li>TiDB returns incorrect results or results that are in the wrong order for a typical user-written query.</li>
<li>Bugs caused by type casts.</li>
<li>The parameters are not boundary value or invalid value, but the query result is not correct(except for overflow scenes).</li>
</ul>
</li>
<li>Incorrect DDL and DML result
<ul>
<li>The data is not written to the disk, or wrong data is written.</li>
<li>Data and index are inconsistent.</li>
</ul>
</li>
<li>Invalid features
<ul>
<li>Due to a regression, the feature can not work in its main workflow
<ul>
<li>Follower can not read follower.</li>
<li>SQL hint does not work.</li>
</ul>
</li>
<li>SQL Plan
<ul>
<li>Cannot choose the best index. The difference between best plan and chosen plan is bigger than 200%.</li>
</ul>
</li>
<li>DDL design
<ul>
<li>DDL process causes data accuracy issue.</li>
</ul>
</li>
<li>Experimental feature
<ul>
<li>If the issue leads to another stable feature’s main workflow not work, and may occur on released version, the severity is critical.</li>
<li>If the issue leads to data loss, the severity is critical.</li>
</ul>
</li>
<li>Exceptions
<ul>
<li>If the feature is clearly labeled as experimental, when it doesn’t work but doesn’t impact another stable feature’s main workflow or only impacts stable feature’s main workflow on master, the issue severity is major.</li>
<li>The feature has been deprecated and a viable workaround is available(at most major).</li>
</ul>
</li>
</ul>
</li>
<li>System stability
<ul>
<li>The system is unavailable for more than 5 minutes(if there are some system errors, the timing starts from failure recovery).</li>
<li>Tools cannot perform replication between upstream and downstream for more than 1 minute if there are no system errors.</li>
<li>TiDB cannot perform the upgrade operation.</li>
<li>TPS/QPS dropped 25% without system errors or rolling upgrades.</li>
<li>Unexpected TiKV core dump or TiDB panic(process crashed).</li>
<li>System resource leak, include but not limit to memory leak and goroutine leak.</li>
<li>System fails to recover from crash.</li>
</ul>
</li>
<li>Security and compliance issues
<ul>
<li>CVSS score &gt;= 9.0.</li>
<li>TiDB leaks secure information to log files, or prints customer data when set to be desensitized.</li>
</ul>
</li>
<li>Backup or Recovery Issues
<ul>
<li>Failure to either backup or restore is always considered critical.</li>
</ul>
</li>
<li>Incompatible Issues
<ul>
<li>Syntax/compatibility issue affecting default install of tier 1 application(i.e. Wordpress).</li>
<li>The DML result is incompatible with MySQL.</li>
</ul>
</li>
<li>CI test case fail
<ul>
<li>Test cases which lead to CI failure and could always be reproduced.</li>
</ul>
</li>
<li>Bug location information
<ul>
<li>Key information is missing in ERROR level log.</li>
<li>No data is reported in monitor.</li>
</ul>
</li>
</ul>
<h3 id="major"><a class="header" href="#major">Major</a></h3>
<p>The bug affects major functionality. Some typical critical bugs are as follow:</p>
<ul>
<li>Invalid query result
<ul>
<li>The query gets the wrong result caused by overflow.</li>
<li>The query gets the wrong result in the corner case.
<ul>
<li>For boundary value, the processing logic in TiDB is inconsistent with MySQL.</li>
</ul>
</li>
<li>Inconsistent data precision.</li>
</ul>
</li>
<li>Incorrect DML or DDL result
<ul>
<li>Extra or wrong data is written to TiDB with a DML in a corner case.</li>
</ul>
</li>
<li>Invalid features
<ul>
<li>The corner case of the main workflow of the feature does not work.</li>
<li>The feature is experimental, but a main workflow does not work.</li>
<li>Incompatible issue of view functionality.</li>
<li>SQL Plan
<ul>
<li>Choose sub-optimal plan. The difference between best plan and chosen plan is bigger than 100% and less than 200%</li>
</ul>
</li>
</ul>
</li>
<li>System stability
<ul>
<li>TiDB panics but process does not exit.</li>
</ul>
</li>
<li>Less important security and compliance issues
<ul>
<li>CVSS score &gt;= 7.0</li>
</ul>
</li>
<li>Issues that affects critical functionality or critical data but rare to reproduce(can’t be reproduced in one week, and have no clear reproduce steps)</li>
<li>CI test cases fail
<ul>
<li>Test case is not stable.</li>
</ul>
</li>
<li>Bug location information
<ul>
<li>Key information is missing in WARN level log.</li>
<li>Data is not accurate in monitor.</li>
</ul>
</li>
</ul>
<h3 id="moderate"><a class="header" href="#moderate">Moderate</a></h3>
<ul>
<li>SQL Plan
<ul>
<li>Cannot get the best plan due to invalid statistics.</li>
</ul>
</li>
<li>Documentation issues</li>
<li>The bugs were caused by invalid parameters which rarely occurred in the product environment.</li>
<li>Security issues
<ul>
<li>CVSS score &gt;= 4.0</li>
</ul>
</li>
<li>Incompatible issues occurred on boundary value</li>
<li>Bug location information
<ul>
<li>Key information is missing in DEBUG/INFO level log.</li>
</ul>
</li>
</ul>
<h3 id="minor"><a class="header" href="#minor">Minor</a></h3>
<p>The bug does not affect functionality or data. It does not even need a workaround. It does not impact productivity or efficiency. It is merely an inconvenience. For example:</p>
<ul>
<li>Invalid notification</li>
<li>Minor compatibility issues
<ul>
<li>Error message or error code does not match MySQL.</li>
<li>Issues caused by invalid parameters or abnormal cases.</li>
</ul>
</li>
</ul>
<h3 id="not-a-bug"><a class="header" href="#not-a-bug">Not a bug</a></h3>
<p>The following issues look like bugs but actually not. They should not be labeled <code>type/bug</code> and instead be only labeled <code>type/compatibility</code>:</p>
<ul>
<li>Behavior is different from MySQL, but could be argued as correct.</li>
<li>Behavior is different from MySQL, but MySQL behavior differs between 5.7 and 8.0.</li>
</ul>
<h2 id="identify-issue-affected-releases"><a class="header" href="#identify-issue-affected-releases">Identify issue affected releases</a></h2>
<p>For <code>type/bug</code> issues, when they are created and identified as <code>severity/critical</code> or <code>severity/major</code>, the ti-chi-bot will assign a list of <code>may-affects-x.y</code> labels to the issue. For example, currently if we have version 5.0, 5.1, 5.2, 5.3, 4.0 and the in-sprint 5.4, when a <code>type/bug</code> issue is created and added label <code>severity/critical</code> or <code>severity/major</code>, the ti-chi-bot will add label <code>may-affects-4.0</code>, <code>may-affects-5.0</code>, <code>may-affects-5.1</code>, <code>may-affects-5.2</code>, and <code>may-affects-5.3</code>. These labels mean that whether the bug affects these release versions are not yet determined, and is awaiting being triaged. You could check <a href="https://pingcap.github.io/tidb-dev-guide/project-management/release-train-model.html#current-maintained-releases">currently maintained releases list</a> for all releases.</p>
<p>When a version is triaged, the triager needs to remove the corresponding <code>may-affects-x.y</code> label. If the version is affected, the triager needs to add a corresponding <code>affects-x.y</code> label to the issue and in the meanwhile the <code>may-affects-x.y</code> label can be automatically removed by the ti-chi-bot, otherwise the triager can simply remove the <code>may-affects-x.y</code> label. So when a issue has a label <code>may-affects-x.y</code>, this means the issue has not been diagnosed on version x.y. When a issue has a label <code>affects-x.y</code>, this means the issue has been diagnosed on version x.y and identified affected. When both the two labels are missing, this means the issue has been diagnosed on version x.y but the version is not affected.</p>
<p>The status of the affection of a certain issue can be then determined by the combination of the existence of the corresponding <code>may-affects-x.y</code> and <code>affects-x.y</code> labels on the issue, see the table below for a clearer illustration.</p>
<table><thead><tr><th align="center">may-affects-x.y</th><th align="center">affects-x.y</th><th align="center">status</th></tr></thead><tbody>
<tr><td align="center">YES</td><td align="center">NO</td><td align="center">version x.y has not been diagnosed</td></tr>
<tr><td align="center">NO</td><td align="center">NO</td><td align="center">version x.y has been diagnosed and identified as not affected</td></tr>
<tr><td align="center">NO</td><td align="center">YES</td><td align="center">version x.y has been diagnosed and identified as affected</td></tr>
<tr><td align="center">YES</td><td align="center">YES</td><td align="center">invalid status</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contribute-code"><a class="header" href="#contribute-code">Contribute Code</a></h1>
<p>TiDB is maintained, improved, and extended by code contributions. We welcome code contributions to TiDB. TiDB uses a workflow based on <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests">pull requests</a>.</p>
<h2 id="before-contributing"><a class="header" href="#before-contributing">Before contributing</a></h2>
<p>Contributing to TiDB does <em>not</em> start with opening a pull request. We expect contributors to reach out to us first to discuss the overall approach together. Without consensus with the TiDB committers, contributions might require substantial rework or will not be reviewed. So please <a href="contribute-to-tidb/report-an-issue.html">create a GitHub issue</a>, discuss under an existing issue, or create a topic on the <a href="https://internals.tidb.io">internal.tidb.io</a> and reach consensus.</p>
<p>For newcomers, you can check the <a href="https://github.com/pingcap/tidb/contribute">starter issues</a>, which are annotated with a &quot;good first issue&quot; label. These are issues suitable for new contributors to work with and won't take long to fix. But because the label is typically added at triage time it can turn out to be inaccurate, so do feel free to leave a comment if you think the classification no longer applies.</p>
<p>To get your change merged you need to sign the <a href="https://cla-assistant.io/pingcap/tidb">CLA</a> to grant PingCAP ownership of your code.</p>
<h2 id="contributing-process"><a class="header" href="#contributing-process">Contributing process</a></h2>
<p>After a consensus is reached in issues, it's time to start the code contributing process:</p>
<ol>
<li>Assign the issue to yourself via <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#assign">/assign</a>. This lets other contributors know you are working on the issue so they won't make duplicate efforts.</li>
<li>Follow the <a href="https://guides.github.com/introduction/flow/">GitHub workflow</a>, commit code changes in your own git repository branch and open a pull request for code review.</li>
<li>Make sure the continuous integration checks on your pull request are green (i.e. successful).</li>
<li>Review and address <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request">comments on your pull request</a>. If your pull request becomes outdated with the target branch, you need to <a href="https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request#perform-a-rebase">rebase your pull request</a> to keep it up to date. Since TiDB uses <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/about-merge-methods-on-github#squashing-your-merge-commits">squash and merge</a>, simply merging master to catch up the change is also acceptable.</li>
<li>When your pull request gets enough approvals (the default number is 2) and all other requirements are met, it will be merged.</li>
<li>Handle regressions introduced by your change. Although committers bear the main responsibility to fix regressions, it's quite nice for you to handle it (reverting the change or sending fixes).</li>
</ol>
<p>Clear and kind communication is key to this process.</p>
<h2 id="referring-to-an-issue"><a class="header" href="#referring-to-an-issue">Referring to an issue</a></h2>
<p>Code repositories in TiDB community require <strong>ALL</strong> the pull requests referring to its corresponding issues. In the pull request body, there <strong>MUST</strong> be one line starting with <code>Issue Number: </code> and linking the relevant issues via the <a href="https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword">keyword</a>, for example:</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code>Issue Number: close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code>Issue Number: ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code>Issue Number: close #123, ref #456
</code></pre>
<p>For pull requests trying to close issues in a different repository, contributors need to first create an issue in the same repository and use this issue to track.</p>
<p>If the pull request body does not provide the required content, the bot will add the <code>do-not-merge/needs-linked-issue</code> label to the pull request to prevent it from being merged.</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>One important thing when you make code contributions to TiDB is tests. Tests should be always considered as a part of your change. Any code changes that cause semantic changes or new function additions to TiDB should have corresponding test cases. And of course you can not break any existing test cases if they are still valid. It's recommended to <a href="contribute-to-tidb/../get-started/write-and-run-unit-tests.html">run tests</a> on your local environment first to find obvious problems and fix them before opening the pull request.</p>
<p>It's also highly appreciated if your pull request only contains test cases to increase test coverage of TiDB. Supplement test cases for existing modules is a good and easy way to become acquainted with existing code.</p>
<h2 id="making-good-pull-requests"><a class="header" href="#making-good-pull-requests">Making good pull requests</a></h2>
<p>When creating a pull request for submission, there are several things that you should consider to help ensure that your pull request is accepted:</p>
<ul>
<li>Does the contribution alter the behavior of features or components in a way that it may break previous users' programs and setups? If yes, there needs to be a discussion and agreement that this change is desirable.</li>
<li>Does the contribution conceptually fit well into TiDB? Is it too much of a special case such that it makes things more complicated for the common case, or bloats the abstractions/APIs?</li>
<li>Does the contribution make a big impact on TiDB's build time?</li>
<li>Does your contribution affect any documentation? If yes, you should add/change proper documentation. </li>
<li>If there are any new dependencies, are they under active maintenances? What are their licenses?</li>
</ul>
<h2 id="making-good-commits"><a class="header" href="#making-good-commits">Making good commits</a></h2>
<p>Each feature or bugfix should be addressed by a single pull request, and for each pull request there may be several commits. In particular:</p>
<ul>
<li>Do <em>not</em> fix more than one issues in the same commit (except, of course, if one code change fixes all of them).</li>
<li>Do <em>not</em> do cosmetic changes to unrelated code in the same commit as some feature/bugfix.</li>
</ul>
<h2 id="waiting-for-review"><a class="header" href="#waiting-for-review">Waiting for review</a></h2>
<p>To begin with, please be patient! There are many more people submitting pull requests than there are people capable of reviewing your pull request. Getting your pull request reviewed requires a reviewer to have the spare time and motivation to look at your pull request. If your pull request has not received any notice from reviewers (i.e., no comment made) for some time, you can ping the reviewers and assignees, or take it to <a href="https://internals.tidb.io">internal.tidb.io</a> for more attention.</p>
<p>When someone does manage to find the time to look at your pull request, they will most likely make comments about how it can be improved (don't worry, even committers/maintainers have their pull requests sent back to them for changes). It is then expected that you update your pull request to address these comments, and the review process will thus iterate until a satisfactory solution has emerged.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cherry-pick-a-pull-request"><a class="header" href="#cherry-pick-a-pull-request">Cherry-pick a Pull Request</a></h1>
<p>TiDB uses <a href="contribute-to-tidb/../project-management/release-train-model.html">release train model</a> and has multiple releases. Each release matches one git branch. For <code>type/bug</code> issues with <code>severity/critical</code> and <code>severity/major</code>, it is anticipated to be fixed on any <a href="https://pingcap.github.io/tidb-dev-guide/project-management/release-train-model.html#current-maintained-releases">currently maintained releases</a> if affected. Contributors and reviewers are responsible to settle the affected versions once the bug is identified as <code>severity/critical</code> or <code>severity/major</code>. Cherry-pick pull requests shall be created to port the fix to affected branches after the original pull request merged. While creating cherry-pick pull requests, bots in TiDB community could help lighten your workload.</p>
<h2 id="what-kind-of-pull-requests-need-to-cherry-pick"><a class="header" href="#what-kind-of-pull-requests-need-to-cherry-pick">What kind of pull requests need to cherry-pick?</a></h2>
<p>Because there are more and more releases of TiDB and limits of developer time, we are not going to cherry-pick every pull request. Currently, only problems with <code>severity/critical</code> and <code>severity/major</code> are candidates for cherry-pick. There problems shall be solved on all affected <a href="https://pingcap.github.io/tidb-dev-guide/project-management/release-train-model.html#current-maintained-releases">maintained releases</a>. Check <a href="contribute-to-tidb/issue-triage.html">Issue Triage chapter</a> for severity identification.</p>
<h2 id="create-cherry-pick-pull-requests-automatically"><a class="header" href="#create-cherry-pick-pull-requests-automatically">Create cherry-pick pull requests automatically</a></h2>
<p>Typically, TiDB repos use ti-chi-bot or ti-srebot to help contributors create cherry-pick pull requests automatically. They are basically same but still have some differences.</p>
<h3 id="ti-chi-bot"><a class="header" href="#ti-chi-bot">ti-chi-bot</a></h3>
<p>ti-chi-bot creates corresponding cherry-pick pull requests according to the <code>needs-cherry-pick-&lt;release-branch-name&gt;</code> on the original pull request once it's merged. If there is any failure or omission, contributors could run <code>/cherry-pick &lt;release-branch-name&gt;</code> to trigger cherry-pick for a specific release.</p>
<h3 id="ti-srebot"><a class="header" href="#ti-srebot">ti-srebot</a></h3>
<p>ti-srebot creates corresponding cherry-pick pull requests according to the <code>needs-cherry-pick-&lt;release-version&gt;</code> on the original pull request once it's merged. If there is any failure or omission, contributors could run <code>/run-cherry-picker</code> to re-run the cherry-pick process. It would fail for already created branches. In addition, ti-srebot will re-request the reviewers and assign the new pull request to the author of the original pull request. ti-srebot will also invite the pull request author to its forked repo.</p>
<h2 id="create-cherry-pick-pull-requests-manually"><a class="header" href="#create-cherry-pick-pull-requests-manually">Create cherry-pick pull requests manually</a></h2>
<p>Contributors could also create cherry-pick pull requests manually if they want. <a href="https://git-scm.com/docs/git-cherry-pick">git cherry-pick</a> is a good command for this. The requirements in <a href="contribute-to-tidb/contribute-code.html">Contribute Code</a> also apply here.</p>
<h2 id="pass-triage-complete-check"><a class="header" href="#pass-triage-complete-check">Pass triage complete check</a></h2>
<p>For pull requests, <code>check-issue-triage-complete</code> checker will first check whether the <a href="https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/contribute-code.html#referring-to-an-issue">corresponding issue</a> has any <code>type/xx</code> label, if not, the checker fails. Then for issues with <code>type/bug</code> label, there must also exist a <code>severity/xx</code> label, otherwise, the checker fails. For <code>type/bug</code> issue with <code>severity/critical</code> or <code>severity/major</code> label, the checker checks if there is any <code>may-affects-x.y</code> label, which means the issue has not been diagnosed on all needed versions. If there is, the pull request is blocked and not able to be merged. So in order to merge a bugfix pull request into the target branch, every other effective version needs to first be diagnosed.</p>
<p>ti-chi-bot will automatically trigger the checker to run on the associated PR by listening to the labeled/unlabeled event of <code>may-affects-x.y</code> labels on bug issues, contributors also could comment <code>/check-issue-triage-complete</code> or <code>/run-check-issue-triage-complete</code> like other checkers to rerun the checker manually and update the status. Once <code>check-issue-triage-complete</code> checker passes, ti-chi-bot will add <code>needs-cherry-pick-&lt;release-version&gt;</code>/<code>needs-cherry-pick-&lt;release-branch-name&gt;</code>  labels to pull requests according to the <code>affects-x.y</code> labels on the corresponding issues.</p>
<p>In addition, if the checker fails, the robot will add the <code>do-not-merge/needs-triage-completed</code> label to the pull request at the same time, which will be used by other plugins like <a href="https://book.prow.tidb.io/#/en/plugins/tars">tars</a>.</p>
<h2 id="review-cherry-pick-pull-requests"><a class="header" href="#review-cherry-pick-pull-requests">Review cherry-pick pull requests</a></h2>
<p>Cherry-pick pull requests obey the <a href="contribute-to-tidb/review-a-pr.html">same review rules</a> as other pull requests. Besides the merge requirements as normal pull requests, cherry-pick pull requests are added <code>do-not-merge/cherry-pick-not-approved</code> label initially. To get it merged, it needs an additional <code>cherry-pick-approved</code> label from team <em>qa-release-merge</em>.</p>
<h2 id="troubleshoot-cherry-pick"><a class="header" href="#troubleshoot-cherry-pick">Troubleshoot cherry-pick</a></h2>
<ul>
<li>If there is any error in the cherry-pick process, for example, the bot fails to create some cherry-pick pull requests. You could ask reviewers/committers/maintainers for help.</li>
<li>If there are conflicts in the cherry-pick pull requests. You must <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/about-merge-conflicts">resolve the conflicts</a> to get pull requests merged. For repos using ti-srebot, you are granted privileges to the forked repo, you could directly push to the pull request branch. For ti-chi-bot, you have to ask committers/maintainers to do that for you or manually create a new cherry-pick pull request for the branch.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="review-a-pull-request"><a class="header" href="#review-a-pull-request">Review a Pull Request</a></h1>
<p>TiDB values any <a href="https://en.wikipedia.org/wiki/Code_review">code review</a>. One of the bottlenecks in the TiDB development process is the lack of code reviews. If you browse the issue tracker, you will see that numerous issues have a fix, but cannot be merged into the main source code repository, because no one has reviewed the proposed solution. Reviewing a pull request can be just as informative as providing a pull request and it will allow you to give constructive comments on another developer's work. It is a common misconception that in order to be useful, a code review has to be perfect. This is not the case at all! It is helpful to just test the pull request and/or play around with the code and leave comments in the pull request.</p>
<h2 id="principles-of-the-code-review"><a class="header" href="#principles-of-the-code-review">Principles of the code review</a></h2>
<ul>
<li>Technical facts and data overrule opinions and personal preferences.</li>
<li>Software design is about trade-offs, and there is no silver bullet.</li>
</ul>
<p>Everyone comes from different technical backgrounds with different knowledge. They have their own personal preferences. It is important that the code review is not based on biased opinions.</p>
<p>Sometimes, making choices of accepting or rejecting a pull request can be tricky as in the following situations: </p>
<ul>
<li>Suppose that a pull request contains special optimization that can improve the overall performance by 30%. However, the pull request introduces a totally different code path, and every subsequent feature must consider it.</li>
<li>Suppose that a pull request is to fix a critical bug, but the change in the pull request is risky to introduce other bugs.</li>
</ul>
<p>If a pull request under your review is in these tricky situations, what is the right choice, accepting the pull request or rejecting it? The answer is always &quot;it depends.&quot; Software design is more like a kind of art than technology. It is about aesthetics and your taste of the code. There are always trade-offs, and often there's no perfect solution.</p>
<h2 id="triaging-pull-requests"><a class="header" href="#triaging-pull-requests">Triaging pull requests</a></h2>
<p>Some pull request authors may not be familiar with TiDB, TiDB development workflow or TiDB community. They don't know what labels should be added to the pull requests and which experts could be asked for review. If you are able to, it would be great for you to triage the pull requests, adding suitable labels to the pull requests, asking corresponding experts to review the pull requests. These actions could help more contributors notice the pull requests and make quick responses.</p>
<h2 id="checking-pull-requests"><a class="header" href="#checking-pull-requests">Checking pull requests</a></h2>
<p>There are some basic aspects to check when you review a pull request:</p>
<ul>
<li><strong>Concentration</strong>. One pull request should only do one thing. No matter how small it is, the change does exactly one thing and gets it right. Don't mix other changes into it.</li>
<li><strong>Tests</strong>. A pull request should be test covered, whether the tests are unit tests, integration tests, or end-to-end tests. Tests should be sufficient, correct and don't slow down the CI pipeline largely.</li>
<li><strong>Functionality</strong>. The pull request should implement what the author intends to do and fit well in the existing code base, resolve a real problem for TiDB users. To get the author's intention and the pull request design, you could follow the discussions in the corresponding GitHub issue or <a href="https://internals.tidb.io">internal.tidb.io</a> topic.</li>
<li><strong>Style</strong>. Code in the pull request should follow common programming style. For Go and Rust, there are built-in tools with the compiler toolchain. However, sometimes the existing code is inconsistent with the style guide, you should maintain consistency with the existing code or file a new issue to fix the existing code style first.</li>
<li><strong>Documentation</strong>. If a pull request changes how users build, test, interact with, or release code, you must check whether it also updates the related documentation such as READMEs and any generated reference docs. Similarly, if a pull request deletes or deprecates code, you must check whether or not the corresponding documentation should also be deleted.</li>
<li><strong>Performance</strong>. If you find the pull request may affect performance, you could ask the author to provide a benchmark result.</li>
</ul>
<h2 id="writing-code-review-comments"><a class="header" href="#writing-code-review-comments">Writing code review comments</a></h2>
<p>When you review a pull request, there are several rules and suggestions you should take to <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request">write better comments</a>:</p>
<ul>
<li><strong>Be respectful to pull request authors and other reviewers</strong>. Code review is a part of your community activities. You should follow the community requirements.</li>
<li><strong>Asking questions instead of making statements</strong>. The wording of the review comments is very important. To provide review comments that are constructive rather than critical, you can try asking questions rather than making statements.</li>
<li><strong>Offer sincere praise</strong>. Good reviewers focus not only on what is wrong with the code but also on good practices in the code. As a reviewer, you are recommended to offer your encouragement and appreciation to the authors for their good practices in the code. In terms of mentoring, telling the authors what they did is right is even more valuable than telling them what they did is wrong.</li>
<li><strong>Provide additional details and context of your review process</strong>. Instead of simply &quot;approving&quot; the pull request. If your test the pull request, report the result and your test environment details. If you request changes, try to suggest how.</li>
</ul>
<h2 id="accepting-pull-requests"><a class="header" href="#accepting-pull-requests">Accepting pull requests</a></h2>
<p>Once you think the pull request is ready, you can <a href="https://docs.github.com/en/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/approving-a-pull-request-with-required-reviews">approve</a> it. </p>
<p>In the TiDB community, most repositories require two approvals before a pull request can be accepted. A few repositories require a different number of approvals, but two approvals are the default setting. After the required approval number is met, a committer can <a href="https://prow.tidb.io/command-help?repo=pingcap%2Ftidb#merge">/merge</a> the pull request.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="make-a-proposal"><a class="header" href="#make-a-proposal">Make a Proposal</a></h1>
<p>This page defines the best practices procedure for making a proposal in TiDB projects. This text is based on the content of <a href="https://github.com/pingcap/tidb/blob/7f4f5c02364b6578da561ec14f409a39ddf954a5/docs/design/README.md">TiDB Design Document</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a bit of a design process and produce a consensus among the TiDB community.</p>
<p>The process described in this page is intended to provide a consistent and controlled path for new features to enter the TiDB projects, so that all stakeholders can be confident about the direction the projects is evolving in.</p>
<h2 id="who-should-initiate-the-design-document"><a class="header" href="#who-should-initiate-the-design-document">Who should initiate the design document?</a></h2>
<p>Everyone is encouraged to initiate a design document, but before doing it, please make sure you have an intention of getting the work done to implement it.</p>
<h2 id="before-creating-a-design-document"><a class="header" href="#before-creating-a-design-document">Before creating a design document</a></h2>
<p>A hastily-proposed design document can hurt its chances of acceptance. Low-quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the design document can make the process smoother.</p>
<p>Although there is no single way to prepare for submitting a design document, it is generally a good idea to pursue feedback from other project developers beforehand, to ascertain that the design document may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting a draft of design document is on the <a href="https://internals.tidb.io/">TiDB Internals forum</a>.</p>
<h2 id="what-is-the-process"><a class="header" href="#what-is-the-process">What is the process?</a></h2>
<ol>
<li>Create an issue describing the problem, goal and solution.</li>
<li>Get responses from other contributors to see if the proposal is generally acceptable.</li>
<li>Create a pull request with a design document based on the <a href="https://github.com/pingcap/tidb/blob/7f4f5c02364b6578da561ec14f409a39ddf954a5/docs/design/TEMPLATE.md">template</a> as <code>YYYY-MM-DD-my-feature.md</code>.</li>
<li>Discussion takes place, and the text is revised in response.</li>
<li>The design document is accepted or rejected when at least two committers reach consensus and no objection from the committer.</li>
<li>If accepted, create a <a href="https://github.com/pingcap/tidb/issues/new?assignees=&amp;labels=type%2Fenhancement&amp;template=development-task.md">tracking issue</a> for the design document or convert one from a previous discuss issue. The tracking issue basically tracks subtasks and progress. And refer the tracking issue in the design document replacing placeholder in the template.</li>
<li>Merge the pull request of design.</li>
<li>Start the implementation.</li>
</ol>
<p>Please refer to the tracking issue from subtasks to track the progress.</p>
<p>An example that almost fits into this model is the proposal &quot;Support global index for partition table&quot;, without following the latest template.</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/18032">tracking issue</a></li>
<li><a href="https://github.com/pingcap/tidb/pull/18982">pull request of design document</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tidb-code-style-and-quality-guide"><a class="header" href="#tidb-code-style-and-quality-guide">TiDB Code Style and Quality Guide</a></h1>
<p>This is an attempt to capture the code and quality standard that we want to maintain.</p>
<h2 id="the-newtype-pattern-improves-code-quality"><a class="header" href="#the-newtype-pattern-improves-code-quality">The newtype pattern improves code quality</a></h2>
<p>We can create a new type using the <code>type</code> keyword.</p>
<p>The newtype pattern is perhaps most often used in Golang to get around type restrictions rather than to try to create new ones. It is used to create different interface implementations for a type or to extend a builtin type or a type from an existing package with new methods.</p>
<p>However, it is generally useful to improve code clarity by marking that data has gone through either a validation or a transformation. Using a different type can reduce error handling and prevent improper usage.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

type Email string

func newEmail(email string) (Email, error) {
    if !strings.Contains(email, &quot;@&quot;) {
        return Email(&quot;&quot;), fmt.Errorf(&quot;Expected @ in the email&quot;)
    }
    return Email(email), nil
}

func (email Email) Domain() string {
    return strings.Split(string(email), &quot;@&quot;)[1]
}

func main() {
    ping, err := newEmail(&quot;go@pingcap.com&quot;)
    if err != nil { panic(err) }
    fmt.Println(ping.Domain())
}
</code></pre>
<h2 id="when-to-use-value-or-pointer-receiver"><a class="header" href="#when-to-use-value-or-pointer-receiver">When to use value or pointer receiver</a></h2>
<p>Because pointer receivers need to be used some of the time, Go programmers often use them all of the time.
This is a typical outline of Go code:</p>
<pre><code class="language-go">type struct S {}
func NewStruct() *S
func (s *S) structMethod()
</code></pre>
<p>Using pointers for the entire method set means we have to read the source code of every function to determine if it mutates the struct. Mutations are a source of error. This is particularly true in concurrent programs. We can contrast this with values: these are always concurrent safe.</p>
<p>For code clarity and bug reduction a best practice is to default to using values and value receivers.
However, pointer receivers are often required to satisfy an interface or for performance reasons, and this need overrides any default practice.</p>
<p>However, performance can favor either approach. One might assume that pointers would always perform better because it avoids copying. However, the performance is roughly the same for small structs in micro benchmark. This is because the copying is cheap, inlining can often avoid copying anyways, and pointer indirection has its own small cost. In a larger program with a goal of predictable low latency the value approach can be more favorable because it avoids <a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/">heap allocation and any additional GC overhead</a>.</p>
<p>As a rule of thumb is that when a struct has 10 or more words we should use pointer receivers. However, to actually know which is best for performance depends on how the struct is used in the program and must ultimately be determined by profiling. For example these are some factors that affect things:</p>
<ul>
<li>method size: small inlineable methods favor value receivers.</li>
<li>Is the struct called repeatedly in a for loop? This favors pointer receivers.</li>
<li>What is the GC behavior of the rest of the program? GC pressure may favor value receivers.</li>
</ul>
<h2 id="parallel-for-loop"><a class="header" href="#parallel-for-loop">Parallel For-Loop</a></h2>
<p>There are two types of for loop on range: &quot;with index&quot; and &quot;without index&quot;. Let's see an example for range with index.</p>
<pre><code class="language-go">func TestRangeWithIndex(t *testing.T) {
	rows := []struct{ index int }{{index: 0}, {index: 1}, {index: 2}}
	for _, row := range rows {
		row.index += 10
	}
	for i, row := range rows {
		require.Equal(t, i+10, row.index)
	}
}
</code></pre>
<p>the output is:</p>
<pre><code>    Error Trace:	version_test.go:39
    Error:      	Not equal: 
                    expected: 10
                    actual  : 0
    Test:       	TestShowRangeWithIndex
</code></pre>
<p>Test fails because when range with index, the loop iterator variable is the same instance of the variable with a clone of iteration target value.</p>
<h3 id="the-same-instance-of-the-variable"><a class="header" href="#the-same-instance-of-the-variable">The same instance of the variable</a></h3>
<p>Since the the loop iterator variable is the same instance of the variable, it may result in tricky error with parallel for-loop.</p>
<pre><code class="language-go">done := make(chan bool)
values := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
for _, v := range values {
	go func() {
		fmt.Println(v)
		done &lt;- true
	}()
}
for _ = range values {
	&lt;-done
}
</code></pre>
<p>You might expect to see <code>a</code>, <code>b</code>, <code>c</code> as the output, but you'll probably see instead is <code>c</code>, <code>c</code>, <code>c</code>. </p>
<p>This is because each iteration of the loop uses the same instance of the variable <code>v</code>, so each closure shares that single variable.</p>
<p>This is the same reason which result wrong test when use <code>t.Parallel()</code> with range, which is covered in <a href="contribute-to-tidb/../get-started/write-and-run-unit-tests.html#parallel">Parallel section of Write and run unit tests</a></p>
<h3 id="a-clone-of-iteration-target-value"><a class="header" href="#a-clone-of-iteration-target-value">A clone of iteration target value</a></h3>
<p>Since the loop iterator variable is a clone of iteration target value, it may result in logic error. It can also lead to performance issue compared with none-index range loop or bare for loop.</p>
<pre><code class="language-go">type Item struct {
	id  int
	value [1024]byte
}

func BenchmarkRangeIndexStruct(b *testing.B) {
	var items [1024]Item
	for i := 0; i &lt; b.N; i++ {
		var tmp int
		for k := range items {
			tmp = items[k].id
		}
		_ = tmp
	}
}

func BenchmarkRangeStruct(b *testing.B) {
	var items [1024]Item
	for i := 0; i &lt; b.N; i++ {
		var tmp int
		for _, item := range items {
			tmp = item.id
		}
		_ = tmp
	}
}
</code></pre>
<pre><code>BenchmarkRangeIndexStruct-12             4875518               246.0 ns/op
BenchmarkRangeStruct-12                    16171             77523 ns/op
</code></pre>
<p>You can see range with index is much slower than range without index, since range with index use cloned value so have big performance decrease if cloned value use lots of memory.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="write-document"><a class="header" href="#write-document">Write Document</a></h1>
<p>Good documentation is crucial for any kind of software. This is especially true for sophisticated software systems such as distributed database like TiDB. The TiDB community aims to provide concise, precise, and complete documentation and welcomes any contribution to improve TiDB's documentation.</p>
<h2 id="where-you-can-contribute"><a class="header" href="#where-you-can-contribute">Where you can contribute</a></h2>
<p>The TiDB community provides bilingual documentation. The English documentation is maintained in the <a href="https://github.com/pingcap/docs">pingcap/docs</a> repository (docs repo) and the Chinese documentation is maintained in the <a href="https://github.com/pingcap/docs-cn">pingcap/docs-cn</a> repository (docs-cn repo). You are welcome to contribute to either of the repositories.</p>
<p>In a addition, you are also welcome to contribute to the <a href="https://github.com/pingcap/docs-tidb-operator">TiDB Operator documentation</a> and the <a href="https://github.com/pingcap/docs-dm">TiDB Data Migration documentation</a>.</p>
<p>This guide walks you through what and how you can contribute to the TiDB bilingual documentation in docs-cn and docs repos.</p>
<h2 id="what-you-can-contribute"><a class="header" href="#what-you-can-contribute">What you can contribute</a></h2>
<p>You can start from any one of the following items to help improve TiDB Docs at the PingCAP website (<a href="https://docs.pingcap.com/tidb/stable">en</a> and <a href="https://docs.pingcap.com/zh/tidb/stable">zh</a>):</p>
<ul>
<li>Fix typos or format (punctuation, space, indentation, code block, etc.)</li>
<li>Fix or update inappropriate or outdated descriptions</li>
<li>Add missing content (sentence, paragraph, or a new document)</li>
<li>Translate docs changes from English to Chinese, or from Chinese to English. See <a href="contribute-to-tidb/write-document.html#how-we-implement-bilingual-documentation">How we implement bilingual documentation</a></li>
<li>Submit, reply to, and resolve <a href="https://github.com/pingcap/docs/issues">docs issues</a> or <a href="https://github.com/pingcap/docs-cn/issues">docs-cn issues</a></li>
<li>(Advanced) Review Pull Requests created by others</li>
</ul>
<h2 id="before-you-contribute"><a class="header" href="#before-you-contribute">Before you contribute</a></h2>
<p>Before you contribute, let's take a quick look at some general information about TiDB documentation maintenance. This can help you to become a contributor soon.</p>
<h3 id="get-familiar-with-style"><a class="header" href="#get-familiar-with-style">Get familiar with style</a></h3>
<ul>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#how-to-write-a-good-commit-message">Commit Message Style</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#pull-request-title-style">Pull Request Title Style</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/docs/blob/master/resources/markdownlint-rules.md">Markdown Rules</a></p>
</li>
<li>
<p><a href="https://github.com/pingcap/community/blob/master/contributors/code-comment-style.md">Code Comment Style</a></p>
</li>
<li>
<p>Diagram Style: <a href="https://github.com/pingcap/community/blob/master/contributors/figma-quick-start-guide.md">Figma Quick Start Guide</a></p>
<p>To keep a consistent style for diagrams, we recommend using <a href="https://www.figma.com/">Figma</a> to draw or design diagrams. If you need to draw a diagram, refer to the guide and use shapes or colors provided in the template.</p>
</li>
</ul>
<h3 id="learn-about-docs-versions"><a class="header" href="#learn-about-docs-versions">Learn about docs versions</a></h3>
<p>Currently, we maintain eight versions of TiDB documentation, each with a separate branch:</p>
<table><thead><tr><th align="left">Docs branch name</th><th align="left">Version description</th></tr></thead><tbody>
<tr><td align="left"><code>master</code> branch</td><td align="left">the latest development version</td></tr>
<tr><td align="left"><code>release-6.0</code> branch</td><td align="left">the 6.0 version</td></tr>
<tr><td align="left"><code>release-5.4</code> branch</td><td align="left">the 5.4 version</td></tr>
<tr><td align="left"><code>release-5.3</code> branch</td><td align="left">the 5.3 version</td></tr>
<tr><td align="left"><code>release-5.2</code> branch</td><td align="left">the 5.2 version</td></tr>
<tr><td align="left"><code>release-5.1</code> branch</td><td align="left">the 5.1 version</td></tr>
<tr><td align="left"><code>release-5.0</code> branch</td><td align="left">the 5.0 version</td></tr>
<tr><td align="left"><code>release-4.0</code> branch</td><td align="left">the 4.0 version</td></tr>
<tr><td align="left"><code>release-3.1</code> branch</td><td align="left">the 3.1 version</td></tr>
<tr><td align="left"><code>release-3.0</code> branch</td><td align="left">the 3.0 version</td></tr>
<tr><td align="left"><code>release-2.1</code> branch</td><td align="left">the 2.1 version</td></tr>
</tbody></table>
<p>Each docs version is updated very frequently and changes to one version often apply to another version or other versions as well. We introduce ti-chi-bot to automatically file PRs to other versions as long as you add corresponding cherry-pick labels to your PR.</p>
<h3 id="use-cherry-pick-labels"><a class="header" href="#use-cherry-pick-labels">Use cherry-pick labels</a></h3>
<ul>
<li>
<p>If your changes apply to only one doc version, just submit a PR to the corresponding version branch.</p>
</li>
<li>
<p>If your changes apply to multiple doc versions, you don't have to submit a PR to each branch. Instead, after you submit your PR, trigger the ti-chi-bot to submit a PR to other version branches by adding one or several of the following labels as needed. Once the current PR is merged, ti-chi-bot will start to work.</p>
<ul>
<li><code>needs-cherry-pick-release-5.2</code> label: ti-chi-bot will submit a PR to the <code>release-5.2</code> branch.</li>
<li><code>needs-cherry-pick-release-5.1</code> label: ti-chi-bot will submit a PR to the <code>release-5.1</code> branch.</li>
<li><code>needs-cherry-pick-release-5.0</code> label: ti-chi-bot will submit a PR to the <code>release-5.0</code> branch.</li>
<li><code>needs-cherry-pick-release-4.0</code> label: ti-chi-bot will submit a PR to the <code>release-4.0</code> branch.</li>
<li><code>needs-cherry-pick-release-3.1</code> label: ti-chi-bot will submit a PR to the <code>release-3.1</code> branch.</li>
<li><code>needs-cherry-pick-release-3.0</code> label: ti-chi-bot will submit a PR to the <code>release-3.0</code> branch.</li>
<li><code>needs-cherry-pick-release-2.1</code> label: ti-chi-bot will submit a PR to the <code>release-2.1</code> branch.</li>
<li><code>needs-cherry-pick-master</code> label: ti-chi-bot will submit a PR to the <code>master</code> branch.</li>
</ul>
</li>
<li>
<p>If most of your changes apply to multiple doc versions but some differences exist among versions, you still can use cherry-pick labels to let ti-chi-bot create PRs to other versions. In this situation, you also need to add the <code>requires-version-specific-change</code> label as a reminder to the PR reviewer. After the PR to another version is successfully submitted by ti-chi-bot, you can make changes to that PR.</p>
</li>
</ul>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to contribute</a></h2>
<p>Your contribution journey is in two stages:</p>
<ol>
<li>
<p>In <a href="contribute-to-tidb/write-document.html#stage-1-create-and-submit-your-pr">stage 1</a>, create and submit your Pull Request to the <a href="https://github.com/pingcap/docs-cn">docs-cn</a> or <a href="https://github.com/pingcap/docs">docs</a> repository.</p>
</li>
<li>
<p>In <a href="contribute-to-tidb/write-document.html#stage-2-get-notified-and-address-review-comments">stage 2</a>, get notified of any review comments and address the comments until the PR gets approved and merged.</p>
</li>
</ol>
<h3 id="stage-1-create-and-submit-your-pr"><a class="header" href="#stage-1-create-and-submit-your-pr">Stage 1: Create and submit your PR</a></h3>
<p>Perform the following steps to create your Pull Request to the <a href="https://github.com/pingcap/docs">docs</a> repository. If don't like to use commands, you can also use <a href="https://desktop.github.com/">GitHub Desktop</a>, which is easier to get started.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>This section takes creating a PR to the <code>master</code> branch in the docs repository as an example. Steps of creating PRs to other branches or to the docs-cn repository are similar.</p>
</blockquote>
<h4 id="step-0-sign-the-cla"><a class="header" href="#step-0-sign-the-cla">Step 0: Sign the CLA</a></h4>
<p>Your PR can only be merged after you sign the <a href="https://cla-assistant.io/pingcap/docs">Contributor License Agreement (docs)</a>. Please make sure you sign the CLA before continuing.</p>
<h4 id="step-1-fork-the-repository"><a class="header" href="#step-1-fork-the-repository">Step 1: Fork the repository</a></h4>
<ol>
<li>Visit the project: <a href="https://github.com/pingcap/docs">https://github.com/pingcap/docs</a></li>
<li>Click the <strong>Fork</strong> button on the top right and wait it to finish.</li>
</ol>
<h4 id="step-2-clone-the-forked-repository-to-local-storage"><a class="header" href="#step-2-clone-the-forked-repository-to-local-storage">Step 2: Clone the forked repository to local storage</a></h4>
<pre><code>cd $working_dir # Comes to the directory that you want put the fork in, for example, &quot;cd ~/Documents/GitHub&quot;
git clone git@github.com:$user/docs.git # Replace &quot;$user&quot; with your GitHub ID

cd $working_dir/docs
git remote add upstream git@github.com:pingcap/docs.git # Adds the upstream repo
git remote -v # Confirms that your remote makes sense
</code></pre>
<h4 id="step-3-create-a-new-branch"><a class="header" href="#step-3-create-a-new-branch">Step 3: Create a new branch</a></h4>
<ol>
<li>
<p>Get your local master up-to-date with upstream/master.</p>
<pre><code>cd $working_dir/docs
git fetch upstream
git checkout master
git rebase upstream/master
</code></pre>
</li>
<li>
<p>Create a new branch based on the master branch.</p>
<pre><code>git checkout -b new-branch-name
</code></pre>
</li>
</ol>
<h4 id="step-4-do-something"><a class="header" href="#step-4-do-something">Step 4: Do something</a></h4>
<p>Edit some file(s) on the <code>new-branch-name</code> branch and save your changes. You can use editors like Visual Studio Code to open and edit <code>.md</code> files.</p>
<h4 id="step-5-commit-your-changes"><a class="header" href="#step-5-commit-your-changes">Step 5: Commit your changes</a></h4>
<pre><code>git status # Checks the local status
git add &lt;file&gt; ... # Adds the file(s) you want to commit. If you want to commit all changes, you can directly use `git add.`
git commit -m &quot;commit-message: update the xx&quot;
</code></pre>
<p>See <a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#how-to-write-a-good-commit-message">Commit Message Style</a>.</p>
<h4 id="step-6-keep-your-branch-in-sync-with-upstreammaster"><a class="header" href="#step-6-keep-your-branch-in-sync-with-upstreammaster">Step 6: Keep your branch in sync with upstream/master</a></h4>
<pre><code># While on your new branch
git fetch upstream
git rebase upstream/master
</code></pre>
<h4 id="step-7-push-your-changes-to-the-remote"><a class="header" href="#step-7-push-your-changes-to-the-remote">Step 7: Push your changes to the remote</a></h4>
<pre><code>git push -u origin new-branch-name # &quot;-u&quot; is used to track the remote branch from origin
</code></pre>
<h4 id="step-8-create-a-pull-request"><a class="header" href="#step-8-create-a-pull-request">Step 8: Create a pull request</a></h4>
<ol>
<li>Visit your fork at <a href="https://github.com/$user/docs">https://github.com/$user/docs</a> (replace <code>$user</code> with your GitHub ID)</li>
<li>Click the <code>Compare &amp; pull request</code> button next to your <code>new-branch-name</code> branch to create your PR. See <a href="https://github.com/pingcap/community/blob/master/contributors/commit-message-pr-style.md#pull-request-title-style">Pull Request Title Style</a>.</li>
</ol>
<p>Now, your PR is successfully submitted.</p>
<h3 id="stage-2-get-notified-and-address-review-comments"><a class="header" href="#stage-2-get-notified-and-address-review-comments">Stage 2: Get notified and address review comments</a></h3>
<p>After your PR is submitted, addressing review comments is just as important as creating the PR. Please perform the following steps to complete your contribution journey.</p>
<h4 id="step-1-get-notified-of-review-comments"><a class="header" href="#step-1-get-notified-of-review-comments">Step 1: Get notified of review comments</a></h4>
<p>After your PR is created, the repository administrator will add labels to your PR for PR management. Review comments will also be submitted to your PR, which requires you to modify the PR content.</p>
<p>Once the review comments are submitted, you will receive a notification in your registered email box. Check your email box and get notified.</p>
<p>Once you receive the email, click the PR link in the mail to open the PR page in your browser, and you will see the comments.</p>
<h4 id="step-2-address-review-comments"><a class="header" href="#step-2-address-review-comments">Step 2: Address review comments</a></h4>
<p>The review comments require you to change your submitted PR content. You can either accept a suggestion and make the change, or decline the suggestion and submit your reply right under the comment stating your reason.</p>
<h5 id="accept-comments-in-your-local-editor"><a class="header" href="#accept-comments-in-your-local-editor">Accept comments in your local editor</a></h5>
<p>To accept suggestions, perform the following steps to modify your submitted PR content:</p>
<ol>
<li>
<p>Pull the latest content from the remote origin of your PR to your local by executing the following commands in the terminal. This ensures that your local content is up-to-date with the remote origin.</p>
<pre><code>cd $working_dir/docs
git checkout new-branch-name
git fetch origin
</code></pre>
</li>
<li>
<p>Edit the file or files to be modified in your local editor (like Visual Studio Code) according to the review comments.</p>
</li>
<li>
<p>Commit your changes. This step is the same as <a href="contribute-to-tidb/write-document.html#step-5-commit-your-changes">Step 5: Commit your changes</a> in stage 1.</p>
<pre><code>git status # Checks the local status
git add &lt;file&gt; ... # Adds the file(s) you want to commit. If you want to commit all changes, you can directly use `git add.`
git commit -m &quot;commit-message: update the xx&quot;
</code></pre>
</li>
<li>
<p>Push your changes to the remote origin:</p>
<pre><code>git push -u origin new-branch-name # &quot;-u&quot; is used to track the remote branch from origin
</code></pre>
</li>
<li>
<p>After all comments are addressed, reply on the PR page: &quot;All comments are addressed. PTAL.&quot;</p>
<p>&quot;PTAL&quot; is short for &quot;Please take a look&quot;.</p>
</li>
</ol>
<h5 id="accept-comments-on-the-pr-page"><a class="header" href="#accept-comments-on-the-pr-page">Accept comments on the PR page</a></h5>
<p>If a review comment is in the suggestion mode where the reviewer has already made the suggested change for you (with highlighted differences), to accept the suggestion, you only need to click the &quot;Commit suggestion&quot; button. Then the suggested change is automatically committed to your PR.</p>
<p>If multiple review comments are in the suggestion mode, it is recommended to accept them in a batch. To do that, perform the following steps on the PR page:</p>
<ol>
<li>
<p>Click the &quot;Files changed&quot; tab and see the file changes. You can see multiple review comments in suggestion mode.</p>
</li>
<li>
<p>Choose the suggestions you want to commit by clicking the &quot;Add suggestion to batch&quot; button on each suggestion.</p>
</li>
<li>
<p>After all suggestions to be committed are chosen, click the &quot;Commit suggestions&quot; button on the upper right corner of the PR page. Then, you have successfully committed all suggested changes.</p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong></p>
<p>After you have addressed review comments, reviewers might also submit new comments. You need to repeat this step 2 and make sure all comments are addressed until the reviewers approve your PR and have it merged.</p>
</blockquote>
<h4 id="step-3-handle-cherry-picked-prs"><a class="header" href="#step-3-handle-cherry-picked-prs">Step 3: Handle cherry-picked PRs</a></h4>
<p>Once your PR gets approved, the repo administrator will have your PR merged into the docs upstream/master. After a few minutes, ti-chi-bot automatically creates PRs to other versions as you have specified by adding cherry-pick labels.</p>
<p>You need to perform the following steps on each one of the cherry-picked PRs:</p>
<ul>
<li>
<p>Check whether the cherry-picked content is exactly what you want to commit to that release version. If yes, please comment &quot;LGTM&quot;, which means &quot;Looks good to me&quot;. The repository administrator will merge it soon.</p>
</li>
<li>
<p>If most of your changes apply to multiple doc versions but some differences exist among versions, make changes by commenting in the cherry-picked PR instructing how you would like to make version-specific changes. Then the repository administrator will commit to the PR according to your comment before you approve it.</p>
</li>
<li>
<p>(Advanced) If any conflicts exist in the cherry-picked PR, resolve the conflicts. This is only for those who have the write permission in the repository.</p>
</li>
</ul>
<p>After the steps above are completed, the administrator will merge the cherry-picked PRs. At this point, your contribution journey is completed! 🎉</p>
<h2 id="how-we-implement-bilingual-documentation"><a class="header" href="#how-we-implement-bilingual-documentation">How we implement bilingual documentation</a></h2>
<p>TiDB documentation is usually written in one language and then translated to another. We use GitHub labels in docs-cn and docs repos (as well as in docs-tidb-operator and docs-dm repos) to track the entire translation or alignment process.</p>
<p>The following labels are used:</p>
<ul>
<li><code>translation/doing</code>: This PR needs translation, or the translation is on the way.</li>
<li><code>translation/done</code>: This PR has been translated in another PR.</li>
<li><code>translation/from-docs</code>: This PR is translated from a docs PR.</li>
<li><code>translation/from-docs-cn</code>: This PR is translated from a docs-cn PR.</li>
<li><code>translation/no-need</code>: This PR does not need translation.</li>
</ul>
<p>The following process describes how a docs-cn PR (Chinese content) is translated and aligned to the docs repo (English content). The translation from docs to docs-cn is similar.</p>
<ol>
<li>
<p>Once a PR is created in docs-cn that updates the Chinese documentation, the repo administrator will soon add a <code>translation/doing</code> or <code>translation/no-need</code> label and an assignee (translator) to the PR. The tracking process begins.</p>
<p>The assignee regularly checks his or her PR list for translation. To check out his or her translation list, use the GitHub search syntax <code>is:pr assignee:@GitHub_ID is:merged label:translation/doing</code> in the GitHub search box on the <a href="https://github.com/pulls">GitHub Pull Requests page</a>.</p>
<p>PRs with the <code>translation/no-need</code> label are not tracked.</p>
</li>
<li>
<p>After this docs-cn PR is merged, the assignee starts the translation in the local editor.</p>
</li>
<li>
<p>Once the assignee submits the translated content in a docs PR, he or she adds the <code>translation/from-docs-cn</code> label to the docs PR, removes the <code>translation/doing</code> label from the docs-cn PR, and adds the <code>translation/done</code> label to the docs-cn PR.</p>
</li>
<li>
<p>The assignee provides the docs-cn PR link in the PR description section of the docs PR (&quot;This PR is translated from&quot;). The reviewer will know from which docs-cn PR the docs PR is translated. At the same time, a reverse link is automatically generated in the docs-cn PR.</p>
</li>
<li>
<p>After the docs PR is merged. The translation tracking process is finished. The updates in Chinese documentation are synchronized to the English documentation.</p>
</li>
</ol>
<p>If you want to apply for a translation, check the following lists of merged docs-cn/docs PRs with the <code>translation/doing</code> label, pick one PR, assign yourself with your GitHub ID, and start the process from step 2 above.</p>
<ul>
<li>The list of PR that can be translated in docs-cn: <a href="https://github.com/pingcap/docs-cn/pulls?q=is%3Apr+label%3Atranslation%2Fdoing+is%3Amerged">Pull requests · pingcap/docs-cn</a></li>
<li>The list of PR that can be translated in docs: <a href="https://github.com/pingcap/docs/pulls?q=is%3Apr+is%3Amerged+label%3Atranslation%2Fdoing+">Pull requests · pingcap/docs</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="release-notes-language-style-guide"><a class="header" href="#release-notes-language-style-guide">Release Notes Language Style Guide</a></h1>
<p>A concise release note can clearly and accurately deliver to users how your PR can make a difference. Your release note written in a PR will be presented in <a href="https://docs.pingcap.com/tidb/stable/release-notes">docs.pingcap.com</a> as a part of the TiDB documentation.</p>
<p>This release notes language style guide briefly explains what a quality release note looks like, provides examples, and aims to help you write quality release notes.</p>
<h2 id="what-a-quality-release-note-looks-like"><a class="header" href="#what-a-quality-release-note-looks-like">What a quality release note looks like</a></h2>
<p>A high-quality release note has the following merits:</p>
<ul>
<li>Clear in type</li>
<li>Adequate and clear in meaning</li>
<li>User perspective</li>
</ul>
<p>A release note with a distinguishable type can help users quickly identify the nature or goal of your PR change. Other teams will also benefit from it.</p>
<p>Depending on what your PR changes, you can refer to one of the following release note types:</p>
<ul>
<li>Compatibility change</li>
<li>Bug fix</li>
<li>Improvement or Feature enhancement</li>
</ul>
<h2 id="compatibility-change"><a class="header" href="#compatibility-change">Compatibility change</a></h2>
<p>A compatibility change note means:</p>
<ul>
<li>Your PR adds, removes, or modifies one or more configuration items or system variables.</li>
<li>Your PR modifies the default value of a configuration item or system variable.</li>
</ul>
<p>For this type of note, you should clearly and adequately state the following aspects:</p>
<ul>
<li>The previous code behavior, configuration item, or default value.</li>
<li>The new code behavior, configuration item, or default value since the new version.</li>
</ul>
<p>Note that the object of the change should be user-perceivable. If the changed configuration item or system variable is not supposed to be exposed to users, do not include it in your release notes.</p>
<p><strong>Examples:</strong></p>
<table><thead><tr><th><strong>Not recommended</strong></th><th><strong>Clear in type</strong></th><th><strong>Adequate and clear in meaning</strong></th><th><strong>User perspective</strong></th><th>Recommended</th></tr></thead><tbody>
<tr><td>copr: cast invalid utf8 string to real bug fix</td><td>❌</td><td>❌</td><td>❌</td><td>Previously, when TiDB converts an illegal UTF-8 string to a Real type, an error is reported directly. From now on, TiDB will process the conversion according to the legal UTF-8 prefix in the string.</td></tr>
<tr><td>sink: fix kafka max message size inaccurate issue</td><td>❌</td><td>❌</td><td>❌</td><td>Change the default value of Kafka Sink max-message-bytes from 512 MB to 1 MB to prevent TiCDC from sending too large messages to Kafka clusters</td></tr>
<tr><td>cdc/sink: adjust kafka initialization logic</td><td>❌</td><td>❌</td><td>❌</td><td>Change the default value of Kafka Sink partition-num to 3 so that TiCDC distributes messages across Kafka partitions more evenly</td></tr>
<tr><td>cmd: hide --sort-dir in changefeed command. (deprecated warning exists)</td><td>✅</td><td>❌</td><td>❌</td><td>Deprecate <code>--sort-dir</code> in the <code>cdc cli changefeed</code> command. Instead, users can set <code>--sort-dir</code> in the <code>cdc server</code> command.</td></tr>
</tbody></table>
<h2 id="bug-fix"><a class="header" href="#bug-fix">Bug fix</a></h2>
<p>A bug fix note means that your PR fixes an existing bug or issue. This type of notes start with &quot;Fix&quot; followed by &quot;the issue/bug&quot;.</p>
<p>Write your note clearly and adequately so that your target readers can get the main point of your bug fix. The bug or issue must be directly perceivable to the users, and you can refer to the associated GitHub issues.</p>
<p>In addition, it is recommended to highlight the bug trigger condition or the workaround if there is any.</p>
<p><strong>Examples:</strong></p>
<table><thead><tr><th><strong>Not recommended</strong></th><th><strong>Clear in type</strong></th><th><strong>Adequate and clear in meaning</strong></th><th><strong>User perspective</strong></th><th>Recommended</th></tr></thead><tbody>
<tr><td>lock_resolver: avoid pessimistic transactions using resolveLocksForWrite</td><td>❌</td><td>✅</td><td>❌</td><td>Fix the issue that committing pessimistic transactions might cause write conflict</td></tr>
<tr><td>retry when meeting stablish conn fails</td><td>❌</td><td>❌</td><td>❌</td><td>Fix the issue of unexpected results when TiFlash fails to establish MPP connections</td></tr>
<tr><td>Fix the issue that greatest(datetime) union null returns empty string</td><td>✅</td><td>❌</td><td>✅</td><td>Fix the issue that the query result might be wrong when NULL is in the UNION subquery</td></tr>
<tr><td>copr: make CM Sketch built with the same encoding as what TiDB assumes</td><td>❌</td><td>❌</td><td>❌</td><td>Fix the issue of potential wrong analyzed statistics when <code>tidb_analyze_version</code> is set to <code>1</code></td></tr>
</tbody></table>
<h2 id="improvement"><a class="header" href="#improvement">Improvement</a></h2>
<p>An improvement note means that your PR improves stability or performance of the product, or enhances an existing feature. In addition to describing what your PR has changed, you should also mention how users can benefit from it.</p>
<p>This type of release note consists of two parts: what you have changed + the benefit of your change. This type of release notes often starts with &quot;support&quot;, &quot;increase&quot;, &quot;improve&quot;, &quot;optimize&quot;, etc.</p>
<p><strong>Examples:</strong></p>
<table><thead><tr><th><strong>Not recommended</strong></th><th><strong>Clear in type</strong></th><th><strong>Adequate and clear in meaning</strong></th><th><strong>User perspective</strong></th><th>Recommended</th></tr></thead><tbody>
<tr><td>Not use the stale read request's <code>start_ts</code> to update <code>max_ts</code> to avoid commit request keep retrying</td><td>✅</td><td>✅</td><td>❌</td><td>Improve commit performance in some edge cases</td></tr>
<tr><td>Restore many small tables would be faster.</td><td>✅</td><td>❌</td><td>❌</td><td>Split and scatter Regions concurrently to improve restore speed</td></tr>
<tr><td>server: stop status server early when gracefully shutdown</td><td>✅</td><td>❌</td><td>❌</td><td>Shut down the status server first to make sure that the client can correctly check the shutdown status</td></tr>
<tr><td>Better err msg when PD endpoint missing certificate</td><td>✅</td><td>❌</td><td>✅</td><td>Improve the error message when connecting to a TLS protected PD endpoint without a certificate</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="committer-guide"><a class="header" href="#committer-guide">Committer Guide</a></h1>
<p>This is an evolving document to provide some helpful tips for committers. Most of them are lessons learned during development. We welcome every committer to contribute to this document. See the <a href="contribute-to-tidb/community-guideline.html">TiDB Community Guideline</a> for an overview of the committership and the general development process.</p>
<h2 id="community-first"><a class="header" href="#community-first">Community First</a></h2>
<p>The collective effort of the community moves the project forward and makes the project awesome for everyone. When we make a decision, it is always helpful to keep the community in mind. Here are some example questions that we can ask:</p>
<ul>
<li>How can I encourage new contributors to get more involved in the project?</li>
<li>Can I help to save my fellow committers' time?</li>
<li>Have I enabled the rest of the community to participate the design proposals?</li>
</ul>
<h2 id="public-archive-principle"><a class="header" href="#public-archive-principle">Public Archive Principle</a></h2>
<p>While private channels such as face to face discussion are useful for development, they also create barriers for the broader community's participation. An open way of development suggests all decisions to be made in public channels, which are archived and accessible to everyone. As a result, any contributor can keep up with the development by watching the archives and join the development anytime.</p>
<p>While this principle applies to every contributor, it is especially important for committers. Here are some example applications of this principle:</p>
<ul>
<li>When getting a project-related question from a personal channel, encourage the person to open a public thread in the <a href="https://internals.tidb.io/">TiDB Internals forum</a>, so others in the community can benefit from the answer.</li>
<li>After an in-person discussion, send a summary to public channels (as an RFC or a discuss topic).</li>
</ul>
<h2 id="shepherd-a-pull-request"><a class="header" href="#shepherd-a-pull-request">Shepherd a Pull Request</a></h2>
<p>Here are some tips to shepherd a pull request. You can also take a look at <a href="contribute-to-tidb/review-a-pr.html">Review a Pull Request</a>.</p>
<ul>
<li>Assign the PR to yourself, so that other committers know that the PR has already been tended to.</li>
<li>Make use of the status label to indicate the current status.</li>
<li>Check if a design document needs to be present.</li>
<li>If the contributor has not requested a reviewer, kindly ask the contributor to do so. If the PR comes from a new contributor, help the contributor to request reviewers and ask the contributor to do so next time.</li>
<li>Moderate the reviews, ask reviewers to approve explicitly.</li>
<li>Mark the PR as accepted and acknowledge the contributor/reviewers.</li>
<li>Merge the PR :)</li>
</ul>
<h2 id="time-management"><a class="header" href="#time-management">Time Management</a></h2>
<p>There are many things that a committer can do, such as moderating discussions, pull request reviews and code contributions.</p>
<p>Working on an open source project can be rewarding, but also be a bit overwhelming sometimes. A little bit of time management might be helpful to alleviate the problem. For example, some committers have a &quot;community day&quot; in a week when they actively manage outstanding PRs, but watch the community less frequently in the rest of the time.</p>
<p>Remember that your merit will never go away, so please take your time and pace when contributing to the project:)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous-topics"><a class="header" href="#miscellaneous-topics">Miscellaneous Topics</a></h1>
<h2 id="communication-channels"><a class="header" href="#communication-channels">Communication channels</a></h2>
<ul>
<li><a href="https://internals.tidb.io">TiDB Internals Forum</a>: TiDB hosts a Discourse instance for TiDB development discussions. It has many separate categories for different topics. You can discuss anything about TiDB development and community in the forum.</li>
</ul>
<h2 id="related-projects"><a class="header" href="#related-projects">Related projects</a></h2>
<ul>
<li><a href="https://github.com/tikv/tikv">TiKV</a>: TiKV is an open-source, distributed, and transactional key-value database. It is used by TiDB as the storage layer.</li>
<li><a href="https://university.pingcap.com/talent-plan/">Talent Plan</a>: Talent Plan is an open source training program initiated by PingCAP. It aims to create and combine some open source learning materials for people interested in open source, distributed systems, Rust, Golang, and other infrastructure knowledges.</li>
</ul>
<h2 id="community-events"><a class="header" href="#community-events">Community events</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introduction-of-tidb-architecture"><a class="header" href="#introduction-of-tidb-architecture">Introduction of TiDB Architecture</a></h1>
<p>Understanding TiDB talks about the architecture of TiDB, the modules it consists of, and the responsibility of each module.</p>
<h2 id="tidb-architecture"><a class="header" href="#tidb-architecture">TiDB Architecture</a></h2>
<p>When people refer to TiDB, they usually refer to the entire TiDB distributed database that includes three components: the TiDB stateless server, the Placement Driver (PD) server, and the storage server, TiKV or TiFlash. The TiDB server does not store data; it only computes and processes SQL queries. The PD server is the managing components of the entire cluster. The storage server is responsible for persistently storing data.</p>
<p>Let's see an architecture graph from TiDB stateless server's perspective.</p>
<p><img src="understand-tidb/../img/tidb-architecture.png" alt="tidb-architecture" /></p>
<p>As you can see, TiDB is a SQL engine that supports the MySQL protocol with some kind of distributed KV storage engine that supports transactions as the underlying storage.</p>
<p>Here come three significant questions.</p>
<ol>
<li>How to support MySQL protocol?</li>
<li>How to communicate with storage engine, store and load data?</li>
<li>How to implement SQL functions?</li>
</ol>
<p>This section will start with a few of brief descriptions of what modules TiDB has and what they do, and then put them together to answer these three questions.</p>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>TiDB source code is fully hosted on Github, you can see all the information from the <a href="https://github.com/pingcap/tidb">repository homepage</a>. The whole repository is developed in Golang and divided into many packages according to functional modules.</p>
<p>Most of the packages export services in the form of interfaces, and most of the functionality is concentrated in one package. But there are packages that provide basic functionality and are dependent on many packages, so these packages need special attention.</p>
<p>The main method of TiDB locates in <code>tidb-server/main.go</code>, which defines how the service is started.</p>
<p>The build system of the entire project can be found in the <code>Makefile</code>.</p>
<p>In addition to the code, there are many test cases, which can be found with suffix <code>_test.go</code>. There is also toolkit under the <code>cmd</code> directory for doing performance tests or constructing test data.</p>
<h3 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h3>
<p>TiDB has a number of modules. Table below is an overview that shows what each module does, and if you want to see the code for the relevant function, you can find the corresponding module directly.</p>
<table><thead><tr><th align="left">Package</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/bindinfo">pingcap/tidb/bindinfo</a></td><td align="left">Handles all global sql bind operations, and caches the sql bind info from storage.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/config">pingcap/tidb/config</a></td><td align="left">The configuration definition.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/ddl">pingcap/tidb/ddl</a></td><td align="left">The execution logic of data definition language (DDL).</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/distsql">pingcap/tidb/distsql</a></td><td align="left">The abstraction of the distributed computing interfaces to isolate the logic between the executor and the TiKV client</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/domain">pingcap/tidb/domain</a></td><td align="left">The abstraction of a storage space in which databases and tables can be created. Like namespace, databases with the same name can exist in different domains. In most cases, a single TiDB instance only creates one Domain instance with details about the information schema and statistics.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/errno">pingcap/tidb/errno</a></td><td align="left">The definition of MySQL error code, error message, and error summary.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/executor">pingcap/tidb/executor</a></td><td align="left">The operator related code that contains the execution logic of most statements.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/expression">pingcap/tidb/expression</a></td><td align="left">The expression-related code that contains various operators and built-in functions.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/infoschema">pingcap/tidb/infoschema</a></td><td align="left">The metadata management module for SQL statements; accessed when all the operations on the information schema are executed.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/kv">pingcap/tidb/kv</a></td><td align="left">The Key-Value engine interface and some public methods; the interfaces defined in this package need to be implemented by the storage engine which is going to adapt TiDB SQL layer.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/lock">pingcap/tidb/lock</a></td><td align="left">The implementation of LOCK/UNLOCK TABLES.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/meta">pingcap/tidb/meta</a></td><td align="left">Manages the SQL metadata in the storage engine through the features of the structure package; infoschema and DDL use this module to access or modify the SQL metadata .</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/meta/autoid">pingcap/tidb/meta/autoid</a></td><td align="left">A module to generate the globally unique monotonically incremental IDs for each table, as well as the database ID and table ID.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/metrics">pingcap/tidb/metrics</a></td><td align="left">Store the metrics information of all modules.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/owner">pingcap/tidb/owner</a></td><td align="left">Some tasks in the TiDB cluster can be executed by only one instance, such as the asynchronous schema change. This owner module is used to coordinate and generate a task executor among multiple TiDB servers. Each task has its own executor.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/parser">pingcap/tidb/parser</a></td><td align="left">A MySQL compatible SQL parser used by TiDB, also contains the data structure definition of abstract syntax tree (AST) and other metadata.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner">pingcap/tidb/planner</a></td><td align="left">Queries optimization related code.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/plugin">pingcap/tidb/plugin</a></td><td align="left">The plugin framework of TiDB.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/privilege">pingcap/tidb/privilege</a></td><td align="left">The management interface of user privileges.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/server">pingcap/tidb/server</a></td><td align="left">Code of the MySQL protocol and connection management.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/session">pingcap/tidb/session</a></td><td align="left">Code of session management.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/binloginfo">pingcap/tidb/sessionctx/binloginfo</a></td><td align="left">Output binlog information.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/stmtctx">pingcap/tidb/sessionctx/stmtctx</a></td><td align="left">Necessary information for the statement of a session during runtime.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/sessionctx/variable">pingcap/tidb/sessionctx/variable</a></td><td align="left">System variable related code.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/statistics">pingcap/tidb/statistics</a></td><td align="left">Code of table statistics.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/store">pingcap/tidb/store</a></td><td align="left">Storage engine drivers, wrapping Key-Value client to meet the requirements of TiDB.</td></tr>
<tr><td align="left"><a href="https://github.com/tikv/client-go">tikv/client-go</a></td><td align="left">The Go client of TiKV.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/structure">pingcap/tidb/structure</a></td><td align="left">The structured API defined on the Transactional Key-Value API, providing structures like List, Queue, and HashMap.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/table">pingcap/tidb/table</a></td><td align="left">The abstraction of Table in SQL.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/tablecodec">pingcap/tidb/tablecodec</a></td><td align="left">Encode and decode data from SQL to Key-Value. See the codec package for the specific encoding and decoding solution for each data type.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/telemetry">pingcap/tidb/telemetry</a></td><td align="left">Code of telemetry collect and report.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/tidb-server">pingcap/tidb/tidb-server</a></td><td align="left">The main method of the TiDB service.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/types">pingcap/tidb/types</a></td><td align="left">All the type related code, including the definition of and operation on types.</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/util">pingcap/tidb/util</a></td><td align="left">Utilities.</td></tr>
</tbody></table>
<p>At a glance, TiDB has 80 packages, which might let you feel overwhelmed, but not all of them are important, and some features only involve a small number of packages, so where to start to look at the source code depends on the purpose of looking at the source code.</p>
<p>If you want to understand the implementation details of a specific feature, then you can refer to the module description above and just find the corresponding module.</p>
<p>If you want to have a comprehensive understanding of the source code, then you can start from <code>tidb-server/main.go</code> and see how tidb-server starts and how it waits for and handles user requests. Then follow the code all the way through to see the exact execution of the SQL. There are also some important modules that need to be looked at to know how they are implemented. For the auxiliary modules, you can look at them selectively to get a general impression.</p>
<h3 id="sql-layer-architecture"><a class="header" href="#sql-layer-architecture">SQL Layer Architecture</a></h3>
<p><img src="understand-tidb/../img/sql-layer-architecture.png" alt="sql-layer-architecture" /></p>
<p>This is a detailed SQL layer architecture graph. You can read it from left to right.</p>
<h3 id="protocol-layer"><a class="header" href="#protocol-layer">Protocol Layer</a></h3>
<p>The leftmost is the Protocol Layer of TiDB, this is the interface to interact with Client, currently TiDB only supports MySQL protocol, the related code is in the <code>server</code> package.</p>
<p>The purpose of this layer is to manage the client connection, parse MySQL commands and return the execution result. The specific implementation is according to MySQL protocol, you can refer to <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL Client/Server Protocol document</a>. If you need to use MySQL protocol parsing and processing functions in your project, you can refer to this module.</p>
<p>The logic for connection establishment is in the <code>Run()</code> method of <code>server.go</code>, mainly in the following two lines.</p>
<pre><code class="language-go">conn, err := s.listener.Accept()
clientConn := s.newConn(conn)
go s.onConn(clientConn)
</code></pre>
<p>The entry method for a single session processing command is to call the <code>dispatch</code> method of the <code>clientConn</code> class, where the protocol is parsed and passed to a different handler.</p>
<h3 id="sql-layer"><a class="header" href="#sql-layer">SQL Layer</a></h3>
<p>Generally speaking, a SQL statement needs to go through a series of processes: </p>
<ol>
<li>syntax parsing</li>
<li>validity verification</li>
<li>building query plan </li>
<li>optimizing query plan</li>
<li>generating executor according to plan</li>
<li>executing and returning results</li>
</ol>
<p>These processes locate at the following modules:</p>
<table><thead><tr><th align="left">Package</th><th align="left">Usage</th></tr></thead><tbody>
<tr><td align="left">pingcap/tidb/sever</td><td align="left">Interface between protocol layer and SQL layer</td></tr>
<tr><td align="left">pingcap/tidb/parser</td><td align="left">SQL parsing and syntax analyze</td></tr>
<tr><td align="left">pingcap/tidb/planner</td><td align="left">Validation, query plan building, query plan optimizing</td></tr>
<tr><td align="left">pingcap/tidb/executor</td><td align="left">Executor generation and execution</td></tr>
<tr><td align="left">pingcap/tidb/distsql</td><td align="left">Send request to TiKV and aggregate return results from TiKV via TiKV Client</td></tr>
<tr><td align="left">pingcap/tidb/kv</td><td align="left">KV client interface</td></tr>
<tr><td align="left">tikv/client-go</td><td align="left">TiKV Go Client</td></tr>
</tbody></table>
<h3 id="kv-api-layer"><a class="header" href="#kv-api-layer">KV API Layer</a></h3>
<p>TiDB relies on the underlying storage engine to store and load data. It does not rely on a specific storage engine (such as TiKV), but has some requirements for the storage engine, and any engine that meets these requirements can be used (TiKV is the most suitable one).</p>
<p>The most basic requirement is &quot;Key-Value engine with transactions and Golang driver&quot;. The more advanced requirement is &quot;support for distributed computation interface&quot;, so that TiDB can push some computation requests down to the storage engine.</p>
<p>These requirements can be found in the interfaces of the <code>kv</code> package, and the storage engine needs to provide a Golang driver that implements these interfaces, which TiDB then uses to manipulate the underlying data.</p>
<p>As for the most basic requirement, these interfaces are related:</p>
<ul>
<li><code>Transaction</code>: Basic manipulation of transaction</li>
<li><code>Receiver</code>: Interface for reading data</li>
<li><code>Mutator</code>: Interface for mutating data</li>
<li><code>Storage</code>: Basic functionality provided by the driver</li>
<li><code>Snapshot</code>: Basic manipulation of data snapshot</li>
<li><code>Iterator</code>: Result of <code>Seek</code>, used to iterate data</li>
</ul>
<p>With the above interfaces, you are able to do all the required operations on the data and complete all the SQL functions. However, for more efficient computing, we have also defined an advanced computing interface, which can focus on these three interfaces or structures:</p>
<ul>
<li><code>Client</code>: Send request to storage engine</li>
<li><code>Request</code>: Payload of the request</li>
<li><code>Response</code>: Abstraction of result</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This section talks about the source structure of TiDB and the architecture of three significant components. More details will be described in the later sections.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-life-cycle-of-a-statement"><a class="header" href="#the-life-cycle-of-a-statement">The Life cycle of a Statement</a></h1>
<h2 id="mysql-protocol-package-with-command-and-statement-string"><a class="header" href="#mysql-protocol-package-with-command-and-statement-string">MySQL protocol package with command and statement string</a></h2>
<p>After connecting and getting authenticated, the server is in a <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L938">statement execution loop</a> until the client is disconnected.</p>
<p>The <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1111">dispatch</a> function checks what kind of command was sent through the MySQL protocol and dispatches the matching function, like this snippet:</p>
<pre><code class="language-golang">	switch cmd {
	// ...
	case mysql.ComQuit:
		return io.EOF
	case mysql.ComInitDB:
		if err := cc.useDB(ctx, dataStr); err != nil {
			return err
		}
		return cc.writeOK(ctx)
	case mysql.ComQuery: // Most frequently used command.
		return cc.handleQuery(ctx, dataStr)
	// ...
	}
</code></pre>
<p>Where <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/mysql/const.go#L102">mysql.ComQuery</a> is routed to <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1633">handleQuery</a>, which handles all different non-prepared statements (some commands like change database/schema or ping are handled directly in the dispatch function).</p>
<p>TiDB keep the state between statements like sql_mode, transaction state etc. in the clientConn's <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/sessionctx/context.go#L43">sessionctx.Context</a> struct.</p>
<p>The MySQL protocol is synchronous, and the typical execution flow revolves around a client sending a single query, and receiving an optional result set ending with an OK package containing the success flag and optional warnings/errors and possible metadata such as affected rows.</p>
<p>As shown here; it is possible that a client might send multiple queries in one mysql.ComQuery call, in which case the cc.ctx.Parse will return multiple results. However; this is not a common occurrence. By default, multiple statements in one mysql.ComQuery call is disabled for security reasons, like making sql injections like <code>SELECT user FROM users WHERE id = ''/* sql injection */; INSERT INTO users VALUES (null, 'EvilUser'); -- '</code>. Clients must explicitly enable the ClientMultiStatements protocol feature.</p>
<h2 id="high-level-code-for-handling-a-query"><a class="header" href="#high-level-code-for-handling-a-query">High level code for handling a query</a></h2>
<p>Real types and function names, but only high level for less distraction by too much details</p>
<p>Further explanations below.</p>
<pre><code class="language-golang">// handleQuery is the entry point for running client connection statements/queries
func (cc *clientConn) handleQuery(ctx context.Context, sql string) (error) {
	stmts, err := cc.ctx.Parse(ctx, sql)
	// ...
	for i, stmt := range stmts {
		retryable, err = cc.handleStmt(ctx, stmt, ...)
		// ...
	}
}

// handleStmt handles a single statement
func (cc *clientConn) handleStmt(ctx context.Context, stmt ast.StmtNode, ...) (bool, error) {
	resultSet, err := cc.ctx.ExecuteStmt(ctx, stmt)
	// ...
	retryable, err := cc.writeResultset(ctx, resultSet, ...)
	// ...
}

func (tc *TiDBContext) ExecuteStmt(ctx context.Context, stmt ast.StmtNode) (ResultSet, error) {
	resultSet, err := tc.Session.ExecuteStmt(ctx, stmt)
	// ...
	return resultSet, err
}

// ExecuteStmt takes an Abstract Syntax Tree and will go through the optimizer and start the execution
// and return a recordSet.
func (s *session) ExecuteStmt(ctx context.Context, stmtNode ast.StmtNode) (sqlexec.RecordSet, error) {
	// ...
	compiler := executor.Compiler{Ctx: s}
	stmt, err := compiler.Compile(ctx, stmtNode)
	// ...
	resultSet, err := runStmt(ctx, s, stmt)
	// ...
	return resultSet, err
}

// Compile compiles an ast.StmtNode to a physical plan.
func (c *Compiler) Compile(ctx context.Context, stmtNode ast.StmtNode) (*ExecStmt, error) {
	// ...
	// PrepareTxnCtx starts a goroutine to begin a transaction if needed, and creates a new transaction context.
	s.PrepareTxnCtx(ctx)

	// Preprocess resolves table names of the node, and checks some statements validation.
	err := plannercore.Preprocess(c.Ctx, stmtNode, plannercore.WithPreprocessorReturn(ret), plannercore.WithExecuteInfoSchemaUpdate(pe))
	// ...
	// Optimize does optimization and creates a Plan.
	// The node must be prepared first.
	finalPlan, names, err := planner.Optimize(ctx, c.Ctx, stmtNode, ret.InfoSchema)
}

// runStmt executes the sqlexec.Statement and commit or rollback the current transaction.
func runStmt(ctx context.Context, se *session, s sqlexec.Statement) (sqlexec.RecordSet, error) {
	rs, err := s.Exec(ctx)
	// ...
	return &amp;execStmtResult{RecordSet: rs, ...}, err
}

// writeResultset iterates over the Resultset and sends it to the client connection.
func (cc *clientConn) writeResultset(ctx context.Context, rs ResultSet ...) (bool, error) {
	retryable, err = cc.writeChunks(ctx, rs, ...)
	// ...
	return false, cc.flush(ctx)
}

// writeChunks writes data from a Chunk, which filled data by a ResultSet, into a connection.
func (cc *clientConn) writeChunks(ctx context.Context, rs ResultSet ...) (bool, error) {
	req := rs.NewChunk()
	for {
		err := rs.Next(ctx, req)
		// ...
		rowCount := req.NumRows()
		if rowCount == 0 {
			break
		}
		cc.writePacket(...)
	}
	return false, cc.writeEOF(...)
}
</code></pre>
<h2 id="statement-string-to-abstract-syntax-tree"><a class="header" href="#statement-string-to-abstract-syntax-tree">Statement string to Abstract Syntax Tree</a></h2>
<p>In <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1633">handleQuery</a> the statement string is <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/yy_parser.go#L172">parsed</a> by <a href="https://github.com/pingcap/tidb/tree/master/parser">the parser</a>, that is a MySQL compatible parser parsing statements and returns an Abstract Syntax Tree (AST) representing the statement. See more in the <a href="understand-tidb/parser.html">parser section</a></p>
<p>Example of Abstract Syntax tree, the fragment of a <code>WHERE</code> clause <code>`id` &gt; 1 AND `value` = 'Second'</code> looks like:</p>
<pre><code class="language-golang">ast.BinaryOperationExpr{
  Op: opcode.LogicAnd,
  L:  ast.BinaryOperationExpr{
    Op: opcode.GT,
    L:  ast.ColumnName{Name: 'id'},
    R:  parser_driver.ValueExpr{i: 1}
  },
  R: ast.BinaryOperationExpr{
    Op: opcode.EQ,
    L:  ast.ColumnName{Name: 'value'},
    R:  parser_driver.ValueExpr{b: 'Second'}
  },
}
</code></pre>
<h2 id="ast---physical-execution-plan"><a class="header" href="#ast---physical-execution-plan">AST -&gt; Physical execution plan</a></h2>
<p>Then the statement in AST form is handled in <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1814">handleStmt</a>/<a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/session/session.go#L1620">ExecuteStmt</a> where the Abstract Syntax Tree is <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/executor/compiler.go#L50">compiled</a> first to a logical plan and then to a physical execution plan, including <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/planner/optimize.go#L100">optimizing</a> the execution plan, through a cost based optimizer. There are several steps in this process, such as name resolution, transaction management, <a href="understand-tidb/privilege.html">privilege checks</a>, handling given hints, etc.</p>
<p>One important thing to note is the <code>planner.TryFastPlan()</code> function that checks if there is a shortcut for a PointGet plan, to avoid spending too much time in the optimizer for <em>simple</em> queries, like primary key lookups.</p>
<p>For deeper understanding, please read the <a href="understand-tidb/planner.html">planner section</a></p>
<p>Example of plan from a simple select:</p>
<pre><code class="language-sql">tidb&gt; explain select id, value from t where id &gt; 1 and value = 'Second';
+--------------------------+---------+-----------+---------------+----------------------------------+
| id                       | estRows | task      | access object | operator info                    |
+--------------------------+---------+-----------+---------------+----------------------------------+
| TableReader_7            | 0.00    | root      |               | data:Selection_6                 |
| └─Selection_6            | 0.00    | cop[tikv] |               | eq(test.t.value, &quot;Second&quot;)       |
|   └─TableRangeScan_5     | 1.00    | cop[tikv] | table:t       | range:(1,+inf], keep order:false |
+--------------------------+---------+-----------+---------------+----------------------------------+
</code></pre>
<p>Where TableReader_7 is the task which will run in TiDB, getting already filtered data from Selection_6 scheduled on the storage nodes (TiKV/TiFlash) directly connected to the storage nodes Table/index range scan task/coprocessor, TableRangeScan_5.</p>
<h2 id="executing-the-optimized-plan"><a class="header" href="#executing-the-optimized-plan">Executing the optimized plan</a></h2>
<p>The optimized plan is executed through <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/session/session.go#L1750">runStmt</a>, which builds an <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/executor/adapter.go#L319">executor</a> from the plan and will return a record set or directly execute the statements in case no records will be returned, like <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> statements. Before returning the record set, the executor starts the execution by calling the Volcano inspired <code>Open()</code> API and the <code>Next()</code> API to retrieve the first chunk of data or execute the statement fully if no records are to be returned.</p>
<p>The executors are often including coprocessors as seen above, where tasks can be seen as stream processors and can be parallelized and delegated to storage nodes (TiKV/TiFlash).</p>
<p>For Data Manipulation Language statements, the changes are buffered in a transaction buffer on the TiDB node, which is different in how MySQL/InnoDB handles it (where the changes are done directly in the btrees and undone in case of rollback. More information in the <a href="understand-tidb/dml.html">DML section</a></p>
<h3 id="requests-sent-to-tikvtiflash-coprocessors"><a class="header" href="#requests-sent-to-tikvtiflash-coprocessors">Requests sent to TiKV/TiFlash coprocessors</a></h3>
<p>During the execution different task are executed as coprocessors and delegated/pushed down to the storage nodes (TiKV/TiFlash) for both scaling and more optimized use of the cluster.</p>
<p>This way there is less data sent between TiDB nodes and TiKV/TiFlash nodes (only filtered and aggregated results) and the computation/load are distributed across several storage nodes.</p>
<p>Common coprocessors are: TableScan (simplest form no real optimisation), IndexScan (Range reads from index), Selection (Filter on condition, <code>WHERE</code> clause etc.), LIMIT (no more than N records), TopN (Order + Limit), Aggregation (<code>GROUP BY</code>)</p>
<pre><code class="language-golang">// HandleStreamRequest handles the coprocessor stream request.
func (h *CoprocessorDAGHandler) HandleStreamRequest(ctx context.Context, req *coprocessor.Request, stream tikvpb.Tikv_CoprocessorStreamServer) error {
  e, err := h.buildDAGExecutor(req)
  err = e.Open(ctx)
  chk := newFirstChunk(e)
  for {
    chk.Reset()
    err = Next(ctx, e, chk)
    // ...
    if chk.NumRows() == 0 {
       return h.buildResponseAndSendToStream(chk, ...)
    }
  }
}
</code></pre>
<p>As seen above the Volcano inspired execution is iterating over <code>chunks</code> of data, not records one-by-one, which also allows for vectorization, which formats the chunk data so it can be processed as a vector instead of looping over each record and column one by one.</p>
<h3 id="sending-the-result-back-to-the-client"><a class="header" href="#sending-the-result-back-to-the-client">Sending the result back to the client</a></h3>
<p>If the statement returns a record set, it is handled in <a href="https://github.com/pingcap/tidb/blob/30cf15a59db11c34ffe05fc926152a43327eaa61/server/conn.go#L1993">writeChunks</a> which loops over the record set's <code>Next()</code> until empty and then adds some context/metadata to the MySQL OK package and flushes the data back to the client.</p>
<p>Notice that things like error handling, tracing etc. are not explained in this page.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ddl---data-definition-language--schema-change-handling"><a class="header" href="#ddl---data-definition-language--schema-change-handling">DDL - Data Definition Language / Schema change handling</a></h1>
<h2 id="a-short-introduction-to-tidbs-ddl"><a class="header" href="#a-short-introduction-to-tidbs-ddl">A short introduction to TiDB's DDL</a></h2>
<p>The design behind TiDB's DDL implementation can be read in the <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2018-10-08-online-DDL.md">Online DDL design doc</a>.</p>
<p>TiDB is a distributed database which needs to have a consistent view of all schemas across the whole cluster. To achieve this in a more asynchronous way, the system uses internal states where each single stage transition is done so that the old/previous stage is compatible with the new/current state, allowing different TiDB Nodes having different versions of the schema definition. All TiDB servers in a cluster shares at most two schema versions/states at the same time, so before moving to the next state change, all currently available TiDB servers needs to be synchronized with the current state.</p>
<p>The states used are defined in <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/model/model.go#L33">tidb/parser/model/model.go</a>:</p>
<pre><code class="language-golang">        // StateNone means this schema element is absent and can't be used.
        StateNone SchemaState = iota
        // StateDeleteOnly means we can only delete items for this schema element.
        StateDeleteOnly
        // StateWriteOnly means we can use any write operation on this schema element,
        // but outer can't read the changed data.
        StateWriteOnly
        // StateWriteReorganization means we are re-organizing whole data after write only state.
        StateWriteReorganization
        // StateDeleteReorganization means we are re-organizing whole data after delete only state.
        StateDeleteReorganization
        // StatePublic means this schema element is ok for all write and read operations.
        StatePublic
</code></pre>
<p>Note: this is a very different implementation from MySQL, which uses Meta Data Locks (MDL) for keeping a single version of the MySQL instance schemas at a time. This results in MySQL replicas can have different version of the schemas, due to lag in asyncronous replication. TiDB has always a consistent view of all schemas in the cluster.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>All DDL jobs goes through two cluster wide DDL Queues:</p>
<ul>
<li>Generic queue for non data changes, <a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/meta/meta.go#L687">DefaultJobListKey</a>.</li>
<li>Add Index Queue for data changes/reorganizations, <a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/meta/meta.go#L689">AddIndexJobListKey</a>, to not block DDLs that does not require data reorganization/backfilling).</li>
</ul>
<p>The two base operations for these queue are:</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/meta/meta.go#L701">enqueue</a>, adding one DDL job to the end of the queue.</li>
<li><a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/meta/meta.go#L722">dequeue</a>, pop the first DDL job from the queue (removing it from the queue and returning it).</li>
</ul>
<p>When a DDL job is completed it will be <a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/meta/meta.go#L883">moved to the DDL history</a>.</p>
<p>There are two main execution parts handling DDLs:</p>
<ul>
<li>TiDB session, which executes your statements. This will parse and validate the SQL DDL statement, create a <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/model/ddl.go#L213">DDL job</a>, and enqueue it in the corresponding queue. It will then monitor the DDL History until the operation is complete (succeeded or failed) and return the result back to the MySQL client.</li>
<li>DDL background goroutines:
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/ddl/ddl_worker.go#L257">limitDDLJobs</a> which takes tasks from the sessions and adds to the DDL queues in batches.</li>
<li><a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/ddl/ddl_worker.go#L154">workers</a> for processing DDLs:
<ul>
<li>General worker, handling the default DDL queue where only metadata changes are needed.</li>
<li>Add Index worker, which updates/backfills data requested in the AddIndexJob queue.</li>
</ul>
</li>
<li><a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/owner/manager.go#L226">DDL owner manager</a> managing that one and only one TiDB node in the cluster is the DDL manager.</li>
</ul>
</li>
</ul>
<h3 id="execution-in-the-tidb-session"><a class="header" href="#execution-in-the-tidb-session">Execution in the TiDB session</a></h3>
<p>The execution of the DDL is started through the 'Next' iterator of the DDLExec class (just like normal query execution):</p>
<pre><code> 0  0x0000000003cd6cd5 in github.com/pingcap/tidb/executor.(*DDLExec).Next
    at ./executor/ddl.go:90
 1  0x0000000003cf3034 in github.com/pingcap/tidb/executor.Next
    at ./executor/executor.go:286
 2  0x0000000003c1f085 in github.com/pingcap/tidb/executor.(*ExecStmt).handleNoDelayExecutor
    at ./executor/adapter.go:584
 3  0x0000000003c1d890 in github.com/pingcap/tidb/executor.(*ExecStmt).handleNoDelay
    at ./executor/adapter.go:465
 4  0x0000000003c1d11e in github.com/pingcap/tidb/executor.(*ExecStmt).Exec
    at ./executor/adapter.go:414
 5  0x0000000003eedb56 in github.com/pingcap/tidb/session.runStmt
    at ./session/session.go:1682
 6  0x0000000003eec639 in github.com/pingcap/tidb/session.(*session).ExecuteStmt
    at ./session/session.go:1576
 7  0x0000000003fab0af in github.com/pingcap/tidb/server.(*TiDBContext).ExecuteStmt
    at ./server/driver_tidb.go:219
 8  0x0000000003f9c785 in github.com/pingcap/tidb/server.(*clientConn).handleStmt
    at ./server/conn.go:1841
 9  0x0000000003f9a5f2 in github.com/pingcap/tidb/server.(*clientConn).handleQuery
    at ./server/conn.go:1710
10  0x0000000003f94f9c in github.com/pingcap/tidb/server.(*clientConn).dispatch
    at ./server/conn.go:1222
11  0x0000000003f9133f in github.com/pingcap/tidb/server.(*clientConn).Run
    at ./server/conn.go:979
12  0x0000000003fd5798 in github.com/pingcap/tidb/server.(*Server).onConn
    at ./server/server.go:536
13  0x00000000012c4dc1 in runtime.goexit
    at /usr/lib/go-1.16/src/runtime/asm_amd64.s:1371
</code></pre>
<p>Where the different DDL operations are executed as their own functions, like:</p>
<pre><code class="language-golang">        switch x := e.stmt.(type) {
        case *ast.AlterDatabaseStmt:
                err = e.executeAlterDatabase(x)
        case *ast.AlterTableStmt:
                err = e.executeAlterTable(ctx, x)
        case *ast.CreateIndexStmt:
                err = e.executeCreateIndex(x)
        case *ast.CreateDatabaseStmt:
                err = e.executeCreateDatabase(x)
        case *ast.CreateTableStmt:
                err = e.executeCreateTable(x)
        case *ast.CreateViewStmt:
                err = e.executeCreateView(x)
        case *ast.DropIndexStmt:
                err = e.executeDropIndex(x)
        case *ast.DropDatabaseStmt:
                err = e.executeDropDatabase(x)
</code></pre>
<p>Let us use the simple CREATE TABLE as an example (which does not need any of the WriteOnly or DeleteOnly states):</p>
<pre><code class="language-sql">CREATE TABLE t (id int unsigned NOT NULL PRIMARY KEY, notes varchar(255));
</code></pre>
<p>This statement has the CreateTableStmt Abstract Syntax Tree type and will be handled by <a href="https://github.com/pingcap/tidb/blob/7fd60012336c46158df46c30d095a364fcc103f3/executor/ddl.go#L295">executeCreateTable</a>/<a href="https://github.com/pingcap/tidb/blob/7fd60012336c46158df46c30d095a364fcc103f3/ddl/ddl_api.go#L1862">CreateTable</a> functions.</p>
<p>It will fill in a <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/model/model.go#L269">TableInfo</a> struct according to the table definition in the statement and create a <a href="https://github.com/pingcap/tidb/blob/9f68c8e92a994e4790bfd9e567e5ad86c8daa861/parser/model/ddl.go#L213">DDL job</a> and call <a href="https://github.com/pingcap/tidb/blob/7fd60012336c46158df46c30d095a364fcc103f3/ddl/ddl.go#L541">doDDLJob</a> which goes through the <a href="https://github.com/pingcap/tidb/blob/6eb02fbe5ed448a2c814dd5563414fb733274329/ddl/ddl_worker.go#L257">limitDDLJobs</a> goroutine and adds one or more jobs to the DDL job queue in <a href="https://github.com/pingcap/tidb/blob/6eb02fbe5ed448a2c814dd5563414fb733274329/ddl/ddl_worker.go#L279">addBatchDDLJobs</a></p>
<p>DDL job encoded as JSON:</p>
<pre><code class="language-json">{
  &quot;id&quot;: 56,
  &quot;type&quot;: 3,
  &quot;schema_id&quot;: 1,
  &quot;table_id&quot;: 55,
  &quot;schema_name&quot;: &quot;test&quot;,
  &quot;state&quot;: 0,
  &quot;err&quot;: null,
  &quot;err_count&quot;: 0,
  &quot;row_count&quot;: 0,
  &quot;raw_args&quot;: [
    {
      &quot;id&quot;: 55,
      &quot;name&quot;: {
        &quot;O&quot;: &quot;t&quot;,
        &quot;L&quot;: &quot;t&quot;
      },
      &quot;charset&quot;: &quot;utf8mb4&quot;,
      &quot;collate&quot;: &quot;utf8mb4_bin&quot;,
      &quot;cols&quot;: [
        {
          &quot;id&quot;: 1,
          &quot;name&quot;: {
            &quot;O&quot;: &quot;id&quot;,
            &quot;L&quot;: &quot;id&quot;
          },
          &quot;offset&quot;: 0,
          &quot;origin_default&quot;: null,
          &quot;origin_default_bit&quot;: null,
          &quot;default&quot;: null,
          &quot;default_bit&quot;: null,
          &quot;default_is_expr&quot;: false,
          &quot;generated_expr_string&quot;: &quot;&quot;,
          &quot;generated_stored&quot;: false,
          &quot;dependences&quot;: null,
          &quot;type&quot;: {
            &quot;Tp&quot;: 3,
            &quot;Flag&quot;: 4131,
            &quot;Flen&quot;: 10,
            &quot;Decimal&quot;: 0,
            &quot;Charset&quot;: &quot;binary&quot;,
            &quot;Collate&quot;: &quot;binary&quot;,
            &quot;Elems&quot;: null
          },
          &quot;state&quot;: 5,
          &quot;comment&quot;: &quot;&quot;,
          &quot;hidden&quot;: false,
          &quot;change_state_info&quot;: null,
          &quot;version&quot;: 2
        },
        {
          &quot;id&quot;: 2,
          &quot;name&quot;: {
            &quot;O&quot;: &quot;notes&quot;,
            &quot;L&quot;: &quot;notes&quot;
          },
          &quot;offset&quot;: 1,
          &quot;origin_default&quot;: null,
          &quot;origin_default_bit&quot;: null,
          &quot;default&quot;: null,
          &quot;default_bit&quot;: null,
          &quot;default_is_expr&quot;: false,
          &quot;generated_expr_string&quot;: &quot;&quot;,
          &quot;generated_stored&quot;: false,
          &quot;dependences&quot;: null,
          &quot;type&quot;: {
            &quot;Tp&quot;: 15,
            &quot;Flag&quot;: 0,
            &quot;Flen&quot;: 255,
            &quot;Decimal&quot;: 0,
            &quot;Charset&quot;: &quot;utf8mb4&quot;,
            &quot;Collate&quot;: &quot;utf8mb4_bin&quot;,
            &quot;Elems&quot;: null
          },
          &quot;state&quot;: 5,
          &quot;comment&quot;: &quot;&quot;,
          &quot;hidden&quot;: false,
          &quot;change_state_info&quot;: null,
          &quot;version&quot;: 2
        }
      ],
      &quot;index_info&quot;: null,
      &quot;constraint_info&quot;: null,
      &quot;fk_info&quot;: null,
      &quot;state&quot;: 0,
      &quot;pk_is_handle&quot;: true,
      &quot;is_common_handle&quot;: false,
      &quot;common_handle_version&quot;: 0,
      &quot;comment&quot;: &quot;&quot;,
      &quot;auto_inc_id&quot;: 0,
      &quot;auto_id_cache&quot;: 0,
      &quot;auto_rand_id&quot;: 0,
      &quot;max_col_id&quot;: 2,
      &quot;max_idx_id&quot;: 0,
      &quot;max_cst_id&quot;: 0,
      &quot;update_timestamp&quot;: 0,
      &quot;ShardRowIDBits&quot;: 0,
      &quot;max_shard_row_id_bits&quot;: 0,
      &quot;auto_random_bits&quot;: 0,
      &quot;pre_split_regions&quot;: 0,
      &quot;partition&quot;: null,
      &quot;compression&quot;: &quot;&quot;,
      &quot;view&quot;: null,
      &quot;sequence&quot;: null,
      &quot;Lock&quot;: null,
      &quot;version&quot;: 4,
      &quot;tiflash_replica&quot;: null,
      &quot;is_columnar&quot;: false,
      &quot;temp_table_type&quot;: 0,
      &quot;policy_ref_info&quot;: null,
      &quot;placement_settings&quot;: null
    }
  ],
  &quot;schema_state&quot;: 0,
  &quot;snapshot_ver&quot;: 0,
  &quot;real_start_ts&quot;: 0,
  &quot;start_ts&quot;: 428310284267159550,
  &quot;dependency_id&quot;: 0,
  &quot;query&quot;: &quot;CREATE TABLE t (id int unsigned NOT NULL PRIMARY KEY, notes varchar(255))&quot;,
  &quot;binlog&quot;: {
    &quot;SchemaVersion&quot;: 0,
    &quot;DBInfo&quot;: null,
    &quot;TableInfo&quot;: null,
    &quot;FinishedTS&quot;: 0
  },
  &quot;version&quot;: 1,
  &quot;reorg_meta&quot;: null,
  &quot;multi_schema_info&quot;: null,
  &quot;priority&quot;: 0
}
</code></pre>
<h3 id="execution-in-the-tidb-ddl-owner"><a class="header" href="#execution-in-the-tidb-ddl-owner">Execution in the TiDB DDL Owner</a></h3>
<p>When the tidb-server starts, it will initialize a <a href="https://github.com/pingcap/tidb/blob/463cc34410d8075f41e5a6151170dbe8a5ae4088/domain/domain.go#L676">domain</a> where it creates a DDL object and calls <a href="https://github.com/pingcap/tidb/blob/7fd60012336c46158df46c30d095a364fcc103f3/ddl/ddl.go#L346">ddl.Start()</a> which starts the limitDDLJobs goroutine and the two DDL workers. It also starts the <a href="https://github.com/pingcap/tidb/blob/d4580596ee4512861924d5028f2753439b860053/owner/manager.go#L187">CampaignOwner</a>/<a href="https://github.com/pingcap/tidb/blob/d4580596ee4512861924d5028f2753439b860053/owner/manager.go#L226">campaignLoop</a> which monitor the owner election and makes sure to elect a new owner when needed.</p>
<p>A ddl worker goes through this workflow in a loop (which may handle one job state per loop, leaving other work to a new loop):</p>
<ol>
<li>Wait for either a signal from local sessions, global changes through PD or a ticker (2 * lease time or max 1 second) and then calls <a href="https://github.com/pingcap/tidb/blob/476027077e43902f69b6d4b4608ebd06fd831d12/ddl/ddl_worker.go#L484">handleDDLJobQueue</a>.</li>
<li>Start a transaction.</li>
<li>Checks if it is the owner (and if not just returns).</li>
<li>Picks the first job from its DDL queue.</li>
<li>Waits for dependent jobs (like reorganizations/backfill needs to wait for its meta-data jobs to be finished first, which it is dependent on).</li>
<li>Waits for the current/old schema version to be globally synchronized, if needed, by waiting until the lease time is passed or all tidb nodes have updated their schema version. </li>
<li>If the job is done (completed or rolled back):
<ol>
<li>Clean up old physical tables or indexes, not part of the new table.</li>
<li>Remove the job from the ddl queue.</li>
<li>Add the job to the DDL History.</li>
<li>Return from handleDDLJobQueue, we are finished!</li>
</ol>
</li>
<li>Otherwise, execute the actual DDL job, <a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/ddl/ddl_worker.go#L709">runDDLJob</a> See more about this below!</li>
<li>Update the DDL Job in the queue, for the next loop/transaction.</li>
<li>Write to the binlog.</li>
</ol>
<p>The execution of the job's DDL changes in <a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/ddl/ddl_worker.go#L709">runDDLJob</a> looks like this:</p>
<pre><code class="language-golang">        // For every type, `schema/table` modification and `job` modification are conducted
        // in the one kv transaction. The `schema/table` modification can be always discarded
        // by kv reset when meets a unhandled error, but the `job` modification can't.
        // So make sure job state and args change is after all other checks or make sure these
        // change has no effect when retrying it.
        switch job.Type {
        case model.ActionCreateSchema:
                ver, err = onCreateSchema(d, t, job)
        case model.ActionModifySchemaCharsetAndCollate:
                ver, err = onModifySchemaCharsetAndCollate(t, job)
        case model.ActionDropSchema:
                ver, err = onDropSchema(d, t, job)
        case model.ActionCreateTable:
                ver, err = onCreateTable(d, t, job)
        case model.ActionCreateView:
                ver, err = onCreateView(d, t, job)
        case model.ActionDropTable, model.ActionDropView, model.ActionDropSequence:
                ver, err = onDropTableOrView(d, t, job)
        case model.ActionDropTablePartition:
                ver, err = w.onDropTablePartition(d, t, job)
        case model.ActionAddColumn:
                ver, err = onAddColumn(d, t, job)
        case model.ActionAddColumns:
                ver, err = onAddColumns(d, t, job)
        case model.ActionDropColumn:
                ver, err = onDropColumn(t, job)
        case model.ActionDropColumns:
                ver, err = onDropColumns(t, job)
        case model.ActionModifyColumn:
                ver, err = w.onModifyColumn(d, t, job)
        case model.ActionSetDefaultValue:
                ver, err = onSetDefaultValue(t, job)
        case model.ActionAddIndex:
                ver, err = w.onCreateIndex(d, t, job, false)
        case model.ActionDropIndex, model.ActionDropPrimaryKey:
                ver, err = onDropIndex(t, job)
        case model.ActionDropIndexes:
                ver, err = onDropIndexes(t, job)
        case model.ActionTruncateTable:
                ver, err = onTruncateTable(d, t, job)
        ...
</code></pre>
<p>Where each operation is handled separately, which is also one of the reasons TiDB has the limitation of only one DDL operation at a time (i.e. not possible to add one column and drop another column in the same DDL statement).</p>
<p>Following the example of <code>CREATE TABLE</code> we see it will be handled by <a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/ddl/table.go#L47">onCreateTable</a>, which after some checks, will create a new Schema version and if table is not yet in <code>StatePublic</code> state, it will create the table in <a href="https://github.com/pingcap/tidb/blob/d53f9f55a0f92589ea18b642b700dbb1b3cfbbfd/meta/meta.go#L358">CreateTableOrView</a> which simply writes the TableInfo as a JSON into the meta database.</p>
<p>Notice that it will take another loop in the handleDDLJobQueue above to finish the DDL Job by updating the Schema version and synchronizing it with other TiDB nodes.</p>
<h3 id="graphs-over-ddl-life-cycle"><a class="header" href="#graphs-over-ddl-life-cycle">Graphs over DDL life cycle</a></h3>
<p>An overview of the DDL execution flow in the TiDB cluster can be seen here:
<img src="understand-tidb/../img/ddl-structure-flow-chart.png" alt="DDL work flow in TiDB Cluster" /></p>
<p>And more specifically for the DDL worker:
<img src="understand-tidb/../img/ddl-owner-detail-flow-chart.png" alt="DDL owner worker detailed flow chart" /></p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2018-10-08-online-DDL.md">Online DDL design doc</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dml"><a class="header" href="#dml">DML</a></h1>
<p>Example:</p>
<pre><code class="language-sql">insert into t values (1, 1);
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dql"><a class="header" href="#dql">DQL</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This chapter describes the execution process of a data query statement in TiDB. Starting from the SQL processing flow, it describes how a SQL statement is sent to TiDB, how TiDB processes it after receiving the SQL statement, and how the execution result is returned.</p>
<h2 id="execution-process"><a class="header" href="#execution-process">Execution Process</a></h2>
<p>Briefly, the execution process of a SQL statement can be divided into three stages:</p>
<ol>
<li>
<p>Protocol Layer</p>
<p>Protocol layer is responsible for parsing the network protocol. Its code locates at <code>server</code> package, mainly consisting of two parts: one for connection establishing and management, every connection corresponds to one session separately; one for handling the packets read from the connection.</p>
</li>
<li>
<p>SQL Layer</p>
<p>SQL layer is the most complex part in TiDB, handling SQL statement parsing and execution. SQL is a complex language, having various data types and operators, numerous syntax combinations. Besides, TiDB uses a distributed storage engine underneath, so it will encounter many problems standalone storage engines won't.</p>
</li>
<li>
<p>KV API Layer</p>
<p>KV API layer routes requests to the right KV server and passes the results back to SQL layer. It should handle the exceptions happened in this stage.</p>
</li>
</ol>
<p>A SQL statement goes through the above three stages sequentially, get parsed and transformed, then handled by SQL layer. In SQL layer, query plans are generated and executed, retrieving data from the underneath storage engine. We'll give a detailed introduction to SQL layer.</p>
<h3 id="protocol-layer-1"><a class="header" href="#protocol-layer-1">Protocol Layer</a></h3>
<h4 id="entry"><a class="header" href="#entry">Entry</a></h4>
<p>The entry of TiDB's SQL layer is in <code>server/conn.go</code>. After a connection is established between the client and TiDB, TiDB spawns a goroutine to listen and poll on the port. In <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L911">clientConn.Run()</a>, a loop keeps reading network packets and calls <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1111">clientConn.dispatch()</a> to handle them:</p>
<pre><code class="language-go">data, err := cc.readPacket()
if err = cc.dispatch(ctx, data)
</code></pre>
<p><code>dispatch</code> handles the raw data array. The first byte of the array represents command type. Among the types, <code>COM_QUERY</code> represents data query statement. You can refer to <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL protocol</a> for more information about the data array. For <code>COM_QUERY</code>, its content is SQL statement. <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1633">clientConn.handleQuery()</a> handles the SQL statement. It calls <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/driver_tidb.go#L217">TiDBContext.ExecuteStmt()</a> in <code>server/driver_tidb.go</code>:</p>
<pre><code class="language-go">func (tc *TiDBContext) ExecuteStmt(ctx context.Context, stmt ast.StmtNode) (ResultSet, error) {
	rs, err := tc.Session.ExecuteStmt(ctx, stmt)
</code></pre>
<p><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/session/session.go#L1620">session.ExecuteStmt()</a> is the entry of the SQL layer kernel and returns the result of the SQL execution.</p>
<h4 id="exit"><a class="header" href="#exit">Exit</a></h4>
<p>After a series of operations described above, the execution results will be returned to the client in <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html">COM_QUERY response</a> format by <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L1943">clientConn.writeResultSet()</a>.</p>
<h3 id="sql-layer-1"><a class="header" href="#sql-layer-1">SQL Layer</a></h3>
<p>In SQL layer, there are multiple concepts and interfaces we need to pay close attention to:</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/session/session.go#L123">Session</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/util/sqlexec/restricted_sql_executor.go#L133">RecordSet</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/planner/core/plan.go#L36">Plan</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/executor.go#L258">Executor</a></li>
</ul>
<h4 id="a-hrefunderstand-tidbsessionhtmlsessiona"><a class="header" href="#a-hrefunderstand-tidbsessionhtmlsessiona"><a href="understand-tidb/session.html">Session</a></a></h4>
<p>The most important function in <code>Session</code> is <code>ExecuteStmt</code>. It wraps calls to other modules. The SQL execution will respect environment variables in <code>Session</code> like <code>AutoCommit</code> and timezone.</p>
<h4 id="a-hrefunderstand-tidbparserhtmlparsera"><a class="header" href="#a-hrefunderstand-tidbparserhtmlparsera"><a href="understand-tidb/parser.html">Parser</a></a></h4>
<p><a href="https://github.com/pingcap/tidb/blob/master/parser/yy_parser.go">Parser</a> consists of <a href="https://github.com/pingcap/tidb/blob/master/parser/lexer.go">Lexer</a> and Yacc. It turns the SQL text to AST:</p>
<pre><code class="language-go">p := parserPool.Get().(*parser.Parser)
defer parserPool.Put(p)
p.SetSQLMode(s.sessionVars.SQLMode)
p.SetParserConfig(s.sessionVars.BuildParserConfig())
tmp, warn, err := p.Parse(sql, charset, collation)
</code></pre>
<p>In the parsing process, lexer first transforms the SQL text to tokens, and then parser accepts the tokens as inputs and generates appropriate AST nodes. For example, statement <code>SELECT * FROM t WHERE c &gt; 1;</code> matches <a href="https://github.com/pingcap/tidb/blob/45457ea8810ca7b835da4ba7f55d0eee02043ac5/parser/parser.y#L3936">SelectStmt rule</a> finally turns to the structure below:</p>
<pre><code class="language-go">type SelectStmt struct {
	dmlNode
	// SelectStmtOpts wraps around select hints and switches.
	*SelectStmtOpts
	// Distinct represents whether the select has distinct option.
	Distinct bool
	// From is the from clause of the query.
	From *TableRefsClause
	// Where is the where clause in select statement.
	Where ExprNode
	// Fields is the select expression list.
	Fields *FieldList
	// GroupBy is the group by expression list.
	GroupBy *GroupByClause
	// Having is the having condition.
	Having *HavingClause
	// WindowSpecs is the window specification list.
	WindowSpecs []WindowSpec
	// OrderBy is the ordering expression list.
	OrderBy *OrderByClause
	// Limit is the limit clause.
	Limit *Limit
	// LockInfo is the lock type
	LockInfo *SelectLockInfo
	// TableHints represents the table level Optimizer Hint for join type
	TableHints []*TableOptimizerHint
	// IsInBraces indicates whether it's a stmt in brace.
	IsInBraces bool
	// WithBeforeBraces indicates whether stmt's with clause is before the brace.
	// It's used to distinguish (with xxx select xxx) and with xxx (select xxx)
	WithBeforeBraces bool
	// QueryBlockOffset indicates the order of this SelectStmt if counted from left to right in the sql text.
	QueryBlockOffset int
	// SelectIntoOpt is the select-into option.
	SelectIntoOpt *SelectIntoOption
	// AfterSetOperator indicates the SelectStmt after which type of set operator
	AfterSetOperator *SetOprType
	// Kind refer to three kind of statement: SelectStmt, TableStmt and ValuesStmt
	Kind SelectStmtKind
	// Lists is filled only when Kind == SelectStmtKindValues
	Lists []*RowExpr
	With  *WithClause
}
</code></pre>
<p><code>From t</code> is parsed to <code>From</code> field. <code>WHERE c &gt; 1</code> is parsed to <code>Where</code> field. <code>*</code> is parsed to <code>Fields</code> field. Most data structures in <code>ast</code> package implement <code>ast.Node</code> interface. This interface has a <code>Accept</code> method, implementing the classic visitor pattern, used by following procedures to traverse the tree.</p>
<h4 id="compile"><a class="header" href="#compile">Compile</a></h4>
<p>After the AST is generated, it's going to be validated, transformed and optimized in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/compiler.go#L50">Compiler.Compile()</a>:</p>
<pre><code class="language-go">compiler := executor.Compiler{Ctx: s}
stmt, err := compiler.Compile(ctx, stmtNode)
</code></pre>
<p>There are three steps:</p>
<ol>
<li><code>plan.Preprocess</code>: do validations and name binding.</li>
<li><code>plan.Optimize</code>: make and optimize query plans, this is the core part.</li>
<li>construct <code>executor.ExecStmt</code> structure: <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/adapter.go#L186">ExecStmt</a> holds the query plans. It's the foundation for following execution.</li>
</ol>
<h4 id="a-hrefunderstand-tidbexecutionhtmlexecutora"><a class="header" href="#a-hrefunderstand-tidbexecutionhtmlexecutora"><a href="understand-tidb/execution.html">Executor</a></a></h4>
<p>While constructing the executor in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/executor/adapter.go#L764">ExecStmt.buildExecutor()</a>, query plans are turned to executor. Then the execution engine could perform the query plans via the executor. The generated executor is encapsulated in a <code>recordSet</code> structure:</p>
<pre><code class="language-go">return &amp;recordSet{
	executor:   e,
	stmt:       a,
	txnStartTS: txnStartTS,
}
</code></pre>
<p>This structure implements <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/util/sqlexec/restricted_sql_executor.go#L133">ast.RecordSet</a> interface. It abstracts the query results and has the following methods:</p>
<pre><code class="language-go">type RecordSet interface {
	// Fields gets result fields.
	Fields() []*ast.ResultField
	// Next reads records into chunk.
	Next(ctx context.Context, req *chunk.Chunk) error
	// NewChunk create a chunk.
	NewChunk() *chunk.Chunk
	// Close closes the underlying iterator, call Next after Close will
	// restart the iteration.
	Close() error
}
</code></pre>
<p>The functionality of each method is described in the comments. In short, <code>Fields()</code> retrieves the type of each column. <code>Next()</code> returns a batch of the result. <code>Close()</code> closes the result set.</p>
<p>TiDB's execution engine executes in Volcano model. All the executors constitute an executor tree. Every upper layer gathers results from the lower layer by calling its <code>Next()</code> method. Assuming we have a SQL statement <code>SELECT c1 FROM t WHERE c2 &gt; 1;</code> and the query plan is full table scanning plus filtering, the executor tree is like:</p>
<p><img src="understand-tidb/../img/dql-volcano.png" alt="" /></p>
<p>From the above picture, we can see the data flow between executors. The starting point of a SQL statement execution, also the first <code>Next()</code> call is in <a href="https://github.com/pingcap/tidb/blob/05d2210647d6a1503a8d772477e43b14a024f609/server/conn.go#L2016">the function returning data back to the client</a>:</p>
<pre><code class="language-go">err := rs.Next(ctx, req)
</code></pre>
<p><code>rs</code> is a <code>RecordSet</code> instance. Keep calling its <code>Next</code> method to get more results to return to the client.</p>
<h2 id="overall-diagram"><a class="header" href="#overall-diagram">Overall Diagram</a></h2>
<p>The above SQL query statement execution process can in general be described as the following picture:</p>
<p><img src="understand-tidb/../img/dql-frame-diagram.png" alt="" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>Parser is responsible for interpreting a SQL string into an abstract syntax tree (AST), which is more structural and easier to process. AST can be used for preprocessing, syntactic analysis, and so on.</p>
<p>The code lives in the <a href="https://github.com/pingcap/tidb/tree/master/parser">pingcap/tidb repo, parser directory</a>.</p>
<h2 id="understand-parser"><a class="header" href="#understand-parser">Understand Parser</a></h2>
<p>Parser is generated by a parser generator named <a href="https://github.com/cznic/parser">yacc</a>. It takes the grammar file <code>parser.y</code> as the input and outputs the source code file <code>parser.go</code>, which is the real parser imported by TiDB. Thus, the core file is <code>parser.y</code> because when the SQL syntax changes, most of the changes take place in <code>parser.y</code>.</p>
<p>In case you are unfamiliar with yacc, some concepts are listed here:</p>
<ul>
<li><strong>Terminal Symbol</strong> is also known as &quot;token&quot;. When a SQL string reaches parser, the first step is to tokenize them into an array of tokens. For example, <code>&quot;SELECT * FROM t&quot;</code> is tokenized to <code>[selectKeyword, '*', fromKeyword, identifier(t)]</code> by <a href="https://github.com/pingcap/tidb/blob/4b110036e1a7d7c3584113512a544c8350459157/parser/lexer.go#L169">lexer.Lex()</a>.</li>
<li><strong>Non-terminal Symbol</strong> is a syntactic variable, which can represent a group of terminal/non-terminal symbols.</li>
<li><strong>Grammar Rule</strong> specifies which symbols can replace which other non-terminal symbol.</li>
<li><strong>Semantic Action</strong> defines how an AST node is constructed.</li>
</ul>
<p>An example of a grammar rule is as follows:</p>
<pre><code>AlterDatabaseStmt:
	&quot;ALTER&quot; DatabaseSym DBName DatabaseOptionList
	{
		$$ = &amp;ast.AlterDatabaseStmt{
			Name:                 $3,
			AlterDefaultDatabase: false,
			Options:              $4.([]*ast.DatabaseOption),
		}
	}
</code></pre>
<ul>
<li><code>AlterDatabaseStmt</code> is a non-terminal symbol because there is no such token.</li>
<li><code>&quot;ALTER&quot;</code> is a terminal symbol.</li>
<li><code>DatabaseSym</code>, <code>DBName</code> and <code>DatabaseOptionList</code> are non-terminal symbols that are defined in other grammar rules.</li>
<li>The pseudo-code in brackets is the semantic action. It means an AST node <code>ast.AlterDatabaseStmt</code> will be constructed when the rule is reduced by the parser. Note that a dollar character <code>$</code> followed by a number represents the binding Golang value previously (in other rules), where the number is the index of symbol in rule (1-based). <code>$$</code> represents current binding value. After goyacc substitution, this code snippet will be valid Golang code.</li>
</ul>
<p>Getting back to <code>parser.y</code>, the structure of this file is divided into three parts:</p>
<ol>
<li><code>%union</code> enumerates all the Golang types that can be passed around grammar rules.</li>
<li><code>%token</code> or <code>%type</code> declares the terminal or non-terminal symbols that will be used in grammar rules.</li>
<li>Grammar rules define the syntax of SQL and related semantic actions.</li>
</ol>
<p>Except for <code>parser.y</code>, other sub-package/files should be easy to understand, feel free to explore them by yourself:</p>
<table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody>
<tr><td>ast</td><td>The AST definition used by TiDB.</td></tr>
<tr><td>auth</td><td>Authentication-related functions.</td></tr>
<tr><td>charset</td><td>Currently supported charsets and encodings.</td></tr>
<tr><td>format</td><td>The Formatters for yacc file and the functions for restoring AST to SQL.</td></tr>
<tr><td>goyacc</td><td>The generator for parser.go.</td></tr>
<tr><td>model</td><td>Basic structures in TiDB like TableInfo, ColumnInfo...</td></tr>
<tr><td>mysql</td><td>MySQL constants, errors, privileges, types, and others.</td></tr>
<tr><td>opcode</td><td>Operator code like &lt;, &gt;, +, =...</td></tr>
<tr><td>terror</td><td>The errors used by TiDB.</td></tr>
<tr><td>test_driver</td><td>A parser driver only for unit tests.</td></tr>
<tr><td>tidb</td><td>TiDB related features' keywords.</td></tr>
<tr><td>types</td><td>The field types and evaluation types that used in TiDB.</td></tr>
</tbody></table>
<h2 id="develop-and-build"><a class="header" href="#develop-and-build">Develop and Build</a></h2>
<p>To get started with the parser development, please also take a look at <a href="https://github.com/pingcap/tidb/blob/master/parser/docs/quickstart.md">quickstart.md</a>. It shows the basic usage of the parser and it explains some concepts like parser_driver.</p>
<p>Run <code>make parser</code> in the project root directory to generate a new <code>parser.go</code>. If you want to try your new parser patches on TiDB, follow <a href="https://github.com/pingcap/tidb/blob/master/parser/docs/update-parser-for-tidb.md">this procedure</a> to have TiDB use your copy of the parser. This allows you to make changes to both the parser and TiDB and test them together.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ol>
<li>How to debug the parsing procedure?</li>
</ol>
<p>Put the test file in the <code>parser</code> package. Set <a href="https://github.com/pingcap/tidb/blob/4b110036e1a7d7c3584113512a544c8350459157/parser/goyacc/main.go#L525"><code>yyDebug</code></a> level to <code>4</code>(or any integers &gt;= 4) before calling <code>Parse()</code>. The parser will try to show state information in each step.</p>
<ol start="2">
<li>How to resolve shift-reduce or reduce-reduce conflicts?</li>
</ol>
<p>Shift means &quot;move the next token in&quot; to match the current rule. Reduce means &quot;replace current tokens/symbols to a non-terminal symbol&quot;. Shift-reduce conflicts occur when the parser cannot decide the next step is to shift or to reduce.</p>
<p>When yacc reports such conflicts, it also keeps the file <code>y.output</code>. You can search &quot;conflict on&quot; in the file to locate which rule conflicts with other rules. Then you can try to annotate the <code>%precedence</code> to tokens, rewrite the grammar rule, or ask for help on GitHub.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="planner"><a class="header" href="#planner">Planner</a></h1>
<p>The <code>planner</code> package contains most of the codes related to SQL optimization. The input of the planner is an AST of the query returned from the parser, and the output of the planner is a plan tree that would be used for further execution.</p>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<table><thead><tr><th align="left">Package</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/cascades">tidb/planner/cascades</a></td><td align="left">The next generation Cascades model planner, which is under development and disabled by default</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/core">tidb/planner/core</a></td><td align="left">The core logic of the currently used System R model planner. The Cascades model planner also calls utility functions in this package</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/implementation">tidb/planner/implementation</a></td><td align="left">Physical implementations for the operators in Cascades planner</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/memo">tidb/planner/memo</a></td><td align="left">Intermediate results for the searching procedure of Cascades planner</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/property">tidb/planner/property</a></td><td align="left">Properties about the output of operators, including schema, stats, order property, partition property, etc</td></tr>
<tr><td align="left"><a href="https://github.com/pingcap/tidb/tree/master/planner/util">tidb/planner/util</a></td><td align="left">Common utility functions / structures shared by the two planners</td></tr>
</tbody></table>
<p>We can see that, TiDB has two planners, one is of System R model, which is defaultly used, and the other is of Cascades model, which is still under development. The unified entry function of planner module is <code>Optimize()</code>, before diving into either of the two planners, it would firstly check if there is any intervention for the planner from the &quot;SQL Plan Management&quot; module, if yes, the AST of the query would be modified before going through the optimization procedures. &quot;SQL Plan Management&quot; module is beyond the scope of this article, and it would be introduced in the <a href="understand-tidb/sql-plan-management.html">SQL Plan Management</a> section.</p>
<p>This article would only focus on introducing the System R planner, i.e, the <code>core</code> package, readers who are interested in the Cascacdes planner can refer to this <a href="https://github.com/pingcap/tidb/tree/master/docs/design/2018-08-29-new-planner.md">design</a> doc.</p>
<h2 id="optimization-procedures"><a class="header" href="#optimization-procedures">Optimization Procedures</a></h2>
<p>Ignore the trivial steps, the query optimization procedures can be briefly divided into 4 phases:</p>
<ol>
<li>build an initial logical plan</li>
<li>logically optimize the initial logical plan</li>
<li>physically optimize the logical plan</li>
<li>tidy up the physical plan</li>
</ol>
<h3 id="plan-building"><a class="header" href="#plan-building">Plan Building</a></h3>
<p>The entry function of this phase is <code>PlanBuilder.Build()</code>, it would translate the input AST to a logical plan tree from bottom up according to the predefined rules / orders. Specifically, it would check each sub-clause of the query, and build a corresponding operator for the clause. The operators are connected as a DAG, which is known as a logical plan tree.</p>
<p>A key step in this phase is translating the expressions for each clause, e.g, <code>where a = 1</code> would have a <code>Selection</code> operator built correspondingly, and an expression <code>eq(a, 1)</code> would be translated and saved in the <code>Selection operator</code>. The expression translation logics are encapsulated in a structure <code>expressionRewriter</code> and its methods. The <code>expressionRewriter</code> would traverse and transalte the AST expressions recursively, and utilize a result stack for intermediate results.</p>
<p><code>expressionRewriter</code> would not only do the simple expression transaltions, but would optimize subqueries in the expressions. The details of subquery optimization would not be explained here, because they are pretty complicated. Briefly speaking, for most of the uncorrelated subqueries, <code>expressionRewriter</code> would directly execute them and substitute them with the result constants. For correlated subqueries, or some of the uncorrelated subqueries, <code>expressionRewriter</code> would build a subtree from them and connect it with the main plan tree using a <code>LogicalJoin</code> or <code>LogicalApply</code> operator. Note that, <code>LogicalApply</code> is a special kind of join operator which can only be executed in a nested-loop approach. <code>LogicalApply</code> operator in some plan trees can be converted to a regular <code>LogicalJoin</code>, which can be executed in other more efficient join algorithms, and planner would do this conversion in the subsequent logical optimization phase if possible.</p>
<p>During the plan building process, optimization flags would be collected for each operator built. For example, if a <code>Selection</code> operator is built, then an optimization flag like <code>flagPredicatePushDown</code> would be set in the plan builder. These saved flags would be used later in the logical optimization phase.</p>
<h3 id="logical-optimization"><a class="header" href="#logical-optimization">Logical Optimization</a></h3>
<p>The entry function of this phase (also known as rule-based optimization) is <code>logicalOptimize()</code>. This function would do logically equivalent transformations for the initial plan tree according to relational algebra, and the result plan tree should be better than the initial one from the execution efficiency perspective in principle. Specifically, <code>logicalOptimize()</code> would traverse all the logical optimization rules predefined as <code>optRuleList</code> in order, and check if a rule is applicable by referring to the optimization flags saved during the plan building phase. If the flag is set for a rule, planner would traverse the plan tree from top down, and apply the transformations implied by the rule to the subtree satisfying the rule prerequisites.</p>
<p>An example logical optimization rule is &quot;column pruning&quot;, for each operator in the plan tree, it would collect the columns needed by the upper operators, and prune the unneeded columns from the output. Another example rule is &quot;decorrelation&quot;, it would try to pull up operators referring correlated columns, and resolve the column dependency, hence convert the <code>LogicalApply</code> operator to a regular <code>LogicalJoin</code>.</p>
<h3 id="physical-optimization"><a class="header" href="#physical-optimization">Physical Optimization</a></h3>
<p>The entry function of this phase (also known as cost-based optimization) is <code>physicalOptimize()</code>, it would do cost based enumeration for the implementations of each logical operator, and find a combination of all operators with the lowest cost as the final physical plan. Specifically, each logical operator would implement an interface function <code>exhaustPhysicalPlans()</code> to list all the possible physical algorithms, e.g, <code>LogicalAggregation</code> would have two possible implementations including <code>PhysicalStreamAggregation</code> and <code>PhysicalHashAggregation</code>. Each implementation may require specific properties for its child's output, e.g, <code>PhysicalStreamAggregation</code> would require that the child's output rows should be in order of the <code>GROUP BY</code> columns. These properties are recorded in <code>PhysicalProperty</code> structure, and passed down to the enumeration procedure of the child operators.</p>
<p>Once the planner knows the specific implementation of the plan tree, or of a subtree, it can compute a cost for this implementation. The cost of one implementation is calculated as a sum of its resource consumptions including CPU, Memory, Network, IO, etc. For each kind of resource specifically, the consumption is measured based on a unit factor (e.g, scanFactor is the unit factor for IO consumption, which means the cost of scanning 1 byte data on TiKV or TiFlash), and the estimated number of rows / bytes to be processed by this operator. Note that, these unit factors can be customized by setting system variables like <code>tidb_opt_xxx_factor</code> to fit clusters of different hardware configurations. Each implementation of the whole logical plan tree would have a cost then, planner would choose the one with the lowest cost for execution.</p>
<p>One thing worth mention is that, TiDB supports pushing some operators down to storage engine to speed up the query execution, e.g, we can push <code>Selection</code> operator down to the coprocessor of TiKV, and reduce the rows returned from TiKV to TiDB through the network. The logic about deciding whether to push operators down to storage engine or not is piggybacked on the search framework of the physical optimization. Specifically, it is achieved by introducing <code>TaskType</code> field into <code>PhysicalProperty</code>, for example, once the planner wants to push down a <code>Limit</code> operator to TiKV, it would enumerate an implementation <code>PhysicalLimit</code> which has <code>CopXXXTaskType</code> as the <code>TaskType</code> of the required <code>PhysicalProperty</code> for its child. Once the child of <code>PhysicalLimit</code> has generated a TiKV implementation, these two plan snippets would be concatenated in <code>attach2Task()</code> interface, hence achieving the operator pushdown for storage engine.</p>
<h3 id="post-optimization"><a class="header" href="#post-optimization">Post Optimization</a></h3>
<p>The entry function of this phase is <code>postOptimize()</code>. The query optimization has almost finished when coming here, this phase would not apply big changes to the plan, it would only do some clean and tidy up works. The jobs in this phase include a new round of projection elimination(the first round is applied in logical optimization), and projection injection to simplify the code implementations of executor package, and so on.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This section talks about the brief steps of query optimization, and the corresponding entry functions for each step.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="table-statistics"><a class="header" href="#table-statistics">Table Statistics</a></h1>
<p>Like most commercial databases, TiDB query optimization incorporates a cost-based optimizer that relies on the statistics of the database data to make an optimal query plan. Therefore, the statistics play a key role in TiDB for the optimizer to choose, e.g., the right index for table access or the right join method between the index nested loop join and hash join, and many more scenarios for an optimal query execution plan.</p>
<p>In this chapter, we will introduce different types of statistics being used in TiDB, the corresponding data structure, how TiDB collects and maintains them, as well as how the TiDB optimizer uses these statistics in the optimization process. Given the space limit, we will not cover all the implementation details. However, the corresponding code modules will be pointed out as much as possible. Please also note that as TiDB and its optimizer evolve over time, some of these statistics and their application may also have evolved or been modified.</p>
<h2 id="types-of-tidb-statistics"><a class="header" href="#types-of-tidb-statistics">Types of TiDB statistics</a></h2>
<p>Among many types of statistics commonly used by databases, TiDB mainly uses three types of them: histogram, top-n values (a.k.a, MFV or most frequent values), and count-min sketch (CM sketch). We will briefly introduce each of these statistics first.</p>
<h3 id="histogram"><a class="header" href="#histogram">Histogram</a></h3>
<p>Histogram splits the data into a number of buckets and maintains some information to describe a bucket, such as the number of records in the bucket. It is widely used in many RDBMS to estimate a range.</p>
<p>Among two commonly used histogram strategies, equal-depth and equal-width, we choose the equal-depth histogram for it has a better guarantee of worst case error rate compared to that of the equal-width histogram. You can refer to the paper <a href="https://dl.acm.org/citation.cfm?id=602294">Accurate estimation of the number of tuples satisfying a condition</a> for more information. With the equal-depth histogram, the number of values in each bucket is to be as equal as possible. For example, to split the given record set of <code>1.6, 1.9, 1.9, 2.0, 2.4, 2.6, 2.7, 2.7, 2.8, 2.9, 3.4, 3.5</code> into 4 buckets, the final buckets would look like <code>[1.6, 1.9], [2.0, 2.6], [2.7, 2.8], [2.9, 3.5]</code>.	Thus the depth, (a.k.a. the number of records) of each bucket is 3, as shown in the following graph.</p>
<p><img src="understand-tidb/../img/stats-histogram.png" alt="equal-depth histogram" /></p>
<h3 id="count-min-sketch"><a class="header" href="#count-min-sketch">Count-Min Sketch</a></h3>
<p>The Count-Min Sketch (CM sketch) is a data structure used for query cardinality estimation for the equal predicate, or join, etc., and provides strong accuracy guarantees. Since its introduction in 2003 in the paper <a href="http://dimacs.rutgers.edu/%7Egraham/pubs/papers/cm-full.pdf">An improved data stream summary: The count-min sketch and its applications</a>, it has gained widespread use given its simplicity of construction and use.</p>
<p>CM sketch maintains an array of <code>d*w</code> counts, and for each value, maps it to a column in each row using <code>d</code> separate hash functions and modifies the count value at those <code>d</code> positions. This is shown in the following figure.</p>
<p><img src="understand-tidb/../img/stats-cmsketch.png" alt="count-min sketch" /></p>
<p>This way, when querying how many times a value appears, the d hash functions are still used to find the position mapped to in each row, and the minimum of these d values is used as the estimate. </p>
<p><strong>Please note that CM sketch is not used as default statistics since version 5.1 given the increasing concerns on estimation bias under the scenarios with large distinct values of a column.</strong></p>
<h3 id="top-n-value-most-frequent-value"><a class="header" href="#top-n-value-most-frequent-value">Top-N Value (Most Frequent Value)</a></h3>
<p>The CM sketch would encounter severe hash collisions when the dataset grows while the histogram has its limit to estimate the selectivity of equal predicates. Thus we extract the Top-N value (a.k.a., the most frequent value) of the dataset out of the histogram to improve the accuracy of the estimation of an equal predicate. Here, the top-n statistics are stored as a pair of <code>(value, cnt)</code>. For example, for a dataset <code>1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5, 6, 7</code>. if n of top-n is 1, the top-n value pair will be <code>[(1, 7)]</code>, and the rest of the histogram is constructed using the remaining data <code>2, 2, 3, 4, 4, 5, 6, 7</code>. You may refer to the paper <a href="https://dl.acm.org/doi/10.1561/1900000004">Synopses for Massive Data: Samples, Histograms, Wavelets, Sketches</a> for additional information.</p>
<h2 id="statistics-construction"><a class="header" href="#statistics-construction">Statistics Construction</a></h2>
<p>When the <code>analyze</code> command is executed, TiDB will collect the histogram, CM sketch, and top-n values statistics. During the execution of <code>analyze</code> command, the columns and indexes that need to be analyzed are divided into different tasks in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/executor/builder.go#L2459">builder.go</a>, and then the tasks are pushed down to TiKV for execution in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/executor/analyze.go">analyze.go</a>. Here we will focus on the construction of histograms as an example.</p>
<h3 id="construction-of-column-histogram"><a class="header" href="#construction-of-column-histogram">Construction of column histogram</a></h3>
<p>When constructing a column histogram, sampling will be performed first, and then the histogram will be constructed. The detailed steps are shown as follows.</p>
<p>In the <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/sample.go#L228">collect</a> function, we implemented the reservoir sampling algorithm to generate a uniform sampling set. Since its principle and code are relatively simple, it will not be introduced here.</p>
<p>After sampling, in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/builder.go#L210">BuildColumn</a>, we implement the construction of column histogram. The samples are sorted first, then the height of each bucket is determined, and followed by traversing each value <code>v</code> sequentially:</p>
<ul>
<li>If <code>v</code> is equal to the previous value, then put <code>v</code> in the same bucket as the previous value, regardless of whether the bucket is full or not so that each value can only exist in one bucket.</li>
<li>If it is not equal to the previous value, then check whether the current bucket is full. If bucket still has room to store a new item, put <code>v</code> directly into the current bucket, and use <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L225">updateLastBucket</a> to change the upper bound and depth of the bucket.</li>
</ul>
<ul>
<li>Otherwise, use <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L214">AppendBucket</a> to put in a new bucket.</li>
</ul>
<blockquote>
<p>You can find how we extract the top-n values then build the histogram in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/builder.go#L215">BuildHistAndTopN</a>.</p>
</blockquote>
<h3 id="construction-of-the-indexed-histogram"><a class="header" href="#construction-of-the-indexed-histogram">Construction of the indexed histogram</a></h3>
<p>When constructing the index column histogram, we use <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/builder.go#L28">SortedBuilder</a> to maintain the intermediate state of the building process. Since the number of rows of data cannot be known in advance, the depth of each bucket cannot be determined. However, since the data in the index column is already ordered, we set the initial depth of each bucket to 1 in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/builder.go#L44">NewSortedBuilder</a>. For each piece of data, <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/builder.go#L56">Iterate</a> will insert the data in a similar way when constructing a column histogram. If at a certain point, the number of required buckets exceeds the current bucket number, then use <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L532">mergeBucket</a> to merge every two previous buckets into one, double the bucket depth, and then continue to insert.</p>
<p>After collecting the histograms separately established on each Region, we also need to merge the histograms on each Region with <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L761">MergeHistogram</a>. In this function:</p>
<ul>
<li>In order to ensure that each value only appears in one bucket, we deal with the problem of the buckets at the junction, that is, if the upper and lower bounds of the two buckets at the junction are <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L775">equal</a>, then the two buckets need to be merged first;</li>
<li>Before actual merging, we <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L795-L806">adjust</a> the average bucket depth of the two histograms to be approximately equal;</li>
<li>If the number of buckets exceeds the limit after the histogram is merged, then the two adjacent buckets are <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L814">merged</a> into one.</li>
</ul>
<h2 id="statistics-maintenance"><a class="header" href="#statistics-maintenance">Statistics maintenance</a></h2>
<p>From version 2.0, TiDB has introduced a dynamic update mechanism, which can dynamically adjust statistics based on the results of the query. In addition, from version 4.0, we have introduced the <code>auto analyze</code> function, which can automatically trigger the collection of (incremental) statistics based on the percentage of table data change. </p>
<p>As data changes significantly, the settings of statistics collection may need to be modified accordingly, too. For example, the histogram needs to adjust the bucket height and the boundaries of the bucket; and the CM Sketch needs to adjust the count array so that the estimated value is equal to the result of the query.</p>
<p>What needs to be pointed out here is that dynamically adjusting statistics based on query results is turned off by default in version 4.0, and will be revisited for a possible redesign in future versions.</p>
<h2 id="the-application-of-the-statistics"><a class="header" href="#the-application-of-the-statistics">The application of the statistics</a></h2>
<h3 id="estimation"><a class="header" href="#estimation">Estimation</a></h3>
<p>Query filtering conditions are often used in query statements to filter out certain data. Thus the main function to exploit statistics is to estimate the number of data after applying these filter conditions so that the optimizer may choose the optimal execution plan based on those estimates. We will introduce two main types of estimation for range and point filtering.</p>
<h4 id="range-estimation"><a class="header" href="#range-estimation">Range estimation</a></h4>
<p>For a query that results in a range of data sets on a particular column, we choose the histogram for estimation.</p>
<p>In the previous introduction of the equal-depth histogram, an example of a histogram is given containing four buckets <code>[1.6, 1.9], [2.0, 2.6], [2.7, 2.8], [2.9, 3.5]</code>, all of which have a bucket depth of 3. Suppose we have such a histogram, and we want to know how many values fall in the interval <code>[1.7, 2.8]</code>. If we put this interval on the histogram, we can see that two buckets are completely covered, namely bucket <code>[2.0, 2.6]</code> and bucket <code>[2.7, 2.8]</code>, so there are 6 values in the interval <code>[2.0, 2.8]</code>. However, the first bucket is only partially covered, so the problem becomes how to estimate the number of values in the interval <code>[1.7, 1.9]</code>. When we already know that there are 3 values in the interval <code>[1.6, 1.9]</code>, how can we estimate how many values are in <code>[1.7, 1.9]</code>? A common approach is to assume that the range is continuous and uniform, so we can estimate the range as a proportion of the bucket, i.e. <code>(1.9 - 1.7) / (1.9 - 1.6) * 3 = 2</code>.</p>
<p>Another question to ask here when applying the interpolation ratio to estimate is what about other data types, say string types, as the previous example uses numerical type which is easy? One way is to map strings to numbers and then calculate the ratio, see <a href="https://github.com/pingcap/tidb/blob/master/statistics/scalar.go">statistics/scalar.go</a> for details. We can see that this mapping is not suitable for multi-column cases.</p>
<h4 id="point-estimation"><a class="header" href="#point-estimation">Point estimation</a></h4>
<p>For a query with equal predicate on a column, the histogram may not work well to estimate the cardinality on a certain value. The common way to estimate is to assume uniform distribution of all values that each value appears an equal number of times, so that <code>(total number of rows/number of distinct values)</code> can be used to estimate. If it exists, CM sketch is used for the estimation of equal-value queries.</p>
<p>Since the result of Count-Min Sketch estimation is not always smaller than the actual value, we choose the Count-Mean-Min Sketch proposed in the paper <a href="http://webdocs.cs.ualberta.ca/%7Edrafiei/papers/cmm.pdf">New estimation algorithms for streaming data: Count-min can do more</a>, which is the same as Count-Min Sketch in the update time, but the difference is with the query time: for each row <code>i</code>, if the hash function maps to value <code>j</code>, then <code>(N - CM[i, j]) / (w-1) (N is the total number of inserted values)</code> is used as the noise generated by other values, so <code>CM[i,j] - (N - CM[i, j]) / (w-1)</code> is used as the estimation value for this row. And then, the median of the estimated values for all rows is used as the final estimate.</p>
<p>After the CM sketch is stopped to use from version 5.1, we extract the top-n values out of the histogram. So we <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L1105">first</a> check whether the value is in the top-n for the point estimation and return the accurate estimate if it's in the top-n. Otherwise, we use <code>the number of rows in the histogram / the NDV in the histogram</code> as the estimation result. Since the top-n values are extracted and applied, the accuracy of this case is improved.</p>
<p>It is relatively simple to estimate cardinality on a single column of a query, so we will not go into details here. The code is basically implemented according to the principle of statistics as introduced above. Please refer to <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/histogram.go#L488">histogram.go/lessRowCount</a> and <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/cmsketch.go#L256">cmsketch.go/queryValue</a> for more information.</p>
<h4 id="multi-column-estimation"><a class="header" href="#multi-column-estimation">Multi-column estimation</a></h4>
<p>The above two subsections describe how we estimate query conditions on a single column, but actual query statements often contain multiple query conditions on multiple columns, so we need to consider how to handle the multi-column case. In TiDB, the <code>Selectivity</code> function in <a href="https://github.com/pingcap/tidb/blob/master/statistics/selectivity.go">selectivity.go</a> implements this functionality, and it is the most important interface to the optimizer provided by the statistics module.</p>
<p>When dealing with query conditions on multiple columns, a common practice is to assume that the different columns are independent of each other, so we just multiply the selectivity among the different columns. However, for filter conditions on an index that can be used to construct a range of index scans, i.e., for an index like <code>(a, b, c)</code> and the conditions like <code>(a = 1 and b = 1 and c &lt; 5) or (a = 1 and b = 1)</code>, the selectivity is estimated by the index's statistics using the method mentioned earlier so that there is no need to assume that the columns are independent of each other.</p>
<p>Therefore, one of the most important tasks of <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/selectivity.go#L176"><code>Selectivity</code></a> is to divide all the query conditions into as few groups as possible so that the conditions in each group can be estimated using the statistics on a column or index. Thus we can make as few assumptions of independence as possible.</p>
<p>We use a simple greedy algorithm to group conditions. We always choose the index or column which covers the most remaining filters and remove these filters from the list. Then go into the next round until all filters are covered. The last step is to do the estimation using the statistics on each column and each index as mentioned before and combine them with the independence assumption as the final result.</p>
<p>It should be noted that we divide the statistics of a single column into <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/selectivity.go#L53">three categories</a>: <code>indexType</code> is the index column, <code>pkType</code> is the primary key of the Int type, and <code>colType</code> is the ordinary column type. If a condition can be covered by multiple types of statistics at the same time, then We will choose pkType or indexType first. This is because we build the histogram of the index use full data and build the histogram of the column just using the sampling data in the version before 5.1.</p>
<p>The above two subsections describe how we estimate query conditions on a single column, but actual query statements often contain multiple query conditions on multiple columns, so we need to consider how to handle the multi-column case. In TiDB, the Selectivity function implements this functionality, and it is the most important interface to the optimizer provided by the statistics information module.</p>
<p>In Selectivity, there are the following steps:</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/selectivity.go#L363">getMaskAndRange</a> calculates the filter conditions that can be covered for each column and each index, uses an int64 as a bitset, and sets the bit position of the filter conditions that can be covered by the column to 1.</li>
<li>Next, in <a href="https://github.com/pingcap/tidb/blob/466f6e77b6b01f09443043f75156de4ca2892141/statistics/selectivity.go#L404">getUsableSetsByGreedy</a>, select as few bitsets as possible to cover as many filter conditions as possible. Every time in the unused bitset, select a filter condition that can cover up to the uncovered. And if the same number of filter conditions can be covered, we will give preference to <code>pkType</code> or <code>indexType</code>.</li>
<li>Use the method mentioned above to estimate the selectivity on each column and each index, and use the independence assumption to combine them as the final result.</li>
</ul>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>The collection and maintenance of statistics are one of the core functions of the database. And for the cost-based query optimizer, the accuracy of statistics directly affects the optimizer's decision and, therefore, the query performance. In distributed databases, collecting statistics is not much different from a single node database. However, it is more challenging to maintain the statistics, e.g., how to maintain accurate and up-to-date statistics in the case of multi-node updates.</p>
<p>For dynamic updating of histograms, the industry generally has two approaches.</p>
<ul>
<li>For each addition or deletion, update the corresponding bucket depth. When its depth is too high, a bucket is split into two equal width buckets, although it is hard to determine the splitting point accurately and may cause estimation error.</li>
<li>Using the actual number obtained from the executed query to adjust the histogram with feedback, assuming that the error contributed by all buckets is uniform, and uses the continuous value assumption to adjust all the buckets involved. However, the assumption of uniformity of errors may not hold and cause problems. For example, when a newly inserted value is larger than the maximum value of the histogram, it will spread the error caused by the newly inserted value to the whole histogram, which causes estimation errors.</li>
</ul>
<p>Currently, TiDB's statistics are still dominated by single-column statistics. To reduce the use of independence assumptions, TiDB will further explore the collection and maintenance of multi-column statistics, as well as other synopses to provide more accurate statistics for the optimizer.</p>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<p>Below is the related code structure from the TiDB repository.</p>
<pre><code>tidb
.
│
...
├── executor
│   │
│   ...
│   ├── analyze.go
│   │
│   ...
...
├── statistics
│   ├── analyze.go
│   ├── analyze_jobs.go
│   ├── analyze_jobs_serial_test.go
│   ├── builder.go
│   ├── cmsketch.go
│   ├── cmsketch_test.go
│   ├── estimate.go
│   ├── feedback.go
│   ├── feedback_test.go
│   ├── fmsketch.go
│   ├── fmsketch_test.go
│   ├── handle
│   │   ├── bootstrap.go
│   │   ├── ddl.go
│   │   ├── ddl_test.go
│   │   ├── dump.go
│   │   ├── dump_test.go
│   │   ├── gc.go
│   │   ├── gc_test.go
│   │   ├── handle.go
│   │   ├── handle_test.go
│   │   ├── main_test.go
│   │   ├── update.go
│   │   ├── update_list_test.go
│   │   └── update_test.go
│   ├── histogram.go
│   ├── histogram_test.go
│   ├── integration_test.go
│   ├── main_test.go
│   ├── row_sampler.go
│   ├── sample.go
│   ├── sample_test.go
│   ├── scalar.go
│   ├── scalar_test.go
│   ├── selectivity.go
│   ├── selectivity_test.go
│   ├── statistics_test.go
│   ├── table.go
│   └── testdata
│       ├── integration_suite_in.json
│       ├── integration_suite_out.json
│       ├── stats_suite_in.json
│       └── stats_suite_out.json
...
├── util
│   │
│   ...
│   ├── ranger
│   │   ├── checker.go
│   │   ├── detacher.go
│   │   ├── main_test.go
│   │   ├── points.go
│   │   ├── ranger.go
│   │   ├── ranger_test.go
│   │   ├── testdata
│   │   │   ├── ranger_suite_in.json
│   │   │   └── ranger_suite_out.json
│   │   ├── types.go
│   │   └── types_test.go
... ...
</code></pre>
<p>The <code>exeutor/analyze.go</code> places how <code>ANALYZE</code> executes and save to the TiKV storage. If you want to know the detailed data structure and how they are maintained, go through the <code>statistics</code> directory. For example, You can find how we define and maintain the histogram structure in <code>statistics/histogram.go</code>.</p>
<p>And for the TiKV repository, you can look into the directory <code>src/coprocessor/statistics/</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rule-based-optimization"><a class="header" href="#rule-based-optimization">Rule-based Optimization</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cost-based-optimization"><a class="header" href="#cost-based-optimization">Cost-based Optimization</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plan-cache"><a class="header" href="#plan-cache">Plan Cache</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>TiDB supports <code>PlanCache</code> for <code>prepare</code> and <code>execute</code> statements. By using <code>PlanCache</code>, TiDB can skip the optimization phase to gain some performance benefits.</p>
<p>There are several limitations to current <code>PlanCache</code>:</p>
<ol>
<li>Only support <code>prepare</code> and <code>execute</code> statements, not support general queries;</li>
<li>Only session-level <code>PlanCache</code> is supported, cached plans cannot be reused across sessions;</li>
<li>Some complex plans cannot be cached, and you can see <a href="https://docs.pingcap.com/tidb/stable/sql-prepare-plan-cache">this document</a> for more details;</li>
</ol>
<h2 id="handling-prepareexecute-statement"><a class="header" href="#handling-prepareexecute-statement">Handling Prepare/Execute Statement</a></h2>
<p>The process of handling a <code>prepare</code> statement is below:</p>
<ol>
<li>Parse the original SQL to an AST;</li>
<li>Encapsulate the AST with some other necessary information(like <code>current-db</code>, <code>statement-text</code>, ...) to <code>CachedPrepareStmt</code>;</li>
<li>Store the <code>CachedPrepareStmt</code> into this session's <code>PreparedStmtMap</code>;</li>
</ol>
<p>The process of handling an <code>execute</code> statement is below:</p>
<ol>
<li>Parse all parameters and store their values into this session's <code>PreparedParamMap</code>;</li>
<li>Get the corresponding <code>CachedPrepareStmt</code> from this session's <code>PreparedStmtMap</code>;</li>
<li>Construct the plan-cache key with information in <code>CachedPrepareStmt</code>;</li>
<li>Fetch a plan from the session's <code>PlanCache</code> by using this key, and:
<ol>
<li>if it succeeds, then
<ol>
<li>check whether this plan is valid for current parameters, if it is, then</li>
<li>rebuild the plan, and</li>
<li>run the rebuilt plan;</li>
</ol>
</li>
<li>else, then
<ol>
<li>optimize the AST in <code>CachedPrepareStmt</code> with current parameters to get a new plan, </li>
<li>store the new plan into current session's <code>PlanCache</code>, and</li>
<li>run the new plan.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="understand-tidb/../img/plan-cache-execute.png" alt="plan-cache-execute" /></p>
<p>The main function of handling <code>execute</code> is <code>common_plans.go:Execute.getPhysicalPlan()</code>.</p>
<h2 id="plan-rebuilding"><a class="header" href="#plan-rebuilding">Plan Rebuilding</a></h2>
<p>A cached plan cannot be reused directly unless it is rebuilt. The main goal of rebuilding is to re-calculate the access range. </p>
<p>For example, if the query is <code>select * from t where a&lt;?</code>, when you first <code>execute</code> it with <code>1</code>, then a <code>TableScan</code> with range <code>(-INF, 1)</code> could be generated and cached, and then you later <code>execute</code> it with <code>2</code>, the range has to be re-calculated to <code>(-INF, 2)</code> so that it can read correct data this time, and that is what plan rebuilding does.</p>
<p><img src="understand-tidb/../img/plan-cache-rebuilding.png" alt="plan-cache-rebuilding" /></p>
<p>The entry function of plan rebuilding is <code>common_plans.go:Execute.RebuildPlan()</code>.</p>
<h2 id="the-parameter-maker"><a class="header" href="#the-parameter-maker">The Parameter Maker</a></h2>
<p>Parameter Makers are used to propagate current parameter values to executors(operators).</p>
<p>For example, if the query is <code>select * from t where a+?&gt;1</code>, then the filter <code>a+?&gt;1</code> will be converted to a <code>Selection</code> operator with an expression-tree <code>a+?&gt;1</code>:</p>
<p><img src="understand-tidb/../img/plan-cache-parameter.png" alt="plan-cache-parameter" /></p>
<p>The parameter placeholder(<code>?</code>) is converted to a <code>ParamMaker</code> in <code>Constant</code>. </p>
<p>You can regard it as a special kind of pointer, and when the plan is processed and the parameter's value is needed, we can use it to get the corresponding value of this parameter.</p>
<pre><code>type Constant struct {
    ...
    ParamMaker *ParamMaker
}

func (c *Constant) Eval(row) Datum {
    if c.ParamMaker != nil {return c.ParamMaker.GetUserVal()}
    ...
}

func (d *ParamMaker) GetUserVal() Datum {
    return d.ctx.GetSessionVars().PreparedParams[d.order]
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sql-plan-management"><a class="header" href="#sql-plan-management">SQL Plan Management</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="execution"><a class="header" href="#execution">Execution</a></h1>
<p>The <code>executor</code> package contains most of the codes related to execution. The input of the executor is a plan tree of the query returned from the planner, and the output of the executor is the result of the query. The entry function of execution module is <code>executorBuild::build</code>, the output result is fetched in <code>clientConn::writeChunks</code>.</p>
<h2 id="execution-framework"><a class="header" href="#execution-framework">Execution Framework</a></h2>
<p>TiDB builds the computing engine based on the distributed storage provided by TiKV. The TiKV server implements a coprocessor framework to support distributed computing. The computing operations will be pushed to the TiKV coprocessor as far as possible to accelerate the computation speed. That is to say, a sub-plan of the SQL execution plan will be executed in parallel on different TiKV servers, and the result of each sub-plan will be collected to a TiDB server to compute for the final result.</p>
<p>The processing model of the execution plan tree is known as the Volcano iterator model. The essential of the Volcano model is abstracted to 3 interfaces: <code>Open</code>, <code>Next</code>, and <code>Close</code>. All operators offer the same interfaces and the implementation is opaque.</p>
<p><code>Open</code> will be invoked in turn for each operator to init the needed resources before computing. Conversely, <code>Close</code> will release the resources. To obtain the query output, the final operator in the plan tree will keep invoking <code>Next</code> until no tuple is pulled from its child.</p>
<p>It's easy to understand how the Volcano model works for single-process execution. For parallelism issues, the Volcano introduces an operator called <code>Exchange</code> at any desired point in a plan tree. Further explanation about the parallelism-related issues would be introduced in the <a href="understand-tidb/parallel-execution-framework.html">Parallel Execution Framework</a> section.</p>
<h2 id="vectorized-execution"><a class="header" href="#vectorized-execution">Vectorized Execution</a></h2>
<p>Vectorization uses the Volcano iteration model where each operator has a <code>Next</code> method that produces result tuples. However, each <code>Next</code> call fetches a block of tuples instead of just one tuple.</p>
<p>The main principle of vectorized execution is batched execution on a columnar data representation: every &quot;work&quot; primitive function that manipulates data does not work on a single data item, but on a vector (an array) of such data items that represents multiple tuples. The idea behind vectorized execution is to amortize the iterator call overhead by performing as much as possible inside the data manipulation methods. For example, this work can be to hash 1000s of values, compare 1000s of string pairs, update a 1000 aggregates, or fetch a 1000 values from 1000s of addresses.</p>
<p>Columnar Different from the row-oriented data representation, columnar format organize data by column rather by row. By storing data in columns rather than rows, the database can more precisely access the data it needs to answer a query rather than scanning and discarding unwanted data in rows. The memory columnar data representation in TiDB is defined as <code>Chunk</code>, which is inspired by <a href="https://arrow.apache.org/">Apache Arrow</a>.</p>
<p>The detailed definition and usage of <code>Chunk</code> will be introduced in the <a href="understand-tidb/implementation-of-vectorized-execution.html">Implementation of Vectorized Execution</a> section.</p>
<h2 id="memory-management-mechanism"><a class="header" href="#memory-management-mechanism">Memory Management Mechanism</a></h2>
<p>In TiDB, we set a memory usage quota for a query, and introduce two interfaces called <code>Tracker</code> and <code>OOMAction</code> for memory management.</p>
<p>The <code>Tracker</code> is used to track the memory usage of each element. The <code>OOMAction</code> is used to abstract the strategies to be used when the memory usage of a SQL exceeds the memory quota.</p>
<p>For example, we define the spill to disk strategy as <code>SpillDiskAction</code>. <code>SpillDiskAction</code> might be triggered by <code>HashJoin</code> or <code>Sort</code> when the memory quota is exceeded. If a query requires an order guarantee, and there is no index to guarantee the order, then the execution must sort the input before proceeding. If the input is small then the sort occurs in memory. We can split the input into multiple partitions and perform a merge sort on them. If the input is large, the <code>SpillDiskAction</code> will be triggered, an external sort algorithm is used. External sorting algorithms generally fall into two ways, sorting and merge. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined, and the final result will be outputted.</p>
<p>For more details, you can refers to the <a href="understand-tidb/memory-management-mechanism.html">Memory Management Mechanism</a> section.</p>
<h2 id="typical-operators"><a class="header" href="#typical-operators">Typical Operators</a></h2>
<p>TiDB implements multiple algorithms for the Join, Aggregation, Sort operators, and so on. We'll take some of them for detailed introduction. If you are interested, you can refer to the <a href="understand-tidb/implementation-of-typical-operators.html">Implementation of Typical Operators</a> section.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parallel-execution-framework"><a class="header" href="#parallel-execution-framework">Parallel Execution Framework</a></h1>
<p>In order to make full use of the multi-core ability of modern hardware, most popular DBMS have implemented the ability of parallel execution SQL execution engine.</p>
<p>There are three common parallel implementations: Intra operator parallelism, Exchange operator, and Morsel-Driven parallelism. And TiDB adopts the first approach.</p>
<h2 id="tidb-implementation"><a class="header" href="#tidb-implementation">TiDB Implementation</a></h2>
<p>In intra-operator parallelism, multiple goroutines will be created inside the operator for parallel processing. The creation, termination and synchronization of the goroutines are handled by the operator itself.</p>
<p>Most operators will create multiple goroutines in <code>Open()</code> or the first call of <code>Next()</code>. And they will wait on channels for input Chunk. Also, a special channel is responsible for notifying whether to stop the computation. And <code>WaitGroup</code> can be used to wait for the termination of all goroutines. This usually happens when <code>Close()</code> is called.</p>
<p>Taking HashJoin as an example, all workers will be started at the first call of <code>Next()</code>, including:</p>
<ol>
<li>buildSideFetcher: Will call <code>buildSideExec.Next()</code> to fetch input Chunk.</li>
<li>builderWorker: Receive data from the buildSideFetcher and build the HashTable.</li>
<li>probeSideFetcher: Wait for the end of building of the HashTable and call <code>probeSideExec.Next()</code> to fetch input Chunk.</li>
<li>probeWorker: Receive data from the probeSideFetcher and then probe the HashTable.</li>
</ol>
<p>When the main goroutine calls <code>HashJoinExec.Next()</code>, it will read data from the result channel and send an empty Chunk to the resource channel. When <code>HashJoinExec.Close()</code> is called, a special channel will be closed and all workers waiting on the channel will exit.</p>
<p>The parallel implementations of operators are various. For example, HashAgg is divided into two stages. Each stage will start multiple goroutines (partialWorkers and finalWorkers).</p>
<p>It is worth noting that we still use the traditional Volcano-model, the <code>Next()</code> is only called by a single thread. The parallelism only occurs in the internal processing of the operator.</p>
<p>The degree of parallelism (DOP) can be controlled by the session variable. For example, <code>tidb_executor_concurrency</code> is 5 by default. It means HashJoin will create five goroutines to probe HashTable. You can also control the parallelism of a specific operator by changing the session variable, such as <code>tidb_hash_join_concurrency</code>.</p>
<p>At present, most important operators have implemented intra-operator parallelism:</p>
<ol>
<li>Join: HashJoin, IndexJoin, IndexHashJoin, IndexMergeJoin</li>
<li>Apply: ParallelApply</li>
<li>Aggregation: HashAgg</li>
<li>Other: Union, Projection</li>
<li>Reader: TableReader, IndexReader</li>
</ol>
<p>Other operators are still single threaded: TopN, Limit, Sort, MergeJoin, StreamAgg, Selection, WindowFunc. But some of them (TopN, Limit, StreamAgg, Selection) can be pushed down to TiKV.</p>
<h2 id="other-parallelism-implementation"><a class="header" href="#other-parallelism-implementation">Other Parallelism Implementation</a></h2>
<p>Intra operator parallelism is the most intuitive way to implement parallelism, but its implementation is complex, because every operator needs to implement parallelism independently. What's worse, too many threads will increase the scheduling overhead. Although, the use of goroutines can alleviate this problem.</p>
<p>A more traditional way to implement parallelism is to use the exchange operator. By encapsulating the parallel logic into the exchange operator, all other operators only need to consider the single thread implementation.</p>
<p>The exchange operator is responsible for data exchange between different threads. The internal implementation of exchange is divided into two parts: sender and receiver. And data is transferred from sender to receiver in different ways, such as hash partition, random distribution or sort merge.</p>
<p>There are usually two ways to control DOP:</p>
<ol>
<li>Users can use hints to specify DOP explicitly.</li>
<li>The optimizer can choose DOP according to the table size of the scan operation automatically.</li>
</ol>
<p>This approach requires the optimizer to generate parallel plans. Generally, plan generation is divided into two stages. The first stage generates serial plans, and the second stage generates its corresponding parallel plans. The second stage is mainly responsible for inserting the exchange operator into the plan tree at the appropriate position. Both heuristic rules and cost model can be used to get the optimal parallel plan.</p>
<p>Currently, TiDB has a simplified implementation of exchange operator: <code>Shuffle Operator</code>. It can make MergeJoin, StreamAgg and WindowFunc run in parallel. And you can enable MergeJoin to be parallel by setting <code>tidb_merge_join_concurrency</code> be greater than 1.</p>
<p>For Morsel-Driven, it implements parallelism by dividing data into fixed size blocks (Morsel: usually 100000 rows). And a customized scheduler will be responsible for task scheduling to achieve better load balancing. And TiDB doesn't use this approach for now.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation-of-vectorized-execution"><a class="header" href="#implementation-of-vectorized-execution">Implementation of Vectorized Execution</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-mechanism-1"><a class="header" href="#memory-management-mechanism-1">Memory Management Mechanism</a></h1>
<p>TiDB's memory management basically consists of a memory usage quota settings for each query, and two interfaces, called <code>Tracker</code> and <code>OOMAction</code>.</p>
<h2 id="tracker"><a class="header" href="#tracker">Tracker</a></h2>
<p><code>Tracker</code> tracks the memory usage of each element with a tree structure.</p>
<p>Genral use cases:</p>
<pre><code class="language-text">                                               /--- Tracker(Component in Executor, e.g. list/rowContainer/worker)
                                               |           ...
                    /--- Tracker(Executor1) ---+--- Tracker(Component)
                    |
Tracker(Session) ---+--- Tracker(Executor2)
      |             |         ...
      |             \--- Tracker(Executor3)
 OOM-Action1
      |
      |
 OOM-Action2
     ...
</code></pre>
<p>When a component allocates some memory, it will call the function <code>Tracker.Consume(bytes)</code> to tell the <code>Tracker</code> how much memory it uses. <code>Tracker.Comsume</code> will traverse all its ancestor nodes, accumulate memory usage and trigger OOM-Action when exceeded.</p>
<h2 id="oom-action"><a class="header" href="#oom-action">OOM-Action</a></h2>
<p><code>OOM-Action</code> is a series of actions grouped in a linked list to reduce memory usage. Each node on the linked list abstracts a strategy to be used when the memory usage of a SQL exceeds the memory quota. For example, we define the spill to disk strategy as <code>SpillDiskAction</code>, rate limit strategy as <code>rateLimitAction</code> and cancel strategy as <code>PanicOnExceed</code>.</p>
<h3 id="rate-limit"><a class="header" href="#rate-limit">Rate Limit</a></h3>
<p>TiDB supports dynamic memory control for the operator that reads data. By default, this operator uses the maximum number of threads that <code>tidb_disql_scan_concurrency</code> allows to read data. When the memory usage of a single SQL execution exceeds <code>tidb_mem_quota_query</code> each time, the operator that reads data stops one thread.</p>
<p>We use <code>rateLimitAction</code> to dynamically control the data reading speed of <code>TableReader</code>.</p>
<h3 id="spill-disk"><a class="header" href="#spill-disk">Spill Disk</a></h3>
<p>TiDB supports disk spill for execution operators. When the memory usage of a SQL execution exceeds the memory quota, tidb-server can spill the intermediate data of execution operators to the disk to relieve memory pressure. Operators supporting disk spill include Sort, MergeJoin, HashJoin, and HashAgg.</p>
<h4 id="spilldiskaction"><a class="header" href="#spilldiskaction">SpillDiskAction</a></h4>
<p>We use <code>SpillDiskAction</code> to control the spill disk of <code>HashJoin</code> and <code>MergeJoin</code>. The data will be placed in Chunk unit when spilling. We can get any data in Chunk through random I/O.</p>
<h4 id="sortandspilldiskaction"><a class="header" href="#sortandspilldiskaction">SortAndSpillDiskAction</a></h4>
<p>We use <code>SortAndSpillDiskAction</code> to control the spill disk of <code>Sort</code>.</p>
<p>If the input of <code>SortExec</code> is small, then it sorts in memory. If the input is large, the <code>SortAndSpillDiskAction</code> will be triggered, and an external sort algorithm will be used. We can split the input into multiple partitions and perform a merge sort on them.</p>
<p>External sorting algorithms generally have two stages, sort and merge. In the sort stage, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge stage, the sorted subfiles are combined, and the final result will be outputted.</p>
<h4 id="aggspilldiskaction"><a class="header" href="#aggspilldiskaction">AggSpillDiskAction</a></h4>
<p>We use <code>AggSpillDiskAction</code> to control the spill disk of <code>HashAgg</code>. When <code>AggSpillDiskAction</code> is triggered, it will switch HashAgg executor to spill-mode, and the memory usage of HashAgg won't grow.</p>
<p>We use the following algorithm to control the memory increasing:</p>
<ol>
<li>When the memory usage is higher than the <code>mem-quota-query</code>, switch the HashAgg executor to spill-mode.</li>
<li>When HashAgg is in spill-mode, keep the tuple in the hash map no longer growing.
a. If the processing key exists in the Map, aggregate the result.
b. If the processing key doesn't exist in the Map, spill the data to disk.</li>
<li>After all data have been processed, output the aggregate result in the map, clear the map. Then read the spilling data from disk, repeat the Step1-Step3 until all data gets aggregated.</li>
</ol>
<p>As we can see, unlike other spilling implementations, <code>AggSpillDiskAction</code> does not make the memory drop immediately, but keeps the memory no longer growing. </p>
<h3 id="logcancel"><a class="header" href="#logcancel">Log/Cancel</a></h3>
<p>When the above methods cannot control the memory within the threshold, we will try to use <code>PanicOnExceed</code> to cancel the SQL or use <code>LogOnExceed</code> to log the SQL info.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation-of-typical-operators"><a class="header" href="#implementation-of-typical-operators">Implementation of Typical Operators</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<p>The transaction engine in TiDB is responsible to provide ACID guarantees for all the read and write requests. It consists of the client/coordinator part in the TiDB repository and the server/participant part in the TiKV repository. </p>
<p>This document is mainly about the TiDB part.</p>
<h2 id="the-architecture"><a class="header" href="#the-architecture">The Architecture</a></h2>
<p>In TiDB the transaction write flow is like this:</p>
<p><img src="understand-tidb/../img/transaction-architecture.png" alt="transaction-architecture" /></p>
<p>After the transaction starts in a session, all the reads and writes will use a snapshot to fetch data, and the written content will be buffered in the memory of the transaction. When the <code>commit</code> statement is received from the client, the Percolator protocol will be used to commit these changes to the storage system.</p>
<h2 id="the-interface"><a class="header" href="#the-interface">The Interface</a></h2>
<p>In TiDB, the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/kv/kv.go#L181-L234"><code>Transaction</code></a> interface defines the commonly used transaction operations.</p>
<pre><code class="language-go">type Transaction interface {
	// Commit commits the transaction operations to KV store.
	Commit(context.Context) error
	// Rollback undoes the transaction operations to KV store.
	Rollback() error
	// LockKeys tries to lock the entries with the keys in KV store.
	// Will block until all keys are locked successfully or an error occurs.
	LockKeys(ctx context.Context, lockCtx *LockCtx, keys ...Key) error
	// SetOption sets an option with a value, when val is nil, uses the default
	// value of this option.
	SetOption(opt int, val interface{})
	// GetOption returns the option
	GetOption(opt int) interface{}
	...
	// StartTS returns the transaction start timestamp.
	StartTS() uint64
	// Valid returns if the transaction is valid.
	// A transaction become invalid after commit or rollback.
	Valid() bool
	// GetMemBuffer return the MemBuffer binding to this transaction.
	GetMemBuffer() MemBuffer
	// GetSnapshot returns the Snapshot binding to this transaction.
	GetSnapshot() Snapshot
}
</code></pre>
<p>These are common interfaces the transaction will provide.</p>
<p>For example, <code>Commit</code> will be used to commit the current ongoing transaction. The transaction is considered ongoing before the <code>Commit</code> operation is triggered. The two-phase commit processing will be used to commit a transaction and it will finally become committed or aborted. </p>
<p><a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/session/txn.go#L50-L71"><code>LazyTxn</code></a> is a wrapper of the transaction implementations, when the SQL statements are executed using a standalone session context, <code>LazyTxn</code> will be used to do things like：</p>
<ul>
<li>Return the memory buffer for write.</li>
<li>Set specific operations or flags for the current transaction.</li>
<li>Return the snapshot of this transaction.</li>
<li>Commit the current transaction.</li>
<li>Lock specific keys.</li>
</ul>
<h2 id="the-statement-execution"><a class="header" href="#the-statement-execution">The Statement Execution</a></h2>
<p>Usually, the first thing that will be done executing a statement is to <code>activate</code> the related transaction</p>
<p>By default, TiDB provides the snapshot isolation level. Thus, in each new transaction, a new global strong snapshot will be fetched first, before executing statements.</p>
<p>In TiDB, the snapshot is represented by a global TSO which is fetched from the PD server, and it acts as the unique identifier for this transaction. After this operation, a transaction is regarded as <code>activated</code>.</p>
<p>For the read SQL statements, the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/snapshot.go">snapshot</a> will be used to provide a global strong consistent snapshot, all the reads will check data visibility using this snapshot. Most executors will set the timestamp doing the build, and the transaction could be activated by the building process. Some commonly used <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/snapshot.go#L40">snapshot</a> APIs are as below:</p>
<pre><code class="language-go">// BatchGet gets all the keys' value from kv-server and returns a map contains key/value pairs.
// The map will not contain nonexistent keys.
func (s *tikvSnapshot) BatchGet(ctx context.Context, keys []kv.Key) (map[string][]byte, error) {
	data, err := s.KVSnapshot.BatchGet(ctx, toTiKVKeys(keys))
	return data, extractKeyErr(err)
}

// Get gets the value for key k from snapshot.
func (s *tikvSnapshot) Get(ctx context.Context, k kv.Key) ([]byte, error) {
	data, err := s.KVSnapshot.Get(ctx, k)
	return data, extractKeyErr(err)
}
</code></pre>
<p>For the write SQL statements, they will write data into the transaction memory buffer temporarily until the <code>commit</code> operation is triggered. There are 3 main interfaces which will write query data into the memory buffer. Here is the <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/table/table.go#L166">table</a> API:</p>
<pre><code class="language-go">// Table is used to retrieve and modify rows in table.
type Table interface {
	// AddRecord inserts a row which should contain only public columns
	AddRecord(ctx sessionctx.Context, r []types.Datum, opts ...AddRecordOption) (recordID kv.Handle, err error)

	// UpdateRecord updates a row which should contain only writable columns.
	UpdateRecord(ctx context.Context, sctx sessionctx.Context, h kv.Handle, currData, newData []types.Datum, touched []bool) error

	// RemoveRecord removes a row in the table.
	RemoveRecord(ctx sessionctx.Context, h kv.Handle, r []types.Datum) error
}
</code></pre>
<p>Every statement will use a <code>staging</code> buffer during its execution. If it's successful, the staging content will be merged into the transaction memory buffer.</p>
<p>For example, <code>AddRecord</code> will try to write a row into the current statement staging buffer, and the <code>RemoveRecord</code> will try to remove a row from the staging statement buffer. The existing transaction memory buffer will not be affected if the statement has failed.</p>
<p>The memory buffer implementation is wrapped in <a href="https://github.com/pingcap/tidb/blob/af70762cd52519f025daa5e869ba37465a7fb311/store/driver/txn/unionstore_driver.go#L27-L29">memBuffer</a>. The internal implementation is <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/internal/unionstore/memdb.go"><code>MemDB</code> struct</a>.</p>
<p>The memory buffer is an ordered map and it provides the <code>staging</code> and <code>discard</code> utilities. For example, the memory content generated by a statement will be discarded if its execution has failed.</p>
<h2 id="the-two-phase-commit"><a class="header" href="#the-two-phase-commit">The Two-phase Commit</a></h2>
<p>After the statement execution phase, the <code>commit</code> statement will trigger the commit execution for the current transaction. In TiDB, the Percolator protocol is used as the distributed transaction protocol, it's a two-phase protocol.</p>
<p>In the first stage, the transaction coordinator (TiDB server) will try to prewrite all the related keys. If all of them are successful, the transaction coordinator will then commit the primary key. After that the transaction is considered committed successfully, and a success message will be responded to the client. All the other keys will be committed asynchronously.</p>
<p>All the changes in the transaction memory buffer will be converted into <a href="https://github.com/pingcap/kvproto/blob/dc1709169bb155de3bea6b28c871215387942994/proto/kvrpcpb.proto#L882">mutations</a> which will be used by the two-phase committer. These mutations will be grouped by their region locations, and prewrite requests will be sent to their region leaders.</p>
<p>If all the prewrite requests are processed successfully, the commit request for the primary key will be sent to TiKV first. If the primary key commit is successful, the transaction is considered committed and will respond to the client with successful results.</p>
<h2 id="recommended-reading"><a class="header" href="#recommended-reading">Recommended Reading</a></h2>
<ul>
<li><a href="https://tikv.org/deep-dive/distributed-transaction/percolator/">Percolator</a></li>
<li><a href="https://research.google/pubs/pub36726/">Large-scale Incremental Processing Using Distributed Transactions and Notifications</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="transaction-on-tikv"><a class="header" href="#transaction-on-tikv">Transaction on TiKV</a></h1>
<p><a href="understand-tidb/transaction.html">The previous section</a> introduces the architecture of the transaction engine and several implementation details in TiDB part. This document is mainly about the TiKV part.</p>
<p>As described in the previous section, the distributed transaction coordinator is <code>tidb-server</code> which receives and processes <code>COMMIT</code> query, and the transaction participants involved are <code>tikv-server</code>s.</p>
<h1 id="transactional-protocol"><a class="header" href="#transactional-protocol">Transactional Protocol</a></h1>
<p>The RPC interfaces in TiDB are defined in <a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L77">a protobuf file</a>, based on the Percolator model.</p>
<p>These interfaces will be used by the transaction coordinator to drive the whole commit process. For example <code>Prewrite</code> will be used to write the lock record in TiKV:</p>
<pre><code class="language-proto">message PrewriteRequest {
    Context context = 1;
    // The data to be written to the database.
    repeated Mutation mutations = 2;
    // The client picks one key to be primary (unrelated to the primary key concept in SQL). This
    // key's lock is the source of truth for the state of a transaction. All other locks due to a
    // transaction will point to the primary lock.
    bytes primary_lock = 3;
    // Identifies the transaction being written.
    uint64 start_version = 4;
    uint64 lock_ttl = 5;
    // TiKV can skip some checks, used for speeding up data migration.
    bool skip_constraint_check = 6;
    // For pessimistic transaction, some mutations don't need to be locked, for example, non-unique index key.
    repeated bool is_pessimistic_lock = 7;
    // How many keys this transaction involves in this region.
    uint64 txn_size = 8;
    // For pessimistic transactions only; used to check if a conflict lock is already committed.
    uint64 for_update_ts = 9;
    // If min_commit_ts &gt; 0, this is a large transaction request, the final commit_ts
    // will be inferred from `min_commit_ts`.
    uint64 min_commit_ts = 10;
    // When async commit is enabled, `secondaries` should be set as the key list of all secondary
    // locks if the request prewrites the primary lock.
    bool use_async_commit = 11;
    repeated bytes secondaries = 12;
    // When the transaction involves only one region, it's possible to commit the transaction
    // directly with 1PC protocol.
    bool try_one_pc = 13;
    // The max commit ts is reserved for limiting the commit ts of 1PC or async commit, which can be used to avoid
    // inconsistency with schema change.
    uint64 max_commit_ts = 14;
}
</code></pre>
<ul>
<li><code>mutations</code> are changes made by the transaction.</li>
<li><code>start_version</code> is the transaction identifier fetched from PD.</li>
<li><code>for_update_ts</code> is used by the pessimistic transactions.</li>
<li><code>try_one_pc</code> field is used if the transaction is committed using <code>one-phase</code> protocol.</li>
<li><code>use_async_commit</code> and <code>secondaries</code> will be used if the transaction is committed in the <code>async-commit</code> mode.</li>
</ul>
<p>Besides <code>prewrite</code> request, there are some other important request types:</p>
<ul>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L125"><code>pessimistic_lock</code> request</a> is used to lock a key. Note pessimistic locking happens in the transaction execution phase, for example a <code>select for update</code> statement will need to pessimistically lock the corresponding rows.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L268"><code>commit</code> request</a> is used to commit a key. After commit the write content is visible to other read or write transactions.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/master/proto/kvrpcpb.proto#L206"><code>check_txn_status</code> request</a> will be used to check the status of a given transaction, so that it could be decided how to process the conflicts.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/0f5764a128ad77ccf0a5b0ce0d6e2bfa50a108ce/proto/kvrpcpb.proto#L374"><code>resolve</code> request</a> will be used to help doing the transaction crash recovery.</li>
<li><a href="https://github.com/pingcap/kvproto/blob/master/proto/kvrpcpb.proto#L247"><code>check_secondary_locks</code> request</a> is a special API, it will be used if the commit mode of the transaction is <code>async-commit</code>.</li>
</ul>
<h1 id="transaction-scheduler"><a class="header" href="#transaction-scheduler">Transaction Scheduler</a></h1>
<p><img src="understand-tidb/../img/transaction_scheduler.png" alt="transaction-scheduler" /></p>
<p>The receiving input transaction requests will be translated into transaction <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/commands/mod.rs#L114">commands</a>. Then the transaction <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/scheduler.rs#L286">scheduler</a> will handle these transaction commands, it will first try to fetch the needed key <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/latch.rs#L22">latches</a> (latch is used to sequence all the transaction commands on the same key)，then try to fetch a storage <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/components/tikv_kv/src/lib.rs#L191">snapshot</a> for the current transaction processing.</p>
<p>The task will be processed as a <a href="https://doc.rust-lang.org/stable/std/future/trait.Future.html">future</a>. The future processing is done in the transaction scheduler thread-pool. Usually, there will be some tasks like conflict and constraint checks, write mutation generations. For example, the prewrite request processing will need to check if there is already a conflict <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/actions/prewrite.rs#L45">lock</a> or a conflict committed write <a href="https://github.com/tikv/tikv/blob/6be3893f7f787b04bf34d99d1369092404ab5cfc/src/storage/txn/actions/prewrite.rs#L59">record</a>.</p>
<h1 id="transaction-log-replication"><a class="header" href="#transaction-log-replication">Transaction Log Replication</a></h1>
<p>In TiDB, the key space is split into different ranges or regions. Each region is a raft group and its leader will be responsible for handling its key range related read/write requests. </p>
<p>If the transaction command processing in the transaction scheduler is successful, the generated transaction writes will be written into the raft log engine by the region leaders in <code>raftStore</code> (raft store will be introduced in other documents in details). The work flow is like this:</p>
<p><img src="understand-tidb/../img/raftStore.png" alt="RaftStore" /></p>
<p>The writes generated by transaction commands will be sent to the raft peer message task queue first, then the raft batch system will poll each raft peer and handle these requests in the raft thread-pool. After all the raft logs are persisted on majority raft group members, they are regarded as <code>commit</code>. Then the correspond apply task be delivered to the apply worker pool to apply the actual write contents to the storage engine, after that the transaction command processing is considered successful and the callback will be invoked to response <code>OK</code> results to the RPC client.</p>
<h1 id="transaction-record-in-tikv"><a class="header" href="#transaction-record-in-tikv">Transaction Record In TiKV</a></h1>
<p>In TiDB, a transaction is considered committed only if its primary key lock is committed successfully (if async commit protocol is not used). The actual key and value written into storage engine is in the following format:</p>
<table><thead><tr><th>CF</th><th align="left">RocksDB Key</th><th>RocksDB Value</th></tr></thead><tbody>
<tr><td>Lock</td><td align="left">user_key</td><td>lock_info</td></tr>
<tr><td>Default</td><td align="left">{user_key}{start_ts}</td><td>user_value</td></tr>
<tr><td>Write</td><td align="left">{user_key}{commit_ts}</td><td>write_info</td></tr>
</tbody></table>
<p>After <code>prewrite</code>, the lock correspond records for the transaction will be written into the storage. Read and write conflicts on the &quot;locked&quot; key will need to consider if it's safe to bypass the lock or it must try to resolve the encountered locks. As <code>commit_ts</code> is part of the stored key, there could be different historical versions for it, and GC is responsible to clean up all the old versions which will not be needed any more. GC mechanism will be introduced in another document.</p>
<h1 id="transaction-recovery"><a class="header" href="#transaction-recovery">Transaction Recovery</a></h1>
<p>In TiDB, the transaction coordinator (in <code>tidb-server</code>) is stateless and it will not persist any information. If the transaction coordinator fails for example the <code>tidb-server</code> crashes, the transaction context in memory will get lost, and as the coordinator is gone the normal commit processing will stop. How to recover the transaction state and make a decision if it should commit or abort? </p>
<p>Actually, there is no special mechanism to recover the undetermined-status transactions, the recovery is done by other concurrent conflict transactions, or the conflict transactions will help decide the actual states of the undetermined-status transactions. The lock resolve process will be triggered if the current ongoing transaction encounters locks of other transactions doing reads or writes. The whole resolve process will be introduced in other documents in details.</p>
<h1 id="transaction-optimizations"><a class="header" href="#transaction-optimizations">Transaction Optimizations</a></h1>
<p>Normally the transaction commit will need two phases, the <code>prewrite</code> phase and <code>commit</code> phase. Under certain circumstances transaction commit could be done in a single phase for example the generated transaction mutations could be processed by a single region leader. This optimization is called one-phase commit in TiDB.</p>
<p>The final transaction status is determined by the commit status of the primary key lock, so the response to the client has to wait until the primary key commit has finished. This wait could be saved using the <code>async-commit</code> protocol so the latency of commit processing could be reduced.</p>
<p>They will both be introduced other documents in details.</p>
<h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>This section talks about the brief steps of transaction processing in the TiKV part, and related interfaces, implementations and optimizations.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="optimistic-transaction"><a class="header" href="#optimistic-transaction">Optimistic Transaction</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lock-resolver"><a class="header" href="#lock-resolver">Lock Resolver</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pessimistic-transaction"><a class="header" href="#pessimistic-transaction">Pessimistic Transaction</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="async-commit"><a class="header" href="#async-commit">Async Commit</a></h1>
<p>Async commit is an optimization of two phase commit introduced in TiDB 5.0. The optimization greatly reduces the latency of the two phase commit process.</p>
<p>This document talks about the implementation of async commit in TiDB. It is recommended that you have learned about the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theories of async commit</a> first.</p>
<p>This document refers to the code of <a href="https://github.com/pingcap/tidb/tree/v5.2.1">TiDB v5.2.1</a>, the corresponding <a href="https://github.com/tikv/client-go/tree/daddf73a0706d78c9e980c91c97cc9ed100f1919">client-go</a> and <a href="https://github.com/tikv/tikv/tree/v5.2.1">TiKV v5.2.1</a>.</p>
<h2 id="tidb-part"><a class="header" href="#tidb-part">TiDB part</a></h2>
<h3 id="preparations"><a class="header" href="#preparations">Preparations</a></h3>
<p>Async commit does not change the behavior during transaction execution. The changes begin from <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1112">2PC execution</a>.</p>
<p>Because we need to record the key list in the primary lock, it is not suitable to use the async commit protocol for large transactions. And binlog does not support async commit, so we disable async commit if binlog is enabled. These checks can be found <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L999">here</a>.</p>
<p>And in the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theory blog</a>, we proves that using a latest timestamp from PD can guarantee linearizability. You can find the code <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1191">here</a>. Actually, it is not always necessary to get this timestamp, the comment <a href="https://github.com/pingcap/tidb/blob/v5.2.1/session/session.go#L559">here</a> explains it:</p>
<pre><code class="language-go">// priority of the sysvar is lower than `start transaction with causal consistency only`
if val := s.txn.GetOption(kv.GuaranteeLinearizability); val == nil || val.(bool) {
    // We needn't ask the TiKV client to guarantee linearizability for auto-commit transactions
    // because the property is naturally holds:
    // We guarantee the commitTS of any transaction must not exceed the next timestamp from the TSO.
    // An auto-commit transaction fetches its startTS from the TSO so its commitTS &gt; its startTS &gt; the commitTS
    // of any previously committed transactions.
    s.txn.SetOption(kv.GuaranteeLinearizability,
                    sessVars.TxnCtx.IsExplicit &amp;&amp; sessVars.GuaranteeLinearizability)
}
</code></pre>
<p>Later, we also calculate a <code>maxCommitTS</code>. This will be discussed later in the DDL compatibility part.</p>
<h3 id="prewrite"><a class="header" href="#prewrite">Prewrite</a></h3>
<p>If we decide to use async commit, we need to provide some <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L131">extra information</a> to enable the async commit protocol, the <code>UseAsyncCommit</code> flag and the secondary keys:</p>
<pre><code class="language-go">req := &amp;kvrpcpb.PrewriteRequest{/* ommitted */}
if c.isAsyncCommit() {
    if batch.isPrimary {
        req.Secondaries = c.asyncSecondaries()
    }
    req.UseAsyncCommit = true
}
</code></pre>
<p>If the <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L292">prewriting succeeds</a>, there are two cases.</p>
<p>If TiKV cannot proceed the async-commit protocol successfully, (probably because the calculated commit TS exceeds <code>maxCommitTS</code>), we fallback to the traditional percolator protocol. Otherwise, the prewrite request succeeds, so we can update the global <code>MinCommitTS</code>.</p>
<pre><code class="language-go">// 0 if the min_commit_ts is not ready or any other reason that async
// commit cannot proceed. The client can then fallback to normal way to
// continue committing the transaction if prewrite are all finished.
if prewriteResp.MinCommitTs == 0 {
    c.setAsyncCommit(false)
} else {
    c.mu.Lock()
    if prewriteResp.MinCommitTs &gt; c.minCommitTS {
        c.minCommitTS = prewriteResp.MinCommitTs
    }
    c.mu.Unlock()
}
</code></pre>
<p>However, if any response of prewrite is finally lost due to RPC reasons, it is impossible for us to know whether the prewriting succeeds. And it also means we cannot know whether the transaction succeeds. In this case, we can only <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/prewrite.go#L187">return an &quot;undetermined error&quot;</a> and the client connection will be closed:</p>
<pre><code class="language-go">defer func() {
    if err != nil {
        // If we fail to receive response for async commit prewrite, it will be undetermined whether this
        // transaction has been successfully committed.
        // If prewrite has been cancelled, all ongoing prewrite RPCs will become errors, we needn't set undetermined
        // errors.
        if (c.isAsyncCommit() || c.isOnePC()) &amp;&amp; sender.GetRPCError() != nil &amp;&amp; atomic.LoadUint32(&amp;c.prewriteCancelled) == 0 {
            c.setUndeterminedErr(errors.Trace(sender.GetRPCError()))
        }
    }
}()
</code></pre>
<p>But don't worry, this does not happen very often. It is safe to retry a prewrite which temporarily fails due to network reasons. The above problem only happens if a prewrite request has been sent, but later retries all fail due to RPC errors.</p>
<h3 id="commit"><a class="header" href="#commit">Commit</a></h3>
<p>The whole commit process is <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1370">done asynchronously in background</a>. This is why the optimization is called &quot;async commit&quot;:</p>
<pre><code class="language-go">if c.isAsyncCommit() {
    // For async commit protocol, the commit is considered success here.
    c.txn.commitTS = c.commitTS
    go func() {
        commitBo := retry.NewBackofferWithVars(c.store.Ctx(), CommitSecondaryMaxBackoff, c.txn.vars)
        c.commitMutations(commitBo, c.mutations)
    }()
    return nil
}
</code></pre>
<p>It does not matter even if some temporary error happens in the commit process. Anyone who encounters these uncommitted async-commit locks is able to finally commit them. Next, we will talk about this.</p>
<h3 id="transaction-recovery-1"><a class="header" href="#transaction-recovery-1">Transaction recovery</a></h3>
<p>If a reader encounters an expired async-commit lock, it needs to resolve this lock.</p>
<p>As usual, the primary lock is checked first to get the transaction information. If it is using the async-commit protocol, the primary lock is never cleaned in <code>CheckTxnStatus</code>. Then we call the <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L732"><code>resolveLockAsync</code> function</a> to resolve this transaction.</p>
<p>First, it checks all secondary locks. After that we should know the commit TS of this transaction. If all locks exist or some key has been committed, we can calculate a real commit TS. And if some lock does not exist, the commit TS is zero which indicates the transaction should be rolled back.</p>
<pre><code class="language-go">resolveData, err := lr.checkAllSecondaries(bo, l, &amp;status)
if err != nil {
    return err
}
status.commitTS = resolveData.commitTs
</code></pre>
<p>Then we can use this commit TS to resolve all the locks in this transaction.</p>
<p>Another case is when the transaction is actually not an async-commit transaction. Some keys are prewritten with the async-commit protocol while some keys fail and fallback. Such a case can be <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L674">detected</a> when checking secondary locks:</p>
<pre><code class="language-go">if !lockInfo.UseAsyncCommit {
    return &amp;nonAsyncCommitLock{}
}
</code></pre>
<p>And then, we will <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/txnlock/lock_resolver.go#L341">retry the lock resolving process</a> assuming the transaction is not an async-commit transaction. And now, <code>CheckTxnStatus</code> can clean up an expired primary lock:</p>
<pre><code class="language-go">if _, ok := errors.Cause(err).(*nonAsyncCommitLock); ok {
    err = resolve(l, true)
}
</code></pre>
<h3 id="ddl-compatibility"><a class="header" href="#ddl-compatibility">DDL compatibility</a></h3>
<p>Without async commit, we check whether the schema changes before the second phase of the commit. But as the transaction is committed after prewriting all the locks, we don't have the chance to check the schema version. Here we use a trick to work around the problem.</p>
<p>For DDLs which involve data reorganizations, we <a href="https://github.com/pingcap/tidb/blob/cd8fb24c5f7ebd9d479ed228bb41848bd5e97445/ddl/ddl.go#L691">delay</a> 3 seconds by default. Then, before doing 2PC, we <a href="https://github.com/tikv/client-go/blob/daddf73a07/txnkv/transaction/2pc.go#L1625">set <code>MaxCommitTS</code></a> to 2 seconds later from now:</p>
<pre><code class="language-go">func (c *twoPhaseCommitter) calculateMaxCommitTS(ctx context.Context) error {
	// Amend txn with current time first, then we can make sure we have another SafeWindow time to commit
	currentTS := oracle.ComposeTS(int64(time.Since(c.txn.startTime)/time.Millisecond), 0) + c.startTS
	_, _, err := c.checkSchemaValid(ctx, currentTS, c.txn.schemaVer, true)
	if err != nil {
		return errors.Trace(err)
	}

	safeWindow := config.GetGlobalConfig().TiKVClient.AsyncCommit.SafeWindow
	maxCommitTS := oracle.ComposeTS(int64(safeWindow/time.Millisecond), 0) + currentTS

	c.maxCommitTS = maxCommitTS
	return nil
}
</code></pre>
<p>Therefore, all async-commit transaction using the old schema should be committed before DDL reorganization happens. So, the DDL reorganization will not miss these data.</p>
<h2 id="tikv-part"><a class="header" href="#tikv-part">TiKV part</a></h2>
<h3 id="concurrency-manager"><a class="header" href="#concurrency-manager">Concurrency manager</a></h3>
<p>As discussed in the <a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">theory blog</a>, TiKV needs to record the max TS and set some memory locks for ongoing prewrite requests.</p>
<p>For simplicity, we use a global component to implement it. We call it the &quot;concurrency manager&quot;.</p>
<p>The methods provided by the concurrency manager can be found in <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/concurrency_manager/src/lib.rs">this file</a>.</p>
<p>It is very easy to update the max TS. It's just an atomic operation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_max_ts(&amp;self, new_ts: TimeStamp) {
    if new_ts != TimeStamp::max() {
        self.max_ts.fetch_max(new_ts.into_inner(), Ordering::SeqCst);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>It is a bit complex for memory locks.</p>
<p>The memory locks can have multiple accessors. Of course, the first one is the prewrite process. And because all readers need to check the memory locks, they are accessors of the memory locks, too. The locks can be removed from the table when there are no accessors.</p>
<p>So the memory table just owns a weak reference to the lock. We define the table like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LockTable(pub Arc&lt;SkipMap&lt;Key, Weak&lt;KeyHandle&gt;&gt;&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>To add a memory lock and be able to write lock information, the <code>lock_key</code> method needs to be called to get a lock guard. The locking process is a bit tricky to handle various possiblities in the multi-thread environment. If interested, you can refer to <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/concurrency_manager/src/lock_table.rs#L22">the code</a> for details.</p>
<h3 id="prewrite-1"><a class="header" href="#prewrite-1">Prewrite</a></h3>
<p>The code of prewrite can be found <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L405">here</a>. We will talk about some key points in the code about async commit.</p>
<p>In TiKV, <code>secondary_keys</code> and <code>try_one_pc</code> in the prewrite request are used to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L411-L415">determine the type</a> of the prewrite:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let commit_kind = match (&amp;self.secondary_keys, self.try_one_pc) {
    (_, true) =&gt; CommitKind::OnePc(self.max_commit_ts),
    (&amp;Some(_), false) =&gt; CommitKind::Async(self.max_commit_ts),
    (&amp;None, false) =&gt; CommitKind::TwoPc,
};
<span class="boring">}
</span></code></pre></pre>
<p>Only when prewriting the primary lock, secondary locks need to be written in the lock:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut secondaries = &amp;self.secondary_keys.as_ref().map(|_| vec![]);
if Some(m.key()) == async_commit_pk {
    secondaries = &amp;self.secondary_keys;
}
<span class="boring">}
</span></code></pre></pre>
<p>In the prewrite action, async commit does not change the checks. What is different is in the <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L367"><code>write_lock</code> function</a>.</p>
<p>Besides setting secondary keys in the primary lock, it calls <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L367"><code>async_commit_timestamps</code></a> to set <code>min_commit_ts</code> in the lock.</p>
<p>Here is the simplified code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let final_min_commit_ts = key_guard.with_lock(|l| {
    let max_ts = txn.concurrency_manager.max_ts();

    let min_commit_ts = cmp::max(cmp::max(max_ts, start_ts), for_update_ts).next();
    let min_commit_ts = cmp::max(lock.min_commit_ts, min_commit_ts);

    let max_commit_ts = max_commit_ts;
    if (!max_commit_ts.is_zero() &amp;&amp; min_commit_ts &gt; max_commit_ts) {
        return Err(ErrorInner::CommitTsTooLarge {
            start_ts,
            min_commit_ts,
            max_commit_ts,
        });
    }

    lock.min_commit_ts = min_commit_ts;
    *l = Some(lock.clone());
    Ok(min_commit_ts)
})?;

txn.guards.push(key_guard);
<span class="boring">}
</span></code></pre></pre>
<p>The final <code>min_commit_ts</code> is set to the maximum of (max TS + 1) and the original <code>min_commit_ts</code>. And if the <code>min_commit_ts</code> is greater than <code>max_commit_ts</code>, a <code>CommitTsTooLarge</code> is returned and triggers a fallback to non-async commit.</p>
<p>The operation is done while locked to guarantee the atomicity of getting the max TS and setting the <code>min_commit_ts</code> in the lock.</p>
<p>The key guard is saved until the lock is successfully written into RocksDB. Before that, readers are able to check the locks in order not to break any constraint. We can release the guard to remove the lock in the memory table after the readers can read the lock from the RocksDB.</p>
<h4 id="fallback-to-non-async-commit"><a class="header" href="#fallback-to-non-async-commit">Fallback to non-async commit</a></h4>
<p>The client may provide a <code>max_commit_ts</code> constraint. If the calculated <code>min_commit_ts</code> is larger than the <code>max_commit_ts</code>, we need to fallback to non-async commit. </p>
<p>When the <code>CommitTsTooLarge</code> error happens, the lock will still be written, but in the lock <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L406">there will be no <code>use_async_commit</code> flag</a> and no secondary keys will be recorded:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Err(Error(box ErrorInner::CommitTsTooLarge { .. })) = &amp;res {
    lock.use_async_commit = false;
    lock.secondaries = Vec::new();
}
<span class="boring">}
</span></code></pre></pre>
<p>After any key encounters this error, we <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L501">don't need to do async commit prewrite</a> for later keys:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> Err(MvccError(box MvccErrorInner::CommitTsTooLarge { .. })) | Ok((..)) =&gt; {
    // fallback to not using async commit or 1pc
    props.commit_kind = CommitKind::TwoPc;
    async_commit_pk = None;
    self.secondary_keys = None;
    // release memory locks
    txn.guards = Vec::new();
    final_min_commit_ts = TimeStamp::zero();
}
<span class="boring">}
</span></code></pre></pre>
<p>When any key in a transaction fallbacks to non-async commit mode, the transaction will be considered as a non-async commit transaction.</p>
<h3 id="memory-lock-checking"><a class="header" href="#memory-lock-checking">Memory lock checking</a></h3>
<p>All transactional reading requests need to update max TS and check memory locks. If the <code>min_commit_ts</code> of the lock is not larger than the snapshot timestamp of the reading, it is not safe to proceed this read. Then, an error will be returned and the client needs to retry later.</p>
<p>Here is <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/mod.rs#L1808">an example</a> in the storage module:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update max_ts and check the in-memory lock table before getting the snapshot
if !pb_ctx.get_stale_read() {
    concurrency_manager.update_max_ts(start_ts);
}
let isolation_level = pb_ctx.get_isolation_level();
if isolation_level == IsolationLevel::Si {
    for key in keys.clone() {
        concurrency_manager
            .read_key_check(key, |lock| {
                Lock::check_ts_conflict(Cow::Borrowed(lock), key, start_ts, bypass_locks)
            })
            .map_err(|e| txn::Error::from_mvcc(e))?;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="check-transaction-status"><a class="header" href="#check-transaction-status">Check transaction status</a></h3>
<p>We use <code>CheckTxnStatus</code> to get the status of the primary lock and use <code>CheckSecondaryLocks</code> for secondary locks.</p>
<p>In <code>CheckTxnStatus</code>, we cannot remove the primary lock simply because it is expired because the transaction may have prewritten all the locks. So we always just return the lock information for async commit locks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if lock.use_async_commit {
    if force_sync_commit {
        // The fallback case
    } else {
        return Ok((TxnStatus::uncommitted(lock, false), None));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The idea of <code>CheckSecondaryLocks</code> is simple. If any lock in the list of secondary keys does not exist, remove the lock and write rollback if necessary. And if any lock has been committed, the transaction is committed. You can refer to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/check_secondary_locks.rs#L54">its implementation</a> for details.</p>
<h3 id="update-max-ts-on-region-changes"><a class="header" href="#update-max-ts-on-region-changes">Update max TS on region changes</a></h3>
<p>In TiKV, we must guarantee that when a key is prewritten using the async-commit protocol, all readings at this key have updated the max TS. Now we update the max TS on the local TiKV. But there are some other cases we missed. If the reading happens on other TiKVs, then the region leader is transfered to the current TiKV or the region is merged into a region whose leader is on this TiKV, the max TS can be incorrect.</p>
<p>So, for safety, we choose to get a latest timestamp from PD when a region <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/raftstore/src/store/peer.rs#L1391">becomes leader</a> or a region <a href="https://github.com/tikv/tikv/blob/v5.2.1/components/raftstore/src/store/fsm/peer.rs#L2992">is merged</a>.</p>
<p>Before the max TS is updated, the corresponding region is not allowed to proceed an async-commit prewrite. The property is checked <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L364">here</a>.</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>This is how the &quot;async commit&quot; optimization is implemented in TiDB.</p>
<p>Due to limited space, some subtle problems such as non-unique timestamps and the compatibility with follower read are not involved.</p>
<p>During the implementation of async commit, many problems blocking one-phase commit (1PC) are solved. So it becomes relatively easy to implement 1PC in TiDB. The next document will introduce the implementation details of 1PC.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="1pc"><a class="header" href="#1pc">1PC</a></h1>
<p>Along with async commit, there is another optimization for transactions, namely 1PC. That is, for transactions that all keys can be prewritten in a single <em>prewrite</em> request to TiKV, we can commit it immediately while prewriting, skipping the second phase (the <em>commit</em> phase) completely. This reduces latency and improves throughput in scenarios where there are many small and simple transactions.</p>
<p>Before working on development related to 1PC, it's recommended to understand how 1PC (as well as async commit) works, and how async commit is implemented (since 1PC is implemented based on async commit). It's recommended to read these two articles first, and this article assumes you already know about them:</p>
<ul>
<li><a href="https://en.pingcap.com/blog/async-commit-the-accelerator-for-transaction-commit-in-tidb-5.0">This article</a> is a great material to learn about the overall idea of async commit and 1PC.</li>
<li><a href="understand-tidb/async-commit.html">This article</a> explains the code related to async commit.</li>
</ul>
<h2 id="rpc-protocol"><a class="header" href="#rpc-protocol">RPC Protocol</a></h2>
<p>A few additional fields to the <code>Prewrite</code> RPC messages are needed for 1PC.</p>
<pre><code class="language-protobuf">message PrewriteRequest {
    // ...
    bool try_one_pc = 13;
    uint64 max_commit_ts = 14;
}

message PrewriteResponse {
    // ...
    uint64 one_pc_commit_ts = 4;
}
</code></pre>
<ul>
<li>The <code>try_one_pc</code> field in the request is to tell TiKV that when handling the prewrite request, it needs to try to commit it directly in 1PC if possible.</li>
<li>The <code>max_commit_ts</code> is used by 1PC and async commit in common. It limits the maximum allowed commit ts. It's related to a mechanism to avoid a transaction commits while schema changed between the transaction's start_ts and commit_ts. This is mechanism is already explained in the <a href="understand-tidb/async-commit.html#ddl-compatibility">article about async commit</a>.</li>
<li>When TiKV successfully commits a transaction in 1PC, the <code>one_pc_commit_ts</code> field in the <code>PrewriteResponse</code> will be set to tell TiDB the final commit_ts. Sometimes TiKV may fail to commit the transaction by 1PC, but it's able to prewrite it in normal 2PC way. In this case, the <code>one_pc_commit_ts</code> will be zero to indicate that TiDB still needs to proceed on the 2PC procedure (i.e. the commit phase of 2PC).</li>
</ul>
<h2 id="tidb-part-1"><a class="header" href="#tidb-part-1">TiDB Part</a></h2>
<p>Based on the implementation of normal 2PC and async commit, there isn't too much additional code to support 1PC, but the code changes are scattered.</p>
<p>The core of 2PC logic is in <code>twoPhaseCommitter</code>, and the entry is the <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/2pc.go#L1115"><code>execute</code> method</a>. You might already know about it from previous articles. But since the path from the <code>execute</code> function to sending RPC requests is quite complicated, let's see how the overall control flow looks like:</p>
<ul>
<li><code>execute</code>
<ul>
<li>⭐ <code>checkOnePC</code></li>
<li><code>prewriteMutations</code>
<ul>
<li><code>doActionOnMutations</code>
<ul>
<li>⭐ <code>checkOnePCFallBack</code></li>
<li><code>doActionOnGroupMutations</code>
<ul>
<li>Divide mutations into batches</li>
<li>⭐ <code>checkOnePCFallBack</code> </li>
<li><code>doActionOnBatches</code>
<ul>
<li><code>actionPrewrite</code>.<code>handleSingleBatch</code>
<ul>
<li><code>buildPrewriteRequest</code></li>
<li><code>SendReq</code></li>
<li>⭐ Error handling (maybe fallback, maybe retry <code>doActionOnMutations</code> recursively)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If not committed in 1PC, continue 2PC or async commit procedure.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The starred items are the ones we are interested in in this article.</p>
<h3 id="checking-if-1pc-can-be-used"><a class="header" href="#checking-if-1pc-can-be-used">Checking if 1PC Can Be Used</a></h3>
<p>In the <code>execute</code> method, it checks if 1PC can be used just after checking async commit, before performing any crucial part of the transaction procedure:</p>
<pre><code class="language-go">func (c *twoPhaseCommitter) checkOnePC() bool {
    // Disable 1PC in local transactions. This is about another feature that's not compatible with
    // async and 1PC, where transactions have two different &quot;scopes&quot; namely Global and Local.
    if c.txn.GetScope() != oracle.GlobalTxnScope {
        return false
    }

    return !c.shouldWriteBinlog() &amp;&amp; c.txn.enable1PC // `txn` is the `KVTxn` object and the value of
                                                     // `enable1PC` is passed from Session previously.
}

func (c *twoPhaseCommitter) execute(ctx context.Context) (err error) {
    // ...

    // Check if 1PC is enabled.
    if c.checkOnePC() {
        commitTSMayBeCalculated = true
        c.setOnePC(true)
        c.hasTriedOnePC = true
    }

    // ...
}
</code></pre>
<p>Same as async commit, 1PC can't be enabled when using TiDB-Binlog.</p>
<p>Note that we still don't know how many prewrite requests this transaction needs. It will be checked later.</p>
<p>Also note that the <code>checkOnePC</code> function doesn't check the transaction's size like how async commit does. Actually, the transaction size is implicitly limited when the keys are divided into batches during prewrite phase. </p>
<p>The logic then goes to the <code>prewriteMutation</code> function from <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/2pc.go#L1222">here</a>, which then calls <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/2pc.go#L563">the <code>doActionOnMutations</code> function</a>:</p>
<pre><code class="language-go">func (c *twoPhaseCommitter) doActionOnMutations(bo *retry.Backoffer, action twoPhaseCommitAction, mutations CommitterMutations) error {
	if mutations.Len() == 0 {
		return nil
	}
	groups, err := c.groupMutations(bo, mutations)
	if err != nil {
		return errors.Trace(err)
	}

	// This is redundant since `doActionOnGroupMutations` will still split groups into batches and
	// check the number of batches. However we don't want the check fail after any code changes.
	c.checkOnePCFallBack(action, len(groups))

	return c.doActionOnGroupMutations(bo, action, groups)
}
</code></pre>
<p>This function divides the mutations by regions, which means, mutations to keys that belong to the same region are grouped together. Then it calls <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/2pc.go#L690">the <code>doActionOnGroupMutations</code> function</a>:</p>
<pre><code class="language-go">func (c *twoPhaseCommitter) doActionOnGroupMutations(bo *retry.Backoffer, action twoPhaseCommitAction, groups []groupedMutations) error {
	// ...

	batchBuilder := newBatched(c.primary())
	for _, group := range groups {
		batchBuilder.appendBatchMutationsBySize(group.region, group.mutations, sizeFunc, txnCommitBatchSize)
	}
	firstIsPrimary := batchBuilder.setPrimary()

	// ...

	c.checkOnePCFallBack(action, len(batchBuilder.allBatches()))

    // ...
</code></pre>
<p><code>doActionOnGroupMutations</code> divides each group into multiple batches if the group has too many keys.</p>
<p>Note that these two functions both call a function named <code>checkOnePCFallBack</code>. It's a helper to check if the transaction needs more than one request to finish prewrite. If so, the 1PC flag will be set to <code>false</code> and 1PC will be disabled for this transaction.</p>
<h3 id="sending-rpc-requests"><a class="header" href="#sending-rpc-requests">Sending RPC Requests</a></h3>
<p>After the procedure stated above, the control flow goes to <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/prewrite.go#L149">the <code>handleSingleBatch</code> method</a> of the <code>actionPrewrite</code> type. Then there's nothing complicated. It creates an RPC request for prewrite, and the <code>try_one_pc</code> field of the request will be set according to whether 1PC is still enabled after the previous procedure. For a 1PC transaction, once <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/prewrite.go#L208"><code>sender.Send</code></a> is invoked and nothing goes wrong, it means the transaction is successfully committed by 1PC. Finally, the <code>execute</code> function will <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/2pc.go#L1273-L1284">return</a> without running the 2PC commit.</p>
<h3 id="error-handling-and-falling-back"><a class="header" href="#error-handling-and-falling-back">Error Handling and Falling Back</a></h3>
<p>However, there are chances that something goes wrong. There are multiple possible cases, some of which needs to be paid attention of:</p>
<h4 id="region-error"><a class="header" href="#region-error">Region Error</a></h4>
<p>A region error means the region may have been changed, including merging and splitting, therefore the request is invalid since it's using an outdated region information.</p>
<p>Suppose we are trying to do prewrite for a 1PC transaction and encountered a region error. The keys in the transaction were located in a single region before, thus 1PC can be used. But the region's state has already changed, so the keys may be located in more than one new regions, if region splitting has happened.</p>
<p>However, we don't need any extra code to handle it for 1PC in this case. That's because on region error, it will <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/prewrite.go#L248">retry recursively</a>, where <code>checkOnePCFallBack</code> will be invoked again. So in the stated above, the <code>checkOnePCFallBack</code> call will unset the 1PC flag while retrying.</p>
<h4 id="fallen-back-by-tikv"><a class="header" href="#fallen-back-by-tikv">Fallen Back by TiKV</a></h4>
<p>When TiKV receives a prewrite request with <code>try_one_pc</code> flag set, sometimes it's possible that TiKV cannot commit it directly in 1PC. In this case TiKV will perform a normal prewrite, and return a response with <code>one_pc_commit_ts = 0</code> to indicate that the transaction is not committed in 1PC way. Then, TiDB will continue normal 2PC procedure.</p>
<p>Currently, the only possible case that this fallback happens is that the calculated <code>min_commit_ts</code> exceeds our <code>max_commit_ts</code>, therefore neither 1PC nor async commit can be used. The handling logic is <a href="https://github.com/tikv/client-go/blob/4fc565e203a99400d0b080a25a93fb860b3b6fd6/txnkv/transaction/prewrite.go#L272-L280">here</a>.</p>
<h4 id="rpc-error"><a class="header" href="#rpc-error">RPC Error</a></h4>
<p>If we cannot receive an RPC response after a few retries, same as that in <a href="understand-tidb/async-commit.html#prewrite">async commit</a>, there will be an undetermined error that will close the client connection.</p>
<h3 id="recovery"><a class="header" href="#recovery">Recovery</a></h3>
<p>When a 2PC transaction crashes on the half way, we need some mechanism to know the transaction's final state (committed or rolled back). For a 1PC transaction, things are much simpler: since TiKV performs the 1PC writing atomically, so the transaction must be either not-prewritten state or fully committed state. In other words, a 1PC transaction won't leave any lock after a crash. Therefore, nothing about 1PC transactions needs recovery.</p>
<h2 id="tikv-part-1"><a class="header" href="#tikv-part-1">TiKV Part</a></h2>
<p>1PC and async commit face the same challenges: <code>commit_ts</code> calculation, follower read consistency, etc. Therefore, 1PC and async commit share many code, including the concurrency manager and many logic in the prewrite procedure.</p>
<p>1PC transaction fetches the <code>max_ts</code> for <code>min_commit_ts</code> calculation and acquires the memory lock in the concurrency manager in the same way as how async commit does. The falling back logic is also using the same code as async commit. For details about them, please refer to <a href="understand-tidb/async-commit.html#tikv-part">the article of async commit</a>.</p>
<p>The only notable difference from async commit is what data is being written after the prewrite request.</p>
<p>First, <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/actions/prewrite.rs#L417">here</a> the <code>txn</code> object buffers data in a different way from non-1PC transaction:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl MvccTxn
pub(crate) fn put_locks_for_1pc(&amp;mut self, key: Key, lock: Lock, remove_pessimstic_lock: bool) {
    self.locks_for_1pc.push((key, lock, remove_pessimstic_lock));
}
<span class="boring">}
</span></code></pre></pre>
<p>Different from the normal <code>put_locks</code> function, locks are not serialized into bytes at this time. Neither are them immediately converted to <code>Write</code> records. It's because we don't know how they should be serialized until all keys are processed. While we expect the keys will be committed by 1PC, it's also possible that we find they need to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L506-L507">fallback</a> to 2PC later, in which case the locks will be <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L751-L755">converted</a> to normal 2PC locks.</p>
<p>Then, If we don't see any error after processing all keys, the locks recorded by the <code>put_locks_for_1pc</code> function will be converted into <code>Write</code> records, and the final <code>min_commit_ts</code> will be used as the <code>commit_ts</code> (<a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L547">here</a> and <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/storage/txn/commands/prewrite.rs#L719">here</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Commit and delete all 1pc locks in txn.
fn handle_1pc_locks(txn: &amp;mut MvccTxn, commit_ts: TimeStamp) -&gt; ReleasedLocks {
    let mut released_locks = ReleasedLocks::new(txn.start_ts, commit_ts);

    for (key, lock, delete_pessimistic_lock) in std::mem::take(&amp;mut txn.locks_for_1pc) {
        let write = Write::new(
            WriteType::from_lock_type(lock.lock_type).unwrap(),
            txn.start_ts,
            lock.short_value,
        );
        // Transactions committed with 1PC should be impossible to overwrite rollback records.
        txn.put_write(key.clone(), commit_ts, write.as_ref().to_bytes());
        if delete_pessimistic_lock {
            released_locks.push(txn.unlock_key(key, true));
        }
    }

    released_locks
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the special handling about <code>delete_pessimistic_lock</code>. If the transaction is a pessimistic transaction, there may already be pessimistic locks when we are performing <code>Prewrite</code>. Since we will write the <code>Write</code> record instead of overwriting the lock, if there's a pessimistic lock, it need to be deleted.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Based on the work already done by async commit, there's not much code introduced by 1PC. 1PC faced a lot of tricky challenges that async commit meets too, and therefore the implementation of 1PC and async commit shares many common code. If you understand how async commit works, 1PC will not be too hard to understand.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mvcc-garbage-collection"><a class="header" href="#mvcc-garbage-collection">MVCC Garbage Collection</a></h1>
<p>TiDB is a database built on TiKV, a multi-version storage engine which supports <a href="https://en.wikipedia.org/wiki/Snapshot_isolation">Snapshot Isolation</a>(SI) based on the <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MultiVersion Concurrency Control</a> (MVCC). Semantically, a multi-version system keeps multi copies of data. However, in the long-term running, there will be many garbage data that takes up a lot of disk space as well as has an impact on performance. A GC is responsible for cleaning up unused data and free the space while minimizing the impact on the system. This document talks about how MVCC GC works and implements in TiDB.</p>
<p>This document refers to the code of <a href="https://github.com/pingcap/tidb/tree/v5.2.1">TiDB v5.2.1</a>, <a href="https://github.com/tikv/pd/tree/v5.2.1">PD v5.2.1</a>, and <a href="https://github.com/tikv/tikv/tree/v5.2.1">TiKV v5.2.1</a>.</p>
<h2 id="tidb-part-2"><a class="header" href="#tidb-part-2">TiDB part</a></h2>
<p>You probably already know that data is stored in TiKV instances in a TiDB cluster. However, the GC process should be triggered by TiDB because it's the coordinator of the cluster. There are several requirements for TiDB when triggering GC.</p>
<ul>
<li>Clean up as much garbage data as possible.</li>
<li>Any data that is possibly read by opened transactions should be kept.</li>
<li>GC should not be frequently triggered.</li>
</ul>
<p>There is an inner table named <code>mysql.tidb</code> in TiDB which stores many runtime information. Actually, these variables are stored in TiKV as common KV variables. We'll talk about the usage of these variables in the GC workflow later.</p>
<pre><code>MySQL [test]&gt; select * from mysql.tidb where variable_name like &quot;tikv_gc_%&quot;;
+--------------------------+----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+
| VARIABLE_NAME            | VARIABLE_VALUE                                                                         | COMMENT                                                                                     |
+--------------------------+----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+
| tikv_gc_leader_uuid      | 5f0c276e9bc0002                                                                        | Current GC worker leader UUID. (DO NOT EDIT)                                                |
| tikv_gc_leader_desc      | host:xxxxx, pid:95695, start at 2021-09-29 16:13:35.740303321 +0800 CST m=+5.325166809 | Host name and pid of current GC leader. (DO NOT EDIT)                                       |
| tikv_gc_leader_lease     | 20210929-17:09:35 +0800                                                                | Current GC worker leader lease. (DO NOT EDIT)                                               |
| tikv_gc_enable           | true                                                                                   | Current GC enable status                                                                    |
| tikv_gc_run_interval     | 10m0s                                                                                  | GC run interval, at least 10m, in Go format.                                                |
| tikv_gc_life_time        | 10m0s                                                                                  | All versions within life time will not be collected by GC, at least 10m, in Go format.      |
| tikv_gc_last_run_time    | 20210929-17:03:35 +0800                                                                | The time when last GC starts. (DO NOT EDIT)                                                 |
| tikv_gc_safe_point       | 20210929-16:53:35 +0800                                                                | All versions after safe point can be accessed. (DO NOT EDIT)                                |
| tikv_gc_auto_concurrency | true                                                                                   | Let TiDB pick the concurrency automatically. If set false, tikv_gc_concurrency will be used |
| tikv_gc_scan_lock_mode   | legacy                                                                                 | Mode of scanning locks, &quot;physical&quot; or &quot;legacy&quot;                                              |
| tikv_gc_mode             | distributed                                                                            | Mode of GC, &quot;central&quot; or &quot;distributed&quot;                                                      |
+--------------------------+----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+
11 rows in set (0.003 sec)
</code></pre>
<h3 id="gc-worker"><a class="header" href="#gc-worker">GC Worker</a></h3>
<p><code>GCWorker</code> is the component responsible for triggering GC in TiDB.</p>
<pre><code class="language-go">// GCWorker periodically triggers GC process on tikv server.
type GCWorker struct {
	uuid         string
	desc         string
	...
}
</code></pre>
<p>In <code>GCWorker</code> structure, <code>uuid</code> field is the unique identifier. When it's initialized, a timestamp is fetched from PD and formatted as a 16-digit hex string, and used as the <code>uuid</code>. <code>desc</code> is a human-readable identifier that is composed of <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L93">some instance information</a>.</p>
<p>The Start function of GCWorker will be called when TiDB is bootstrapped. In <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L105-L113">this file</a>, a goroutine will be created for triggering GC jobs periodically.</p>
<pre><code class="language-go">// Start starts the worker.
func (w *GCWorker) Start() {
	var ctx context.Context
	ctx, w.cancel = context.WithCancel(context.Background())
	var wg sync.WaitGroup
	wg.Add(1)
	go w.start(ctx, &amp;wg)
	wg.Wait() // Wait create session finish in worker, some test code depend on this to avoid race.
}
</code></pre>
<p>There is a <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L214-L229">ticker</a> in <code>GCWorker</code> that will try running the GC task every minute. We'll talk about how it works in the following sections.</p>
<h3 id="gc-leader"><a class="header" href="#gc-leader">GC Leader</a></h3>
<p>In TiDB's design, there is only one GC leader which can trigger GC in the cluster, so there is an election and lease for the proposal of the leader. <code>GCWorker</code> checks if it itself is the leader before starting a real GC job.</p>
<pre><code class="language-go">func (w *GCWorker) tick(ctx context.Context) {
	isLeader, err := w.checkLeader()
	...
	if isLeader {
		err = w.leaderTick(ctx)
		...
	} else {
		// Config metrics should always be updated by leader, set them to 0 when current instance is not leader.
		metrics.GCConfigGauge.WithLabelValues(gcRunIntervalKey).Set(0)
		metrics.GCConfigGauge.WithLabelValues(gcLifeTimeKey).Set(0)
	}
}
</code></pre>
<p>Luckily, TiDB is built on a durable and high-available storage layer, which makes the election quite easy by the following mechanism.</p>
<p><img src="understand-tidb/../img/gc-leader-election.png" alt="gc-leader-election.png" /></p>
<p>This is the flowchart of leader election which is implemented in <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L1669"><code>checkLeader</code></a> function, if the result is leader, we then trying to tick a GC.</p>
<h3 id="gc-prepare"><a class="header" href="#gc-prepare">GC Prepare</a></h3>
<p>When a GC workflow is triggered, we are facing another issue - find out the data that can be cleaned up.</p>
<p>Since TiDB follows SI isolation level, all reads performed in a transaction should get the result from the same timestamp, if not so, there will be consistency and repeatable read issues. Besides, we don't want that the garbage data is cleaned up once after it's not used, because recovery is important when misoperations. That means before starting a GC round, there are <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L362-L393">many checks</a>.</p>
<pre><code class="language-go">func (w *GCWorker) checkPrepare(ctx context.Context) (bool, uint64, error) {
	enable, err := w.checkGCEnable()
	...
	now, err := w.getOracleTime()
	...
	ok, err := w.checkGCInterval(now)
	...
	newSafePoint, newSafePointValue, err := w.calcNewSafePoint(ctx, now)
	...
	err = w.saveTime(gcLastRunTimeKey, now)
	...
	err = w.saveTime(gcSafePointKey, *newSafePoint)
	...
	return true, newSafePointValue, nil
}
</code></pre>
<p>GC is enabled by default, but it's allowed to be turned off. In prepare stage, it'll check if GC is enabled first.</p>
<p>In TiDB, there is a variable named <code>tikv_gc_run_interval</code> which controls the frequency of GC. It's the min interval between 2 GC rounds, 10min by default.</p>
<p>Once it's ready to perform a GC round, <code>calcNewSafePoint</code> is called to get a new safepoint, this deals with some long-term opened transactions. We'll talk about how safepoint is decided later.</p>
<p>If a new safepoint is got, we then update the GC checkpoint and new safepoint, here we're ready to start a GC round. It's ok that TiDB collapses after the new GC round is set because it won't break the GC promises, we just skip a round of GC.</p>
<h3 id="gc-safepoint"><a class="header" href="#gc-safepoint">GC Safepoint</a></h3>
<p>This is the key problem of GC.</p>
<p>What we desired is the min transaction start timestamp between all TiDB instances. TiDB instances will store their min start timestamp in PD's etcd, so we just fetch all the min transaction start timestamps <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L395-L413">here</a>. <code>GetWithPrefix</code> will get all KV pairs from the etcd storage.</p>
<pre><code class="language-go">func (w *GCWorker) calcGlobalMinStartTS(ctx context.Context) (uint64, error) {
	kvs, err := w.tikvStore.GetSafePointKV().GetWithPrefix(infosync.ServerMinStartTSPath)
	if err != nil {
		return 0, err
	}

	var globalMinStartTS uint64 = math.MaxUint64
	for _, v := range kvs {
		minStartTS, err := strconv.ParseUint(string(v.Value), 10, 64)
		if err != nil {
			logutil.Logger(ctx).Warn(&quot;parse minStartTS failed&quot;, zap.Error(err))
			continue
		}
		if minStartTS &lt; globalMinStartTS {
			globalMinStartTS = minStartTS
		}
	}
	return globalMinStartTS, nil
}
</code></pre>
<p>TiDB server has the risk of crash, however, if a never-pushed-up min start timestamp is left in the system, GC will never works. To solve this issue, the min start timestamp is set with a lease and if TiDB is offline for a long duration, that min start timestamp will be cleared.</p>
<p>After we get all the min start timestamps from etcd, it's easy to calculate the global min start timestamp. It's easy to know the min start timestamp from a single TiDB instance, and every TiDB instance will report it's min start timestamp to etcd in <a href="https://github.com/pingcap/tidb/blob/v5.2.1/domain/infosync/info.go#L548-L570"><code>ReportMinStartTS</code></a> function every interval.</p>
<p>There is a further situation cannot be handled by calculating the global min start timestamp across all TiDB servers, some tools may require TiDB keep data available for a long time. e.g., when <a href="https://github.com/pingcap/tidb/tree/v5.2.1/br">BR</a> is processing backup task, the snapshot should be kept even the specific lifetime has been passed. This is checked when <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L590-L612"><code>setGCWorkerServiceSafePoint</code></a> is called.</p>
<h3 id="gc-workflow"><a class="header" href="#gc-workflow">GC Workflow</a></h3>
<p>Once the safepoint is decided and prepare stage is done, it's ready to start a GC workflow. Generally, there are three steps to do.</p>
<ul>
<li>Resolve locks.</li>
<li>Delete unused ranges.</li>
<li>GC for every key.</li>
</ul>
<p>The workflow can be found from <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L614-L682">GC job function</a>. The main intent of this workflow is to clean up data has more impact on the running tasks earlier.</p>
<p>In resolve locks phase, GC will clean up the locks of aborted transaction and commit the locks of success transaction. <code>GCWorker</code> scans the locks from every store and call <a href="https://github.com/tikv/client-go/blob/daddf73a0706d78c9e980c91c97cc9ed100f1919/txnkv/txnlock/lock_resolver.go#L184"><code>BatchResolveLocks</code></a> for cleaning up, you may read <a href="understand-tidb/lock-resolver.html">lock resolver chapter</a> for more information about locks.</p>
<p>There are two modes when scanning locks, legacy mode and physical mode. Currently, only legacy mode is stable. The physical mode(a.k.a., Green GC) is introduced in TiDB 4.0, however not GA yet. When it is available, it's possible to scan locks by physical mode which bypasses the Raft layer and scan the locks directly. The <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L1001-L1018"><code>resolveLocks</code></a> function will use legacy mode as a fallback even if physical mode is set.</p>
<pre><code class="language-go">func (w *GCWorker) resolveLocks(ctx context.Context, safePoint uint64, concurrency int, usePhysical bool) (bool, error) {
	if !usePhysical {
		return false, w.legacyResolveLocks(ctx, safePoint, concurrency)
	}
	// First try resolve locks with physical scan
	err := w.resolveLocksPhysical(ctx, safePoint)
	if err == nil {
		return true, nil
	}
	...
	return false, w.legacyResolveLocks(ctx, safePoint, concurrency)
}
</code></pre>
<p>The <code>GCWorker</code> then cleans up unused ranges, which are caused by drop table or drop index statements. When executing the drop statements in TiDB, TiDB only marks some ranges to be deleted and returns success. These to-be-deleted ranges are actually cleaned up in GC.</p>
<pre><code>MySQL [test]&gt; create table t(id int primary key, v int, key k(v));
Query OK, 0 rows affected (0.109 sec)

MySQL [test]&gt; insert into t values(1,1),(2,2),(3,3);
Query OK, 3 rows affected (0.004 sec)
Records: 3  Duplicates: 0  Warnings: 0

MySQL [test]&gt; alter table t drop index k;
Query OK, 0 rows affected (0.274 sec)

MySQL [test]&gt; SELECT HIGH_PRIORITY job_id, element_id, start_key, end_key FROM mysql.gc_delete_range;
+--------+------------+----------------------------------------+----------------------------------------+
| job_id | element_id | start_key                              | end_key                                |
+--------+------------+----------------------------------------+----------------------------------------+
|     58 |          1 | 7480000000000000385f698000000000000001 | 7480000000000000385f698000000000000002 |
+--------+------------+----------------------------------------+----------------------------------------+
1 row in set (0.002 sec)

MySQL [test]&gt; SELECT HIGH_PRIORITY job_id, element_id, start_key, end_key FROM mysql.gc_delete_range_done WHERE 1;
+--------+------------+--------------------+--------------------+
| job_id | element_id | start_key          | end_key            |
+--------+------------+--------------------+--------------------+
|     55 |         53 | 748000000000000035 | 748000000000000036 |
+--------+------------+--------------------+--------------------+
1 row in set (0.002 sec)
</code></pre>
<p>The to-be-deleted ranges are stored in <code>mysql.gc_delete_range</code>. They will be deleted in <a href="https://github.com/pingcap/tidb/blob/v5.2.1/store/gcworker/gc_worker.go#L686"><code>deleteRanges</code></a> in GC. After they are cleaned up, they will be moved into <code>mysql.gc_delete_range_done</code>, and double-checked after 24 hours.</p>
<p>Finally, the <code>GCWorker</code> is going to clean up the stale keys. From TiDB 5.0, only <code>distributed</code> mode is supported, this document will talk about <code>distributed</code> mode below.</p>
<p>Distributed GC is implemented by pushing up the safepoint in PD. Notice that the safepoint is monotonic. PD guarantees this by comparing the old and new values <a href="https://github.com/tikv/pd/blob/v5.2.1/server/grpc_service.go#L1081-L1127">here</a>.</p>
<pre><code class="language-go">// UpdateGCSafePoint implements gRPC PDServer.
func (s *Server) UpdateGCSafePoint(ctx context.Context, request *pdpb.UpdateGCSafePointRequest) (*pdpb.UpdateGCSafePointResponse, error) {
	...
	newSafePoint := request.SafePoint

	// Only save the safe point if it's greater than the previous one
	if newSafePoint &gt; oldSafePoint {
		if err := s.storage.SaveGCSafePoint(newSafePoint); err != nil {
			return nil, err
		}
		log.Info(&quot;updated gc safe point&quot;,
			zap.Uint64(&quot;safe-point&quot;, newSafePoint))
	} else if newSafePoint &lt; oldSafePoint {
		log.Warn(&quot;trying to update gc safe point&quot;,
			zap.Uint64(&quot;old-safe-point&quot;, oldSafePoint),
			zap.Uint64(&quot;new-safe-point&quot;, newSafePoint))
		newSafePoint = oldSafePoint
	}

	return &amp;pdpb.UpdateGCSafePointResponse{
		Header:       s.header(),
		NewSafePoint: newSafePoint,
	}, nil
}
</code></pre>
<p>If PD returns the same new safepoint as TiDB provides, TiDB takes this GC round success.</p>
<h3 id="distributed-gc-on-tikv"><a class="header" href="#distributed-gc-on-tikv">Distributed GC on TiKV</a></h3>
<p>As we talked above, TiDB only pushes up the safepoint in PD instead of cleaning up keys directly. Every TiKV has an inner <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/server/gc_worker/gc_manager.rs#L217-L237"><code>GcManager</code></a> with <code>safe_point</code> field.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(super) struct GcManager&lt;S: GcSafePointProvider, R: RegionInfoProvider, E: KvEngine&gt; {
    cfg: AutoGcConfig&lt;S, R&gt;,

    /// The current safe point. `GcManager` will try to update it periodically. When `safe_point` is
    /// updated, `GCManager` will start to do GC on all regions.
    safe_point: Arc&lt;AtomicU64&gt;,

    safe_point_last_check_time: Instant,

    /// Used to schedule `GcTask`s.
    worker_scheduler: Scheduler&lt;GcTask&lt;E&gt;&gt;,

    /// Holds the running status. It will tell us if `GcManager` should stop working and exit.
    gc_manager_ctx: GcManagerContext,

    cfg_tracker: GcWorkerConfigManager,
    feature_gate: FeatureGate,
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, TiKV tries to <a href="https://github.com/tikv/tikv/blob/v5.2.1/src/server/gc_worker/gc_manager.rs#L301-L322">pull safepoint</a> from PD every 10 seconds. If the pulled safepoint is greater than the local one, the local one will be pushed up, and meanwhile, a GC job is trigger in TiKV locally.</p>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>This document talked about how MVCC GC worked in TiDB system. The most basic requirement of GC is not to delete readable data. Due to the guarantee of GC, you don't need to care about that data is removed. The green GC, skips fetch snapshot when read locks, help to improve the performance of GC. There are some further performance-related topics of GC in TiKV which will be talked in TiKV Dev Guide.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="session"><a class="header" href="#session">Session</a></h1>
<p>The <code>session</code> package (and related packages such as <code>sessionctx</code> and <code>sessionctx/variable</code>) are responsible for maintaining the state of both sessions and transactions.</p>
<h2 id="new-session-origins"><a class="header" href="#new-session-origins">New session origins</a></h2>
<p>New connections are first established in the <code>server</code> package. After some initial protocol negotiation, the <code>server</code> package <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/server/driver_tidb.go#L181-L186">calls</a> <code>session.CreateSession()</code>. This function then calls <code>session.createSessionWithOpt()</code> (via <code>CreateSessionWithOpt()</code>) which creates the session.</p>
<p>Sessions used for internal server operations are usually created in a different manner, with the sessionctx being retrieved from a pool of sessions maintained by <code>domain</code>. For example:</p>
<pre><code class="language-go">dom := domain.GetDomain(e.ctx)
sysSessionPool := dom.SysSessionPool()
ctx, err := sysSessionPool.Get()
if err != nil {
    return nil, err
}
restrictedCtx := ctx.(sessionctx.Context)
restrictedCtx.GetSessionVars().InRestrictedSQL = true
</code></pre>
<p>Internal sessions will not show up in the output of <code>SHOW PROCESSLIST</code>, and skip all privilege checks because they do not have a privilege manager handle attached.</p>
<h2 id="system-variable-state"><a class="header" href="#system-variable-state">System variable state</a></h2>
<p>System variables follow similar semantics to MySQL:</p>
<ul>
<li>If a variable includes <code>SESSION</code> scope, the value is copied to the session state when the session is created.</li>
<li>Any changes to the <code>GLOBAL</code> value will not apply to any existing sessions.</li>
</ul>
<p>The state of the variables is stored in <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/session.go#L432-L958"><code>sessionVars</code></a>. The raw <em>string</em> values are stored in a map named <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/session.go#L449-L450"><code>systems</code></a>. This string value is used for persistence in the <code>mysql.global_variables</code> table.</p>
<p>For many variables, as well as a <em>string</em> value there is a typed field in <code>sessionVars</code>. For example:</p>
<p><code>SessionVars.systems[&quot;tidb_skip_utf8_check&quot;]</code> (string) maps to <code>SessionVars.SkipUTF8Check</code> (bool).</p>
<p>The typed value is set when the <code>SetSession</code> attached to the <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L1029-L1032">system variable definition</a> is called. For <code>tidb_skip_utf8_check</code> this is as follows:</p>
<pre><code class="language-go">{Scope: ScopeGlobal | ScopeSession, Name: TiDBSkipUTF8Check, Value: BoolToOnOff(DefSkipUTF8Check), Type: TypeBool, SetSession: func(s *SessionVars, val string) error {
	s.SkipUTF8Check = TiDBOptOn(val)
	return nil
}},
</code></pre>
<p>The <code>SetSession</code> function can also be considered an <code>Init</code> function, since it is called when the session is created and the values are copied from global scope. To disable <code>SetSession</code> from being called on creation, <code>skipInit</code> can be set to <code>true</code>. For example with <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L745-L752"><code>CharsetDatabase</code></a>:</p>
<pre><code class="language-go">{Scope: ScopeGlobal | ScopeSession, Name: CharsetDatabase, Value: mysql.DefaultCharset, skipInit: true, Validation: func(vars *SessionVars, normalizedValue string, originalValue string, scope ScopeFlag) (string, error) {
    return checkCharacterSet(normalizedValue, CharsetDatabase)
}, SetSession: func(s *SessionVars, val string) error {
	if cs, err := charset.GetCharsetInfo(val); err == nil {
		s.systems[CollationDatabase] = cs.DefaultCollation
	}
	return nil
}},
</code></pre>
<p>In the above example, skipping the <code>SetSession</code> function is useful because it prevents the <code>CollationDatabase</code> from being overwritten when the session is initialized. This is only expected if the user issues a statement to change the <code>CharsetDatabase</code> value.</p>
<h3 id="differences-from-mysql"><a class="header" href="#differences-from-mysql">Differences from MySQL</a></h3>
<p>In TiDB, changes to <code>GLOBAL</code> scoped system variables are propagated to other TiDB servers in the cluster and persist across restarts. The notification event to other servers is sent via an etcd channel in the call <code>domain.GetDomain(s).NotifyUpdateSysVarCache()</code>:</p>
<pre><code class="language-go">// replaceGlobalVariablesTableValue executes restricted sql updates the variable value
// It will then notify the etcd channel that the value has changed.
func (s *session) replaceGlobalVariablesTableValue(ctx context.Context, varName, val string) error {
	stmt, err := s.ParseWithParams(ctx, `REPLACE INTO %n.%n (variable_name, variable_value) VALUES (%?, %?)`, mysql.SystemDB, mysql.GlobalVariablesTable, varName, val)
	if err != nil {
		return err
	}
	_, _, err = s.ExecRestrictedStmt(ctx, stmt)
	domain.GetDomain(s).NotifyUpdateSysVarCache() // &lt;-- the notification happens here
	return err
}
</code></pre>
<p>Because <code>GLOBAL</code> scoped variables are propagated to other servers, TiDB also has a special concept of &quot;instance-scoped variables&quot;. An instance scoped variable is actually a <code>SESSION</code> scoped variable that has a <code>GetSession</code> method which returns data that is specific to an instance. For example, <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/sessionctx/variable/sysvar.go#L1315-L1321"><code>tidb_general_log</code></a>:</p>
<pre><code class="language-go">{Scope: ScopeSession, Name: TiDBGeneralLog, Value: BoolToOnOff(DefTiDBGeneralLog), Type: TypeBool, skipInit: true, SetSession: func(s *SessionVars, val string) error {
	ProcessGeneralLog.Store(TiDBOptOn(val))
	return nil
}, GetSession: func(s *SessionVars) (string, error) {
	return BoolToOnOff(ProcessGeneralLog.Load()), nil
}},
</code></pre>
<p>The decision to make an option such as <code>tidb_general_log</code> instance scoped is because it references a file on the local filesystem. This may create issues when global, as the path may not be writable on each tidb-server in the cluster.</p>
<p>As you can see by the <code>Scope: Session</code>, instance-scoped variables are not natively handled by the sysvar framework, but are instead denoted by the <code>GetSession()</code> function reading from a global location. The documentation for <a href="https://docs.pingcap.com/tidb/dev/system-variables#tidb_general_log"><code>tidb_general_log</code></a> also notes it as &quot;instance&quot; scoped by convention.</p>
<h2 id="transaction-state"><a class="header" href="#transaction-state">Transaction state</a></h2>
<p>The <code>session</code> struct (<code>s.txn</code>) is responsible for keeping modified key-value pairs in a <a href="https://github.com/pingcap/tidb/blob/bfbea9c3ef4232d76296a9c8390eb8b7da5bf45d/session/txn.go#L46-L71"><code>LazyTxn</code></a> until the transaction commits. A <code>commit</code> statement only sets the session variable state that it is <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/executor/simple.go#L701-L703">no longer in an active transaction</a>:</p>
<pre><code class="language-go">func (e *SimpleExec) executeCommit(s *ast.CommitStmt) {
	e.ctx.GetSessionVars().SetInTxn(false)
}
</code></pre>
<p>The function <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/session/tidb.go#L242-L267"><code>autoCommitAfterStmt()</code></a> which is called as part of <a href="https://github.com/pingcap/tidb/blob/246c59d5c926780235dd25aef27c469ffe376e21/session/tidb.go#L207-L224"><code>finishStmt()</code></a> is responsible for committing the transaction:</p>
<pre><code class="language-go">if !sessVars.InTxn() {
	if err := se.CommitTxn(ctx); err != nil {
		if _, ok := sql.(*executor.ExecStmt).StmtNode.(*ast.CommitStmt); ok {
			err = errors.Annotatef(err, &quot;previous statement: %s&quot;, se.GetSessionVars().PrevStmt)
		}
		return err
	}
	return nil
}
</code></pre>
<p>The <code>session.CommitTxn()</code> function will handle the <code>commit</code>, including retry (if permitted). There is also special handling for both pessimistic and optimistic transactions, as well as removing the key-value pairs which apply to temporary tables from the transaction buffer.</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="understand-tidb/the-lifecycle-of-a-statement.html">The lifecycle of a statement</a></li>
<li><a href="understand-tidb/privilege.html">Privilege management</a></li>
<li><a href="understand-tidb/transaction.html">Transaction</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="privilege"><a class="header" href="#privilege">Privilege</a></h1>
<p>At its core, TiDB's approach to user privileges is similar to that of MySQL:</p>
<ul>
<li>The privileges are stored in tables such as <code>mysql.user</code> and <code>mysql.db</code>.</li>
<li>The privilege tables are then loaded into an <a href="https://github.com/pingcap/tidb/blob/master/privilege/privileges/cache.go">in-memory cache</a>. The cache is then used by the privilege manager to determine the privileges of a user.</li>
<li>The cache is automatically updated when using privilege control statements such as <code>GRANT</code> and <code>REVOKE</code>. The statement <code>FLUSH PRIVILEGES</code> can also be used to manually reload the cache for when manual changes are made to the privilege tables.</li>
</ul>
<h2 id="behavior-differences-from-mysql"><a class="header" href="#behavior-differences-from-mysql">Behavior differences from MySQL</a></h2>
<p>Implicit updates to the privilege cache (i.e. when <code>GRANT</code> or <code>REVOKE</code> statements are executed) run immediately on the instance of TiDB that is executing the statement. A <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/domain/domain.go#L1355-L1373">notification is also sent to all TiDB instances</a> to rebuild their cache. This notification is sent asynchronously, so it is possible that when a load balancer is used, the cache will be out of date when attempting to reconnect to a TiDB instance immediately.</p>
<p>Because the asynchronous notifications do not guarantee delivery, TiDB will also <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/domain/domain.go#L852-L908">automatically rebuild the privilege cache</a> every 5-10 minutes in a loop. This behavior is not strictly MySQL compatible, because in MySQL the privilege cache will only ever be rebuilt from a <code>FLUSH PRIVILEGES</code> statement, a restart, or a privilege control statement.</p>
<p>Client certificate options are stored in the <code>mysql.global_priv</code> table instead of the <code>mysql.user</code> table. This behavior is not intentional, and may be changed in the future.</p>
<h2 id="adding-privilege-checks-to-a-statement"><a class="header" href="#adding-privilege-checks-to-a-statement">Adding privilege checks to a statement</a></h2>
<p>Some privilege checks are automatically assigned during plan building, for example ensuring that you have permissions to the tables that will be accessed. These checks are skipped for <code>information_schema</code> tables, and should you add an additional statement (such as <code>SHOW xyz</code>), you will also need to ensure that privilege checks are added.</p>
<p>Should you need to add privilege checks there are two options:</p>
<ol>
<li>
<p>During plan building you can attach <code>visitInfo</code> to the plan (examples: <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/planner/core/planbuilder.go#L745"><code>SET CONFIG</code></a>, <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/planner/core/planbuilder.go#L2378-L2380"><code>SHOW BACKUPS</code></a>)</p>
</li>
<li>
<p>In the executor function which handles the statement (examples: <a href="https://github.com/pingcap/tidb/blob/1a54708a7f8f86515236626c78e97a33d8adf583/executor/show.go#L368-L380"><code>SHOW PROCESSLIST</code></a>).</p>
</li>
</ol>
<p>The first option is recommended, as it is much less verbose. However, <code>visitInfo</code> does not handle cases where the statement can behave differently depending on the permissions of the user executing it. All users can execute the <code>SHOW PROCESSLIST</code> statement, but to see the sessions of other users requires the <code>PROCESS</code> privilege.</p>
<p><code>visitInfo</code> also only supports <strong>AND</strong> semantics. For complex scenarios (such as <code>DROP USER</code> requiring either <code>CREATE USER</code> <strong>OR</strong> <code>DELETE</code> privileges on the <code>mysql.user</code> table), option 2 is required.</p>
<h3 id="manually-checking-with-the-privilege-manager"><a class="header" href="#manually-checking-with-the-privilege-manager">Manually checking with the privilege manager</a></h3>
<p>For (2) above, manual checks should follow the following pattern:</p>
<pre><code class="language-go">checker := privilege.GetPrivilegeManager(e.ctx)
if checker != nil &amp;&amp; !checker.RequestVerification(ctx.GetSessionVars().ActiveRoles, schema.Name.L, table.Name.L, &quot;&quot;, mysql.AllPrivMask) {
    /* do something */
}
..
if checker == nil || !checker.RequestDynamicVerification(ctx.GetSessionVars().ActiveRoles, &quot;RESTRICTED_TABLES_ADMIN&quot;, false) {
    /* do something */
}
</code></pre>
<p>The check for <code>checker != nil</code> is important because for internal SQL statements the privilege manager is not present. These statements are expected to fall through and satisfy the privilege check.</p>
<h3 id="static-and-dynamic-privileges"><a class="header" href="#static-and-dynamic-privileges">Static and dynamic privileges</a></h3>
<p>Privileges fall into two categories:</p>
<ul>
<li>Static privileges: These are the &quot;traditional&quot; privileges such as <code>INSERT</code>, <code>UPDATE</code>, <code>SELECT</code>, <code>DELETE</code>, <code>SUPER</code>, <code>PROCESS</code> which have existed in MySQL for a long time. They can <em>usually</em> be assigned to a user on either a global or database/table level.</li>
<li>Dynamic privileges: These are new privileges such as <code>BACKUP_ADMIN</code>, <code>RESTORE_ADMIN</code>, <code>CONNECTION_ADMIN</code>. They can only be assigned on a global level, and each have their own &quot;grantable&quot; attribute.</li>
</ul>
<p>Dynamic privileges were introduced in MySQL 8.0 (and <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-dynamic-privileges.md">TiDB 5.1</a>) to solve a specific issue, which is that the <code>SUPER</code> privilege is too coarse. There are many scenarios where a user needs to be assigned the <code>SUPER</code> privilege to perform a specific action, but too many other privileges are granted at the same time.</p>
<p>Any statements added to TiDB <strong>should no longer require</strong> the <code>SUPER</code> privilege directly. Instead, a dynamic privilege should be added <a href="https://github.com/pingcap/tidb/blob/5e05922de6a253859cfbfe19356de8a2e2db39da/privilege/privileges/cache.go#L1009">which will be satified</a> by the <code>SUPER</code> privilege.</p>
<h3 id="security-enhanced-mode"><a class="header" href="#security-enhanced-mode">Security Enhanced Mode</a></h3>
<p>TiDB features an extension to MySQL called <a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-security-enhanced-mode.md">Security Enhanced Mode</a> (SEM), which is disabled by default. One of the main aims of SEM is to reduce the privileges of <code>SUPER</code> and instead require specific &quot;restricted&quot; dynamic privileges instead. The design is inspired by features such as &quot;Security Enhanced Linux&quot; (SeLinux) and AppArmor.</p>
<p>SEM plugs directly into the privilege manager, but the hard coded list of restricted objects lives in <a href="https://github.com/pingcap/tidb/blob/master/util/sem/sem.go"><code>./util/sem/*</code></a>. It is expected that over time SEM will protect against additional operations which are considered to be high risk or too broad.</p>
<h3 id="recommended-reading-1"><a class="header" href="#recommended-reading-1">Recommended Reading</a></h3>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-security-enhanced-mode.md">Technical Design: Security Enhanced Mode</a></li>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2021-03-09-dynamic-privileges.md">Technical Design: Dynamic Privileges</a></li>
<li><a href="https://dev.mysql.com/worklog/task/?id=8131">MySQL Worklog: Pluggable Dynamic Privileges</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plugin"><a class="header" href="#plugin">Plugin</a></h1>
<p>The plugin API allows TiDB to be extended with new features such as audit logging or IP allow/deny listing.</p>
<p>Sample code is provided for a basic audit logging plugin at <a href="https://github.com/pingcap/tidb/tree/master/plugin/conn_ip_example"><code>plugin/conn_ip_example/</code></a>. For an example on compiling TiDB and this plugin:</p>
<pre><code class="language-bash">plugin=&quot;conn_ip_example&quot;
cd cmd/pluginpkg
go install
cd ../../plugin/$plugin
pluginpkg -pkg-dir . -out-dir .
cd ../..
 
./bin/tidb-server -plugin-dir plugin/$plugin -plugin-load $plugin-1
</code></pre>
<p>An explanation of what this does:</p>
<ul>
<li><code>cd cmd/pluginpkg</code> and <code>go install</code> compiles the command line utility called <code>pluginpkg</code>, which is used to build the plugin.</li>
<li><code>pluginpkg -pkg-dir . -out-dir .</code> reads the plugin code + <code>manifest.toml</code> file and generates a shared object file for the plugin (<code>conn_ip_example-1.so</code>).</li>
<li>When the tidb-server starts, it can load plugins in a specified directory (<code>plugin-dir</code>).</li>
</ul>
<p>You can confirm which plugins are installed with the <code>SHOW PLUGINS</code> statement:</p>
<pre><code class="language-sql">mysql&gt; show plugins;
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
| Name            | Status       | Type  | Library                                                                              | License | Version |
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
| conn_ip_example | Ready-enable | Audit | /home/morgo/go/src/github.com/morgo/tidb/plugin/conn_ip_example/conn_ip_example-1.so |         | 1       |
+-----------------+--------------+-------+--------------------------------------------------------------------------------------+---------+---------+
1 row in set (0.00 sec)
</code></pre>
<h2 id="customizing-the-example-plugin"><a class="header" href="#customizing-the-example-plugin">Customizing the example plugin</a></h2>
<p>The manifest file describes the capabilities of the plugin, and which features it implements. For a basic version:</p>
<pre><code class="language-toml">name = &quot;conn_ip_example&quot;
kind = &quot;Audit&quot;
description = &quot;just a test&quot;
version = &quot;1&quot;
license = &quot;&quot; # Suggested: APLv2 or GPLv3. See https://choosealicense.com/ for details
validate = &quot;Validate&quot;
onInit = &quot;OnInit&quot;
onShutdown = &quot;OnShutdown&quot;
export = [
    {extPoint=&quot;OnGeneralEvent&quot;, impl=&quot;OnGeneralEvent&quot;},
    {extPoint=&quot;OnConnectionEvent&quot;, impl=&quot;OnConnectionEvent&quot;}
]
</code></pre>
<p>In addition to this basic example, plugins can also implement an <a href="https://github.com/pingcap/tidb/blob/d58d39e9476f2503a1e8790f78a0d25272d0aabe/plugin/spi.go#L51"><code>OnFlush</code></a> function. This is called when the statement <code>FLUSH TIDB PLUGINS pluginName</code> is executed. TiDB does not require plugins to implement a <code>OnFlush</code> function, but when specified it will call this method on all TiDB nodes in the cluster.</p>
<h3 id="onconnectionevent"><a class="header" href="#onconnectionevent">OnConnectionEvent</a></h3>
<p>The <code>OnConnectionEvent</code> is called when a new connection is initially created (<code>event plugin.ConnectionEvent == plugin.PreAuth</code>) and again when the connection is successfully established (<code>event plugin.ConnectionEvent == plugin.Connected</code>).</p>
<p>To prevent a connection from being created, an error should be returned for the event <code>plugin.PreAuth</code>.</p>
<h3 id="ongeneralevent"><a class="header" href="#ongeneralevent">OnGeneralEvent</a></h3>
<p>The <code>OnGeneralEvent</code> is called:</p>
<ul>
<li>Before a statement starts execution (<code>event plugin.GeneralEvent == plugin.Starting</code>)</li>
<li>Ater a statement has completed execution (<code>event plugin.GeneralEvent == plugin.Completed</code>)</li>
</ul>
<p>General events are useful for auditing operations performed by users. Because <a href="https://github.com/pingcap/tidb/blob/b2a1d21284b75e3137f499d8954071a7b32f7b3b/sessionctx/variable/session.go#L432-L436"><code>sctx SessionVars</code></a> is available in the <code>OnGeneralEvent</code> function, it is possible to obtain a lot of additional information about the statement being executed. For example:</p>
<ul>
<li><code>sctx.User</code> contains the <code>*auth.UserIdentity</code> of the user who is executing this session, and <code>sctx.ActiveRoles</code> contains the list of active roles associated with the session.</li>
<li><code>sctx.DBName</code> contains the name of the database the user is executing in.</li>
<li><code>sctx.StmtCtx</code> contains the context of the statement that was executed. For example <code>sctx.StmtCtx.SQLDigest()</code> can be called to get a digest of the executed statement, and <code>sctx.StmtCtx.Tables</code> contains a slice of tables that are accessed by the statement.</li>
</ul>
<p>The current implementation of <code>OnGeneralEvent</code> does not permit errors to be returned. It is possible that this may change in a future version, since this will allow pre-execution checks to be performed on statements.</p>
<h2 id="additional-reading"><a class="header" href="#additional-reading">Additional Reading</a></h2>
<ul>
<li><a href="https://github.com/pingcap/tidb/blob/master/docs/design/2018-12-10-plugin-framework.md">Plugin Framework RFC Proposal</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="project-management"><a class="header" href="#project-management">Project Management</a></h1>
<p>Practices for managing the TiDB project:</p>
<ul>
<li><a href="project-management/release-train-model.html">Release Train Model</a></li>
<li><a href="project-management/tidb-versioning.html">TiDB Versioning</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="release-train-model"><a class="header" href="#release-train-model">Release Train Model</a></h1>
<h2 id="what-is-the-release-train-model"><a class="header" href="#what-is-the-release-train-model">What is the release train model?</a></h2>
<p>Before introducing the concept of the release train model, let us take a review of the delivery mode of TiDB in the past.</p>
<p>In releases earlier than v5.0, the release frequency of TiDB major versions was a year or half a year, which is quite a long development cycle. The long development cycle has both benefits and drawbacks as follows:</p>
<ul>
<li>Benefits: the longer a development cycle is, the more features one release can deliver.</li>
<li>Drawbacks: the longer a development cycle is, the more difficulties we have to coordinate regression and acceptance tests, and the more possibly a delay happens. Also, if new feature requests are received during the long development cycle, these new features are added to the development backlog after the start of the development cycle. In this case, development tasks are hardly converged before the release date.</li>
</ul>
<p>Starting from v5.0, TiDB adopts the release train model, which is a product development model for requirements gathering, analysis, decision making, release, and issue feedback.</p>
<p>Just like a train delivering goods, decisions need to be made about the priorities of the goods, destination, arrival time, which train to load on, which carriage, etc., before the train departs.</p>
<p>The benefits of moving to the release train model are as follows:</p>
<ol>
<li>A shorter feedback cycle: users can benefit from features shipped faster.</li>
<li>Easier predictability for contributors and users:
<ol>
<li>Developers and reviewers can decide in advance the target release to deliver specific features.</li>
<li>If a feature misses a release train, we have a good idea of when the feature will show up later.</li>
<li>Users know when to expect their features.</li>
</ol>
</li>
<li>Transparency. There will be a published cut-off date (AKA code freeze) for the release and people will know about the date in advance. Hopefully this will remove the contention around which features will be included in the release.</li>
<li>Quality. we've seen issues pop up in release candidates due to last-minute features that didn't have proper time to bake in. More time between code freeze and release will let us test more, document more and resolve more issues.</li>
<li>Project visibility and activity. Having frequent releases improves our visibility and gives the community more opportunities to talk about TiDB.</li>
</ol>
<p>Because nothing is ever perfect, the release train model has some downsides as well:</p>
<ol>
<li>Most notably, for features that miss the code-freeze date for a release, we have to wait for a few months to catch the next release train. Most features will reach users faster as per benefit #1, but it is possible that a few features missing the code-freeze date might lose out.</li>
<li>With the frequent releases, users need to figure out which release to use. Also, having frequent new releases to upgrade may be a bit confusing.</li>
<li>Frequent releases means more branches. To fix a bug of an old release, we need to work on more old branches.</li>
</ol>
<p>We decided to experiment with release train model and see if the benefits for us as a community exceed the drawbacks. </p>
<h2 id="how-will-tidb-development-process-look-like"><a class="header" href="#how-will-tidb-development-process-look-like">How will TiDB development process look like?</a></h2>
<p>At this stage we are planning to make a release every two months.</p>
<p>Thus, a typical development cycle takes two months, which we call a sprint. For example, the development cycle of v5.2 is from the end of June to the end of August and is called Sprint 4.</p>
<p>Two weeks before the release date, the release manager will create a branch for the new release based on the master branch, publish a list of features to be included in the release, and also announce the code-freeze, after which only fixes for blocking bugs can be merged.</p>
<p>For the release train model, we strictly ensure that a release happens on the planned date. For example, we decide to deliver the v5.2 release by the end of August so we will stick to it. If any features cannot be completed by the code-freeze date, we will drop them and avoid taking them into the new release branch. In this case, the development in the master branch can still work as usual and those features will be moved to the following release. </p>
<p>Ideally, we would have started stabilization once we create the new release branch. After the code-freeze date, only pull requests of blocker bugs can be merged to the new release branch. In a rare scenario, it is possible that few features pass the code freeze bar but still fail to be completed on time. Such features will also be dropped from the release train in the end to meet the release deadline.</p>
<p>Developers who want to contribute features to TiDB could follow the procedure described in <a href="project-management/../contribute-to-tidb/make-a-proposal.html">Make a Proposal</a>. Once all the requirements are met and all the codes are merged into the master branch, the feature will be boxed into the nearest release.</p>
<p>Except for feature releases, there also exists patch releases. Patch releases are scheduled when needed, there is no fixed calendar for such releases. When a patch release is scheduled, there are two rounds of triage. A bug fix could only be boxed into a release when it occurs before triage. Get more information about TiDB releases and versions in <a href="project-management/tidb-versioning.html">TiDB versioning</a>.</p>
<h2 id="what-happens-if-features-are-not-completed"><a class="header" href="#what-happens-if-features-are-not-completed">What happens if features are not completed?</a></h2>
<p>Different features have different complexities. Some features can be implemented within a single release while some features span multiple releases. There are two conventional development strategies:</p>
<ol>
<li>
<p>Ensure that each feature is split into testable units and only testable units get merged. This means that a good set of unit tests and system tests are written for sub-tasks before they are merged. This approach ensures that the master branch is in a relatively stable state and can be released at any time.</p>
</li>
<li>
<p>Use feature branches. For a specific feature, the feature developers create a branch from the master branch and ensure that the branch is in sync with the master branch from time to time. Only when the feature developers and reviewers have a high level of confidence in the feature stability, the feature can be merged into master. This approach brings the additional overhead of branching and performing merges from time to time.</p>
</li>
</ol>
<p>With the release train model, to ensure that ongoing features do not affect the stability of the release, TiDB chooses feature branches strategy.</p>
<h2 id="current-maintained-releases"><a class="header" href="#current-maintained-releases">Current Maintained Releases</a></h2>
<table><thead><tr><th align="left">version</th><th align="left">branch</th><th align="left">status</th><th align="left">triage label</th><th align="left">latest release</th><th align="left">issue</th></tr></thead><tbody>
<tr><td align="left">v6.5</td><td align="left">release-6.5</td><td align="left">LTS</td><td align="left">affects-6.5</td><td align="left">v6.5.0</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/39325">https://github.com/pingcap/tidb/issues/39325</a></td></tr>
<tr><td align="left">v6.4</td><td align="left">release-6.4</td><td align="left">DMR</td><td align="left">affects-6.4</td><td align="left">v6.4.0-DMR</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/38364">https://github.com/pingcap/tidb/issues/38364</a></td></tr>
<tr><td align="left">v6.3</td><td align="left">release-6.3</td><td align="left">DMR</td><td align="left">affects-6.3</td><td align="left">v6.3.0-DMR</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/37368">https://github.com/pingcap/tidb/issues/37368</a></td></tr>
<tr><td align="left">v6.2</td><td align="left">release-6.2</td><td align="left">DMR</td><td align="left">affects-6.2</td><td align="left">v6.2.0-DMR</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/35452">https://github.com/pingcap/tidb/issues/35452</a></td></tr>
<tr><td align="left">v6.1</td><td align="left">release-6.1</td><td align="left">LTS</td><td align="left">affects-6.1</td><td align="left">v6.1.3</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/39327">https://github.com/pingcap/tidb/issues/39327</a></td></tr>
<tr><td align="left">v6.0</td><td align="left">release-6.0</td><td align="left">DMR</td><td align="left">affects-6.0</td><td align="left">v6.0.0-DMR</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/32381">https://github.com/pingcap/tidb/issues/32381</a></td></tr>
<tr><td align="left">v5.0</td><td align="left">release-5.0</td><td align="left">LTS</td><td align="left">affects-5.0</td><td align="left">v5.0.6</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/30609">https://github.com/pingcap/tidb/issues/30609</a></td></tr>
<tr><td align="left">v5.1</td><td align="left">release-5.1</td><td align="left">LTS</td><td align="left">affects-5.1</td><td align="left">v5.1.5</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/32148">https://github.com/pingcap/tidb/issues/32148</a></td></tr>
<tr><td align="left">v5.2</td><td align="left">release-5.2</td><td align="left">LTS</td><td align="left">affects-5.2</td><td align="left">v5.2.4</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/30608">https://github.com/pingcap/tidb/issues/30608</a></td></tr>
<tr><td align="left">v5.3</td><td align="left">release-5.3</td><td align="left">LTS</td><td align="left">affects-5.3</td><td align="left">v5.3.4</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/39077">https://github.com/pingcap/tidb/issues/39077</a></td></tr>
<tr><td align="left">v5.4</td><td align="left">release-5.4</td><td align="left">LTS</td><td align="left">affects-5.4</td><td align="left">v5.4.3</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/37748">https://github.com/pingcap/tidb/issues/37748</a></td></tr>
<tr><td align="left">v4.0</td><td align="left">release-4.0</td><td align="left">LTS</td><td align="left">affects-4.0</td><td align="left">v4.0.16</td><td align="left"><a href="https://github.com/pingcap/tidb/issues/29856">https://github.com/pingcap/tidb/issues/29856</a></td></tr>
</tbody></table>
<p>For more versions' information, please check <a href="https://github.com/pingcap/tidb/projects/63">https://github.com/pingcap/tidb/projects/63</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tidb-versioning"><a class="header" href="#tidb-versioning">TiDB Versioning</a></h1>
<p>TiDB versioning has the form <code>X.Y.Z</code> where <code>X.Y</code> refers to the release series and <code>Z</code> refers to the patch number. Starting with TiDB 6.0, TiDB is released as two different release series:</p>
<ul>
<li>LTS(Long-Term Support) Releases</li>
<li>DMR(Development Milestone) Releases</li>
</ul>
<h2 id="lts-releases"><a class="header" href="#lts-releases">LTS Releases</a></h2>
<p>LTS releases are made available approximately every six months. They carry new features and improvements and are recommended to deploy into production environments. There will be patch releases based on the LTS releases in their lifecycle. Example versions:</p>
<ul>
<li><code>5.4</code></li>
<li><code>6.1</code></li>
</ul>
<p>Release <code>4.0</code> and <code>5.x</code> are treated like LTS releases although they are earlier than <code>6.0</code>.</p>
<h2 id="dmr-releases"><a class="header" href="#dmr-releases">DMR Releases</a></h2>
<p>DMR releases are made available approximately every two months. Every 3rd DMR release turns into a LTS release. Same as LTS releases, a DMR release introduces new features and improvements. But there is no patch releases based on the DMR release. Bugs in the DMR release are going to be fixed in the next DMR/LTS releases. There is a <code>-DMR</code> suffix of DMR versioning. Example versions:</p>
<ul>
<li><code>6.0.0-DMR</code></li>
<li><code>6.2.0-DMR</code></li>
</ul>
<h2 id="patch-releases"><a class="header" href="#patch-releases">Patch Releases</a></h2>
<p>Patch releases generally include bug fixes for LTS releases. There is no fixed release schedule for patch releases. Example versions:</p>
<ul>
<li><code>6.1.1</code></li>
<li><code>6.1.2</code></li>
</ul>
<h2 id="historical-versioning"><a class="header" href="#historical-versioning">Historical Versioning</a></h2>
<p>There are some other versioning in history which are not used any more.</p>
<h3 id="gageneral-availability-releases"><a class="header" href="#gageneral-availability-releases">GA(General Availability) Releases</a></h3>
<p>Stable release series, released after RC releases. GA releases are recommended for production usage. Example versions:</p>
<ul>
<li><code>2.1 GA</code></li>
<li><code>5.0 GA</code></li>
</ul>
<h3 id="rcrelease-candidate-releases"><a class="header" href="#rcrelease-candidate-releases">RC(Release Candidate) Releases</a></h3>
<p>RC releases introduces new features and improvements and meant for early test. Comparing with Beta releases, RC releases are much more stable and suitable for test, but not suitable for production usage. Example versions:</p>
<ul>
<li><code>2.0-RC1</code></li>
<li><code>3.0.0-rc.1</code></li>
</ul>
<h3 id="beta-releases"><a class="header" href="#beta-releases">Beta Releases</a></h3>
<p>Beta releases introduces new features and improvements. Comparing with Alpha releases, Beta releases shall not carry any critical bugs. Early adopters could use Beta releases to try new features. Example versions:</p>
<ul>
<li><code>1.1 Beta</code></li>
<li><code>4.0.0-beta.1</code></li>
</ul>
<h3 id="alpha-releases"><a class="header" href="#alpha-releases">Alpha Releases</a></h3>
<p>The very first releases in a series. Used for fundamental functionality and performance test. Example versions:</p>
<ul>
<li><code>1.1 Alpha</code></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="extending-tidb"><a class="header" href="#extending-tidb">Extending TiDB</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="add-a-function"><a class="header" href="#add-a-function">Add a function</a></h1>
<p>To add a builtin function to TiDB the best practice is to look at MySQL first and try to implement the function in such a way that it is commpatible. Avoid adding functions that are already deprecated in MySQL or that might soon be deprecrated.</p>
<p>Here we will implement a <code>HELLO()</code> function that has one argument that is a string. For this you need <a href="extending-tidb/../get-started/build-tidb-from-source.html#clone">a clone of the pingcap/tidb repository</a></p>
<pre><code>sql&gt; SELECT HELLO(&quot;world&quot;);
ERROR: 1305 (42000): FUNCTION test.hello does not exist
</code></pre>
<p>The first step is to define the name of the function in <code>parser/ast/functions.go</code>:</p>
<pre><code class="language-go">// List scalar function names.
const (
...
        Hello = &quot;hello&quot;
)
</code></pre>
<p>This links <code>ast.Hello</code> with &quot;hello&quot;. Note that the lookup for the function is done with the lowercase name, so always use the lowercase name, otherwise it won't find the function.</p>
<p>The next step is to modify <code>expression/builtin.go</code></p>
<pre><code class="language-go">var funcs = map[string]functionClass{
...
        ast.Hello: &amp;helloFunctionClass{baseFunctionClass{ast.Hello, 1, 1}},
}
</code></pre>
<p>Now we need to define <code>helloFunctionClass</code>. We will do this in <code>expression/builtin_string.go</code>. The functions are organised in multiple files, pick the one that fits best.</p>
<pre><code class="language-go">var (
...
        _ functionClass = &amp;helloFunctionClass{}
)
...
var (
        _ builtinFunc = &amp;builtinHelloSig{}
)
...
type helloFunctionClass struct {
        baseFunctionClass
}

func (c *helloFunctionClass) getFunction(ctx sessionctx.Context, args []Expression) (builtinFunc, error) {
        if err := c.verifyArgs(args); err != nil {
                return nil, err
        }
        bf, err := newBaseBuiltinFuncWithTp(ctx, c.funcName, args, types.ETString, types.ETString)
        if err != nil {
                return nil, err
        }
        sig := &amp;builtinHelloSig{bf}
        return sig, nil
}

type builtinHelloSig struct {
        baseBuiltinFunc
}

func (b *builtinHelloSig) Clone() builtinFunc {
        newSig := &amp;builtinHelloSig{}
        newSig.cloneFrom(&amp;b.baseBuiltinFunc)
        return newSig
}

func (b *builtinHelloSig) evalString(row chunk.Row) (name string, isNull bool, err error) {
        name, isNull, err = b.args[0].EvalString(b.ctx, row)
        if isNull || err != nil {
                return name, isNull, err
        }
        return &quot;hello &quot; + name, false, nil
}
</code></pre>
<p>The <code>getFunction()</code> method can return different functions depending on the type and number of arguments. This example always returns the same function that has one string argument and returns a string.</p>
<p>Here <code>evalString()</code> gets called for every row. If the function returns an integer you have to use <code>evalInt</code> and there are also functions for Decimal, Real, Time and JSON.</p>
<p>Now you need to <a href="extending-tidb/../get-started/build-tidb-from-source.html#build">build TiDB</a> again and try the newly added function.</p>
<p>The final result:</p>
<pre><code>sql&gt; SELECT HELLO(&quot;world&quot;);
+----------------+
| HELLO(&quot;world&quot;) |
+----------------+
| hello world    |
+----------------+
1 row in set (0.0007 sec)
</code></pre>
<p>To show the function with multiple rows:</p>
<pre><code>sql&gt; WITH names AS (SELECT &quot;Europe&quot; AS &quot;name&quot; UNION ALL SELECT &quot;America&quot; UNION ALL SELECT &quot;China&quot;)
   -&gt; SELECT HELLO(name) FROM names;
+---------------+
| HELLO(name)   |
+---------------+
| hello Europe  |
| hello America |
| hello China   |
+---------------+
3 rows in set (0.0008 sec)
</code></pre>
<p>For <a href="extending-tidb/../get-started/write-and-run-unit-tests.html">testing</a> have a look at <code>expression/builtin_string_test.go</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
